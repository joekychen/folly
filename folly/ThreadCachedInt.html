<!DOCTYPE html>
<html><head><title>joekychen/folly » folly › ThreadCachedInt.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>ThreadCachedInt.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2012 Facebook, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="cm"> * you may not use this file except in compliance with the License.</span>
<span class="cm"> * You may obtain a copy of the License at</span>
<span class="cm"> *</span>
<span class="cm"> *   http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="cm"> *</span>
<span class="cm"> * Unless required by applicable law or agreed to in writing, software</span>
<span class="cm"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="cm"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="cm"> * See the License for the specific language governing permissions and</span>
<span class="cm"> * limitations under the License.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * Higher performance (up to 10x) atomic increment using thread caching.</span>
<span class="cm"> *</span>
<span class="cm"> * @author Spencer Ahrens (sahrens)</span>
<span class="cm"> */</span>

<span class="cp">#ifndef FOLLY_THREADCACHEDINT_H</span>
<span class="cp">#define FOLLY_THREADCACHEDINT_H</span>

<span class="cp">#include &lt;atomic&gt;</span>
<span class="cp">#include &quot;folly/Likely.h&quot;</span>
<span class="cp">#include &quot;folly/ThreadLocal.h&quot;</span>

<span class="n">namespace</span> <span class="n">folly</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>Note that readFull requires holding a lock and iterating through all of the
thread local objects with the same Tag, so if you have a lot of
ThreadCachedInt's you should considering breaking up the Tag space even
further.</p></td><td class="code"><div class="highlight"><pre><span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">IntT</span><span class="p">,</span> <span class="n">class</span> <span class="n">Tag</span><span class="o">=</span><span class="n">IntT</span><span class="o">&gt;</span>
<span class="n">class</span> <span class="n">ThreadCachedInt</span> <span class="o">:</span> <span class="n">boost</span><span class="o">::</span><span class="n">noncopyable</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">IntCache</span><span class="p">;</span>

 <span class="nl">public:</span>
  <span class="n">explicit</span> <span class="nf">ThreadCachedInt</span><span class="p">(</span><span class="n">IntT</span> <span class="n">initialVal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">cacheSize</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">target_</span><span class="p">(</span><span class="n">initialVal</span><span class="p">),</span> <span class="n">cacheSize_</span><span class="p">(</span><span class="n">cacheSize</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="nf">increment</span><span class="p">(</span><span class="n">IntT</span> <span class="n">inc</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">cache</span> <span class="o">=</span> <span class="n">cache_</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="n">cache</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">parent_</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">cache</span> <span class="o">=</span> <span class="n">new</span> <span class="n">IntCache</span><span class="p">(</span><span class="o">*</span><span class="n">this</span><span class="p">);</span>
      <span class="n">cache_</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">cache</span><span class="o">-&gt;</span><span class="n">increment</span><span class="p">(</span><span class="n">inc</span><span class="p">);</span>
  <span class="p">}</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>Quickly grabs the current value which may not include some cached
increments.</p></td><td class="code"><div class="highlight"><pre>  <span class="n">IntT</span> <span class="n">readFast</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">target_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">}</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>Reads the current value plus all the cached increments.  Requires grabbing
a lock, so this is significantly slower than readFast().</p></td><td class="code"><div class="highlight"><pre>  <span class="n">IntT</span> <span class="n">readFull</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">IntT</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">readFast</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">cache</span> <span class="o">:</span> <span class="n">cache_</span><span class="p">.</span><span class="n">accessAllThreads</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cache</span><span class="p">.</span><span class="n">reset_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">ret</span> <span class="o">+=</span> <span class="n">cache</span><span class="p">.</span><span class="n">val_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
  <span class="p">}</span></pre></div></td></tr>


<tr id="section-5"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-5">&#182;</a></div><p>Quickly reads and resets current value (doesn't reset cached increments).</p></td><td class="code"><div class="highlight"><pre>  <span class="n">IntT</span> <span class="n">readFastAndReset</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">target_</span><span class="p">.</span><span class="n">exchange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span>
  <span class="p">}</span></pre></div></td></tr>


<tr id="section-6"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-6">&#182;</a></div><p>This function is designed for accumulating into another counter, where you
only want to count each increment once.  It can still get the count a
little off, however, but it should be much better than calling readFull()
and set(0) sequentially.</p></td><td class="code"><div class="highlight"><pre>  <span class="n">IntT</span> <span class="n">readFullAndReset</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">IntT</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">readFastAndReset</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">cache</span> <span class="o">:</span> <span class="n">cache_</span><span class="p">.</span><span class="n">accessAllThreads</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cache</span><span class="p">.</span><span class="n">reset_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">ret</span> <span class="o">+=</span> <span class="n">cache</span><span class="p">.</span><span class="n">val_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
        <span class="n">cache</span><span class="p">.</span><span class="n">reset_</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">setCacheSize</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">newSize</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cacheSize_</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">newSize</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">uint32_t</span> <span class="n">getCacheSize</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">cacheSize_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">ThreadCachedInt</span><span class="o">&amp;</span> <span class="n">operator</span><span class="o">+=</span><span class="p">(</span><span class="n">IntT</span> <span class="n">inc</span><span class="p">)</span> <span class="p">{</span> <span class="n">increment</span><span class="p">(</span><span class="n">inc</span><span class="p">);</span> <span class="k">return</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">ThreadCachedInt</span><span class="o">&amp;</span> <span class="n">operator</span><span class="o">-=</span><span class="p">(</span><span class="n">IntT</span> <span class="n">inc</span><span class="p">)</span> <span class="p">{</span> <span class="n">increment</span><span class="p">(</span><span class="o">-</span><span class="n">inc</span><span class="p">);</span> <span class="k">return</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span> <span class="p">}</span></pre></div></td></tr>


<tr id="section-7"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-7">&#182;</a></div><p>pre-increment (we don't support post-increment)</p></td><td class="code"><div class="highlight"><pre>  <span class="n">ThreadCachedInt</span><span class="o">&amp;</span> <span class="n">operator</span><span class="o">++</span><span class="p">()</span> <span class="p">{</span> <span class="n">increment</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="k">return</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">ThreadCachedInt</span><span class="o">&amp;</span> <span class="n">operator</span><span class="o">--</span><span class="p">()</span> <span class="p">{</span> <span class="n">increment</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span> <span class="k">return</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span> <span class="p">}</span></pre></div></td></tr>


<tr id="section-8"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-8">&#182;</a></div><p>Thread-safe set function.
This is a best effort implementation. In some edge cases, there could be
data loss (missing counts)</p></td><td class="code"><div class="highlight"><pre>  <span class="kt">void</span> <span class="n">set</span><span class="p">(</span><span class="n">IntT</span> <span class="n">newVal</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">cache</span> <span class="o">:</span> <span class="n">cache_</span><span class="p">.</span><span class="n">accessAllThreads</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">cache</span><span class="p">.</span><span class="n">reset_</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">target_</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">newVal</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span>
  <span class="p">}</span></pre></div></td></tr>


<tr id="section-9"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-9">&#182;</a></div><p>This is a little tricky - it's possible that our IntCaches are still alive
in another thread and will get destroyed after this destructor runs, so we
need to make sure we signal that this parent is dead.</p></td><td class="code"><div class="highlight"><pre>  <span class="o">~</span><span class="n">ThreadCachedInt</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">cache</span> <span class="o">:</span> <span class="n">cache_</span><span class="p">.</span><span class="n">accessAllThreads</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">cache</span><span class="p">.</span><span class="n">parent_</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

 <span class="nl">private:</span>
  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">IntT</span><span class="o">&gt;</span> <span class="n">target_</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="n">cacheSize_</span><span class="p">;</span>
  <span class="n">ThreadLocalPtr</span><span class="o">&lt;</span><span class="n">IntCache</span><span class="p">,</span><span class="n">Tag</span><span class="o">&gt;</span> <span class="n">cache_</span><span class="p">;</span> <span class="c1">// Must be last for dtor ordering</span></pre></div></td></tr>


<tr id="section-10"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-10">&#182;</a></div><p>This should only ever be modified by one thread</p></td><td class="code"><div class="highlight"><pre>  <span class="k">struct</span> <span class="n">IntCache</span> <span class="p">{</span>
    <span class="n">ThreadCachedInt</span><span class="o">*</span> <span class="n">parent_</span><span class="p">;</span>
    <span class="n">mutable</span> <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">IntT</span><span class="o">&gt;</span> <span class="n">val_</span><span class="p">;</span>
    <span class="n">mutable</span> <span class="kt">uint32_t</span> <span class="n">numUpdates_</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">bool</span><span class="o">&gt;</span> <span class="n">reset_</span><span class="p">;</span>

    <span class="n">explicit</span> <span class="nf">IntCache</span><span class="p">(</span><span class="n">ThreadCachedInt</span><span class="o">&amp;</span> <span class="n">parent</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">parent_</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="p">),</span> <span class="n">val_</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">numUpdates_</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">reset_</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span> <span class="p">{}</span>

    <span class="kt">void</span> <span class="nf">increment</span><span class="p">(</span><span class="n">IntT</span> <span class="n">inc</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">LIKELY</span><span class="p">(</span><span class="o">!</span><span class="n">reset_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">)))</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-11"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-11">&#182;</a></div><p>This thread is the only writer to val_, so it's fine do do
a relaxed load and do the addition non-atomically.</p></td><td class="code"><div class="highlight"><pre>        <span class="n">val_</span><span class="p">.</span><span class="n">store</span><span class="p">(</span>
          <span class="n">val_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">)</span> <span class="o">+</span> <span class="n">inc</span><span class="p">,</span>
          <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span>
        <span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">val_</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">inc</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
        <span class="n">reset_</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="nb">false</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="o">++</span><span class="n">numUpdates_</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="n">numUpdates_</span> <span class="o">&gt;</span>
                   <span class="n">parent_</span><span class="o">-&gt;</span><span class="n">cacheSize_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">)))</span> <span class="p">{</span>
        <span class="n">flush</span><span class="p">();</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">flush</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
      <span class="n">parent_</span><span class="o">-&gt;</span><span class="n">target_</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="n">val_</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span>
      <span class="n">val_</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span>
      <span class="n">numUpdates_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="o">~</span><span class="n">IntCache</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">parent_</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">flush</span><span class="p">();</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">};</span>

<span class="p">}</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/folly",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
