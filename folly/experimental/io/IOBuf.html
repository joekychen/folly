<!DOCTYPE html>
<html><head><title>joekychen/folly » folly › experimental › io › IOBuf.cpp

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>IOBuf.cpp</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2012 Facebook, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="cm"> * you may not use this file except in compliance with the License.</span>
<span class="cm"> * You may obtain a copy of the License at</span>
<span class="cm"> *</span>
<span class="cm"> *   http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="cm"> *</span>
<span class="cm"> * Unless required by applicable law or agreed to in writing, software</span>
<span class="cm"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="cm"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="cm"> * See the License for the specific language governing permissions and</span>
<span class="cm"> * limitations under the License.</span>
<span class="cm"> */</span>

<span class="cp">#define __STDC_LIMIT_MACROS</span>

<span class="cp">#include &quot;folly/experimental/io/IOBuf.h&quot;</span>

<span class="cp">#include &quot;folly/Malloc.h&quot;</span>
<span class="cp">#include &quot;folly/Likely.h&quot;</span>

<span class="cp">#include &lt;stdexcept&gt;</span>
<span class="cp">#include &lt;assert.h&gt;</span>
<span class="cp">#include &lt;stdint.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>

<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="p">;</span>

<span class="k">namespace</span> <span class="n">folly</span> <span class="p">{</span>

<span class="k">const</span> <span class="n">uint32_t</span> <span class="n">IOBuf</span><span class="o">::</span><span class="n">kMaxIOBufSize</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>Note: Applying offsetof() to an IOBuf is legal according to C++11, since
IOBuf is a standard-layout class.  However, this isn't legal with earlier
C++ standards, which require that offsetof() only be used with POD types.</p>

<p>This code compiles with g++ 4.6, but not with g++ 4.4 or earlier versions.</p></td><td class="code"><div class="highlight"><pre><span class="k">const</span> <span class="n">uint32_t</span> <span class="n">IOBuf</span><span class="o">::</span><span class="n">kMaxInternalDataSize</span> <span class="o">=</span>
  <span class="n">kMaxIOBufSize</span> <span class="o">-</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">folly</span><span class="o">::</span><span class="n">IOBuf</span><span class="p">,</span> <span class="n">int_</span><span class="p">.</span><span class="n">buf</span><span class="p">);</span>

<span class="n">IOBuf</span><span class="o">::</span><span class="n">SharedInfo</span><span class="o">::</span><span class="n">SharedInfo</span><span class="p">()</span>
  <span class="o">:</span> <span class="n">freeFn</span><span class="p">(</span><span class="nb">NULL</span><span class="p">),</span>
    <span class="n">userData</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>Use relaxed memory ordering here.  Since we are creating a new SharedInfo,
no other threads should be referring to it yet.</p></td><td class="code"><div class="highlight"><pre>  <span class="n">refcount</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">IOBuf</span><span class="o">::</span><span class="n">SharedInfo</span><span class="o">::</span><span class="n">SharedInfo</span><span class="p">(</span><span class="n">FreeFunction</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">freeFn</span><span class="p">(</span><span class="n">fn</span><span class="p">),</span>
    <span class="n">userData</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>Use relaxed memory ordering here.  Since we are creating a new SharedInfo,
no other threads should be referring to it yet.</p></td><td class="code"><div class="highlight"><pre>  <span class="n">refcount</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span><span class="o">*</span> <span class="n">IOBuf</span><span class="o">::</span><span class="k">operator</span> <span class="k">new</span><span class="p">(</span><span class="n">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-5"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-5">&#182;</a></div><p>Since IOBuf::create() manually allocates space for some IOBuf objects
using malloc(), override operator new so that all IOBuf objects are
always allocated using malloc().  This way operator delete can always know
that free() is the correct way to deallocate the memory.</p></td><td class="code"><div class="highlight"><pre>  <span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-6"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-6">&#182;</a></div><p>operator new is not allowed to return NULL</p></td><td class="code"><div class="highlight"><pre>  <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="n">ptr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">bad_alloc</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="o">*</span> <span class="n">IOBuf</span><span class="o">::</span><span class="k">operator</span> <span class="k">new</span><span class="p">(</span><span class="n">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">kMaxIOBufSize</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">IOBuf</span><span class="o">::</span><span class="k">operator</span> <span class="k">delete</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-7"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-7">&#182;</a></div><p>For small buffers, IOBuf::create() manually allocates the space for the
IOBuf object using malloc().  Therefore we override delete to ensure that
the IOBuf space is freed using free() rather than a normal delete.</p></td><td class="code"><div class="highlight"><pre>  <span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IOBuf</span><span class="o">&gt;</span> <span class="n">IOBuf</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">uint32_t</span> <span class="n">capacity</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-8"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-8">&#182;</a></div><p>If the desired capacity is less than kMaxInternalDataSize,
just allocate a single region large enough for both the IOBuf header and
the data.</p></td><td class="code"><div class="highlight"><pre>  <span class="k">if</span> <span class="p">(</span><span class="n">capacity</span> <span class="o">&lt;=</span> <span class="n">kMaxInternalDataSize</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">buf</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">kMaxIOBufSize</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="n">buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">bad_alloc</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">uint8_t</span><span class="o">*</span> <span class="n">bufEnd</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">uint8_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="o">+</span> <span class="n">kMaxIOBufSize</span><span class="p">;</span>
    <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IOBuf</span><span class="o">&gt;</span> <span class="n">iobuf</span><span class="p">(</span><span class="k">new</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="n">IOBuf</span><span class="p">(</span><span class="n">bufEnd</span><span class="p">));</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">iobuf</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">capacity</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">iobuf</span><span class="p">;</span>
  <span class="p">}</span></pre></div></td></tr>


<tr id="section-9"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-9">&#182;</a></div><p>Allocate an external buffer</p></td><td class="code"><div class="highlight"><pre>  <span class="n">uint8_t</span><span class="o">*</span> <span class="n">buf</span><span class="p">;</span>
  <span class="n">SharedInfo</span><span class="o">*</span> <span class="n">sharedInfo</span><span class="p">;</span>
  <span class="n">uint32_t</span> <span class="n">actualCapacity</span><span class="p">;</span>
  <span class="n">allocExtBuffer</span><span class="p">(</span><span class="n">capacity</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sharedInfo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">actualCapacity</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-10"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-10">&#182;</a></div><p>Allocate the IOBuf header</p></td><td class="code"><div class="highlight"><pre>  <span class="k">try</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IOBuf</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">IOBuf</span><span class="p">(</span><span class="n">kExtAllocated</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                                       <span class="n">buf</span><span class="p">,</span> <span class="n">actualCapacity</span><span class="p">,</span>
                                       <span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                                       <span class="n">sharedInfo</span><span class="p">));</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
    <span class="n">free</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
    <span class="k">throw</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IOBuf</span><span class="o">&gt;</span> <span class="n">IOBuf</span><span class="o">::</span><span class="n">takeOwnership</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="n">uint32_t</span> <span class="n">capacity</span><span class="p">,</span>
                                       <span class="n">FreeFunction</span> <span class="n">freeFn</span><span class="p">,</span>
                                       <span class="kt">void</span><span class="o">*</span> <span class="n">userData</span><span class="p">,</span>
                                       <span class="kt">bool</span> <span class="n">freeOnError</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">SharedInfo</span><span class="o">*</span> <span class="n">sharedInfo</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="n">sharedInfo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SharedInfo</span><span class="p">(</span><span class="n">freeFn</span><span class="p">,</span> <span class="n">userData</span><span class="p">);</span>

    <span class="n">uint8_t</span><span class="o">*</span> <span class="n">bufPtr</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">uint8_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IOBuf</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">IOBuf</span><span class="p">(</span><span class="n">kExtUserSupplied</span><span class="p">,</span> <span class="n">kFlagFreeSharedInfo</span><span class="p">,</span>
                                       <span class="n">bufPtr</span><span class="p">,</span> <span class="n">capacity</span><span class="p">,</span>
                                       <span class="n">bufPtr</span><span class="p">,</span> <span class="n">capacity</span><span class="p">,</span>
                                       <span class="n">sharedInfo</span><span class="p">));</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
    <span class="k">delete</span> <span class="n">sharedInfo</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">freeOnError</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">freeFn</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">try</span> <span class="p">{</span>
          <span class="n">freeFn</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">userData</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-11"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-11">&#182;</a></div><p>The user's free function is not allowed to throw.</p></td><td class="code"><div class="highlight"><pre>          <span class="n">abort</span><span class="p">();</span>
        <span class="p">}</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">free</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">throw</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IOBuf</span><span class="o">&gt;</span> <span class="n">IOBuf</span><span class="o">::</span><span class="n">wrapBuffer</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="n">uint32_t</span> <span class="n">capacity</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-12"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-12">&#182;</a></div><p>We cast away the const-ness of the buffer here.
This is okay since IOBuf users must use unshare() to create a copy of
this buffer before writing to the buffer.</p></td><td class="code"><div class="highlight"><pre>  <span class="n">uint8_t</span><span class="o">*</span> <span class="n">bufPtr</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">uint8_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
  <span class="k">return</span> <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IOBuf</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">IOBuf</span><span class="p">(</span><span class="n">kExtUserSupplied</span><span class="p">,</span> <span class="n">kFlagUserOwned</span><span class="p">,</span>
                                     <span class="n">bufPtr</span><span class="p">,</span> <span class="n">capacity</span><span class="p">,</span>
                                     <span class="n">bufPtr</span><span class="p">,</span> <span class="n">capacity</span><span class="p">,</span>
                                     <span class="nb">NULL</span><span class="p">));</span>
<span class="p">}</span>

<span class="n">IOBuf</span><span class="o">::</span><span class="n">IOBuf</span><span class="p">(</span><span class="n">uint8_t</span><span class="o">*</span> <span class="n">end</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">next_</span><span class="p">(</span><span class="k">this</span><span class="p">),</span>
    <span class="n">prev_</span><span class="p">(</span><span class="k">this</span><span class="p">),</span>
    <span class="n">data_</span><span class="p">(</span><span class="n">int_</span><span class="p">.</span><span class="n">buf</span><span class="p">),</span>
    <span class="n">length_</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
    <span class="n">flags_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">int_</span><span class="p">.</span><span class="n">buf</span> <span class="o">==</span> <span class="n">kMaxInternalDataSize</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">uint8_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="k">this</span><span class="p">)</span> <span class="o">==</span> <span class="n">kMaxIOBufSize</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">IOBuf</span><span class="o">::</span><span class="n">IOBuf</span><span class="p">(</span><span class="n">ExtBufTypeEnum</span> <span class="n">type</span><span class="p">,</span>
             <span class="n">uint32_t</span> <span class="n">flags</span><span class="p">,</span>
             <span class="n">uint8_t</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span>
             <span class="n">uint32_t</span> <span class="n">capacity</span><span class="p">,</span>
             <span class="n">uint8_t</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span>
             <span class="n">uint32_t</span> <span class="n">length</span><span class="p">,</span>
             <span class="n">SharedInfo</span><span class="o">*</span> <span class="n">sharedInfo</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">next_</span><span class="p">(</span><span class="k">this</span><span class="p">),</span>
    <span class="n">prev_</span><span class="p">(</span><span class="k">this</span><span class="p">),</span>
    <span class="n">data_</span><span class="p">(</span><span class="n">data</span><span class="p">),</span>
    <span class="n">length_</span><span class="p">(</span><span class="n">length</span><span class="p">),</span>
    <span class="n">flags_</span><span class="p">(</span><span class="n">kFlagExt</span> <span class="o">|</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">ext_</span><span class="p">.</span><span class="n">capacity</span> <span class="o">=</span> <span class="n">capacity</span><span class="p">;</span>
  <span class="n">ext_</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
  <span class="n">ext_</span><span class="p">.</span><span class="n">buf</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
  <span class="n">ext_</span><span class="p">.</span><span class="n">sharedInfo</span> <span class="o">=</span> <span class="n">sharedInfo</span><span class="p">;</span>

  <span class="n">assert</span><span class="p">(</span><span class="n">data</span> <span class="o">&gt;=</span> <span class="n">buf</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">data</span> <span class="o">+</span> <span class="n">length</span> <span class="o">&lt;=</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">capacity</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">kFlagUserOwned</span><span class="p">)</span> <span class="o">==</span>
         <span class="p">(</span><span class="n">sharedInfo</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">));</span>
<span class="p">}</span>

<span class="n">IOBuf</span><span class="o">::~</span><span class="n">IOBuf</span><span class="p">()</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-13"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-13">&#182;</a></div><p>Destroying an IOBuf destroys the entire chain.
Users of IOBuf should only explicitly delete the head of any chain.
The other elements in the chain will be automatically destroyed.</p></td><td class="code"><div class="highlight"><pre>  <span class="k">while</span> <span class="p">(</span><span class="n">next_</span> <span class="o">!=</span> <span class="k">this</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-14"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-14">&#182;</a></div><p>Since unlink() returns unique_ptr() and we don't store it,
it will automatically delete the unlinked element.</p></td><td class="code"><div class="highlight"><pre>    <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">next_</span><span class="o">-&gt;</span><span class="n">unlink</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">flags_</span> <span class="o">&amp;</span> <span class="n">kFlagExt</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">decrementRefcount</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">IOBuf</span><span class="o">::</span><span class="n">empty</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">const</span> <span class="n">IOBuf</span><span class="o">*</span> <span class="n">current</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
  <span class="k">do</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next_</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">current</span> <span class="o">!=</span> <span class="k">this</span><span class="p">);</span>
  <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">uint32_t</span> <span class="n">IOBuf</span><span class="o">::</span><span class="n">countChainElements</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">uint32_t</span> <span class="n">numElements</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">IOBuf</span><span class="o">*</span> <span class="n">current</span> <span class="o">=</span> <span class="n">next_</span><span class="p">;</span> <span class="n">current</span> <span class="o">!=</span> <span class="k">this</span><span class="p">;</span> <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next_</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">numElements</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">numElements</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">uint64_t</span> <span class="n">IOBuf</span><span class="o">::</span><span class="n">computeChainDataLength</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">uint64_t</span> <span class="n">fullLength</span> <span class="o">=</span> <span class="n">length_</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">IOBuf</span><span class="o">*</span> <span class="n">current</span> <span class="o">=</span> <span class="n">next_</span><span class="p">;</span> <span class="n">current</span> <span class="o">!=</span> <span class="k">this</span><span class="p">;</span> <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next_</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fullLength</span> <span class="o">+=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">length_</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">fullLength</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">IOBuf</span><span class="o">::</span><span class="n">prependChain</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IOBuf</span><span class="o">&gt;&amp;&amp;</span> <span class="n">iobuf</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-15"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-15">&#182;</a></div><p>Take ownership of the specified IOBuf</p></td><td class="code"><div class="highlight"><pre>  <span class="n">IOBuf</span><span class="o">*</span> <span class="n">other</span> <span class="o">=</span> <span class="n">iobuf</span><span class="p">.</span><span class="n">release</span><span class="p">();</span></pre></div></td></tr>


<tr id="section-16"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-16">&#182;</a></div><p>Remember the pointer to the tail of the other chain</p></td><td class="code"><div class="highlight"><pre>  <span class="n">IOBuf</span><span class="o">*</span> <span class="n">otherTail</span> <span class="o">=</span> <span class="n">other</span><span class="o">-&gt;</span><span class="n">prev_</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-17"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-17">&#182;</a></div><p>Hook up prev<em>->next</em> to point at the start of the other chain,
and other->prev_ to point at prev_</p></td><td class="code"><div class="highlight"><pre>  <span class="n">prev_</span><span class="o">-&gt;</span><span class="n">next_</span> <span class="o">=</span> <span class="n">other</span><span class="p">;</span>
  <span class="n">other</span><span class="o">-&gt;</span><span class="n">prev_</span> <span class="o">=</span> <span class="n">prev_</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-18"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-18">&#182;</a></div><p>Hook up otherTail->next_ to point at us,
and prev_ to point back at otherTail,</p></td><td class="code"><div class="highlight"><pre>  <span class="n">otherTail</span><span class="o">-&gt;</span><span class="n">next_</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
  <span class="n">prev_</span> <span class="o">=</span> <span class="n">otherTail</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IOBuf</span><span class="o">&gt;</span> <span class="n">IOBuf</span><span class="o">::</span><span class="n">clone</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IOBuf</span><span class="o">&gt;</span> <span class="n">newHead</span><span class="p">(</span><span class="n">cloneOne</span><span class="p">());</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">IOBuf</span><span class="o">*</span> <span class="n">current</span> <span class="o">=</span> <span class="n">next_</span><span class="p">;</span> <span class="n">current</span> <span class="o">!=</span> <span class="k">this</span><span class="p">;</span> <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next_</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">newHead</span><span class="o">-&gt;</span><span class="n">prependChain</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">cloneOne</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">newHead</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IOBuf</span><span class="o">&gt;</span> <span class="n">IOBuf</span><span class="o">::</span><span class="n">cloneOne</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">flags_</span> <span class="o">&amp;</span> <span class="n">kFlagExt</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IOBuf</span><span class="o">&gt;</span> <span class="n">iobuf</span><span class="p">(</span><span class="k">new</span> <span class="n">IOBuf</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">ExtBufTypeEnum</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ext_</span><span class="p">.</span><span class="n">type</span><span class="p">),</span>
                                      <span class="n">flags_</span><span class="p">,</span> <span class="n">ext_</span><span class="p">.</span><span class="n">buf</span><span class="p">,</span> <span class="n">ext_</span><span class="p">.</span><span class="n">capacity</span><span class="p">,</span>
                                      <span class="n">data_</span><span class="p">,</span> <span class="n">length_</span><span class="p">,</span>
                                      <span class="n">ext_</span><span class="p">.</span><span class="n">sharedInfo</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ext_</span><span class="p">.</span><span class="n">sharedInfo</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">ext_</span><span class="p">.</span><span class="n">sharedInfo</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_acq_rel</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">iobuf</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-19"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-19">&#182;</a></div><p>We have an internal data buffer that cannot be shared
Allocate a new IOBuf and copy the data into it.</p></td><td class="code"><div class="highlight"><pre>    <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IOBuf</span><span class="o">&gt;</span> <span class="n">iobuf</span><span class="p">(</span><span class="n">IOBuf</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">kMaxInternalDataSize</span><span class="p">));</span>
    <span class="n">assert</span><span class="p">((</span><span class="n">iobuf</span><span class="o">-&gt;</span><span class="n">flags_</span> <span class="o">&amp;</span> <span class="n">kFlagExt</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">iobuf</span><span class="o">-&gt;</span><span class="n">data_</span> <span class="o">+=</span> <span class="n">headroom</span><span class="p">();</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">iobuf</span><span class="o">-&gt;</span><span class="n">data_</span><span class="p">,</span> <span class="n">data_</span><span class="p">,</span> <span class="n">length_</span><span class="p">);</span>
    <span class="n">iobuf</span><span class="o">-&gt;</span><span class="n">length_</span> <span class="o">=</span> <span class="n">length_</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">iobuf</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">IOBuf</span><span class="o">::</span><span class="n">unshareOneSlow</span><span class="p">()</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-20"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-20">&#182;</a></div><p>Internal buffers are always unshared, so unshareOneSlow() can only be
called for external buffers</p></td><td class="code"><div class="highlight"><pre>  <span class="n">assert</span><span class="p">(</span><span class="n">flags_</span> <span class="o">&amp;</span> <span class="n">kFlagExt</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-21"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-21">&#182;</a></div><p>Allocate a new buffer for the data</p></td><td class="code"><div class="highlight"><pre>  <span class="n">uint8_t</span><span class="o">*</span> <span class="n">buf</span><span class="p">;</span>
  <span class="n">SharedInfo</span><span class="o">*</span> <span class="n">sharedInfo</span><span class="p">;</span>
  <span class="n">uint32_t</span> <span class="n">actualCapacity</span><span class="p">;</span>
  <span class="n">allocExtBuffer</span><span class="p">(</span><span class="n">ext_</span><span class="p">.</span><span class="n">capacity</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sharedInfo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">actualCapacity</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-22"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-22">&#182;</a></div><p>Copy the data
Maintain the same amount of headroom.  Since we maintained the same
minimum capacity we also maintain at least the same amount of tailroom.</p></td><td class="code"><div class="highlight"><pre>  <span class="n">uint32_t</span> <span class="n">headlen</span> <span class="o">=</span> <span class="n">headroom</span><span class="p">();</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">headlen</span><span class="p">,</span> <span class="n">data_</span><span class="p">,</span> <span class="n">length_</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-23"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-23">&#182;</a></div><p>Release our reference on the old buffer</p></td><td class="code"><div class="highlight"><pre>  <span class="n">decrementRefcount</span><span class="p">();</span></pre></div></td></tr>


<tr id="section-24"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-24">&#182;</a></div><p>Make sure kFlagExt is set, and kFlagUserOwned and kFlagFreeSharedInfo
are not set.</p></td><td class="code"><div class="highlight"><pre>  <span class="n">flags_</span> <span class="o">=</span> <span class="n">kFlagExt</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-25"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-25">&#182;</a></div><p>Update the buffer pointers to point to the new buffer</p></td><td class="code"><div class="highlight"><pre>  <span class="n">data_</span> <span class="o">=</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">headlen</span><span class="p">;</span>
  <span class="n">ext_</span><span class="p">.</span><span class="n">buf</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
  <span class="n">ext_</span><span class="p">.</span><span class="n">sharedInfo</span> <span class="o">=</span> <span class="n">sharedInfo</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">IOBuf</span><span class="o">::</span><span class="n">unshareChained</span><span class="p">()</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-26"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-26">&#182;</a></div><p>unshareChained() should only be called if we are part of a chain of
multiple IOBufs.  The caller should have already verified this.</p></td><td class="code"><div class="highlight"><pre>  <span class="n">assert</span><span class="p">(</span><span class="n">isChained</span><span class="p">());</span>

  <span class="n">IOBuf</span><span class="o">*</span> <span class="n">current</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">isSharedOne</span><span class="p">())</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-27"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-27">&#182;</a></div><p>we have to unshare</p></td><td class="code"><div class="highlight"><pre>      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next_</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">current</span> <span class="o">==</span> <span class="k">this</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-28"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-28">&#182;</a></div><p>None of the IOBufs in the chain are shared,
so return without doing anything</p></td><td class="code"><div class="highlight"><pre>      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span></pre></div></td></tr>


<tr id="section-29"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-29">&#182;</a></div><p>We have to unshare.  Let coalesceSlow() do the work.</p></td><td class="code"><div class="highlight"><pre>  <span class="n">coalesceSlow</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">IOBuf</span><span class="o">::</span><span class="n">coalesceSlow</span><span class="p">(</span><span class="n">size_t</span> <span class="n">maxLength</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-30"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-30">&#182;</a></div><p>coalesceSlow() should only be called if we are part of a chain of multiple
IOBufs.  The caller should have already verified this.</p></td><td class="code"><div class="highlight"><pre>  <span class="n">assert</span><span class="p">(</span><span class="n">isChained</span><span class="p">());</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">length_</span> <span class="o">&lt;</span> <span class="n">maxLength</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-31"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-31">&#182;</a></div><p>Compute the length of the entire chain</p></td><td class="code"><div class="highlight"><pre>  <span class="n">uint64_t</span> <span class="n">newLength</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">IOBuf</span><span class="o">*</span> <span class="n">end</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
  <span class="k">do</span> <span class="p">{</span>
    <span class="n">newLength</span> <span class="o">+=</span> <span class="n">end</span><span class="o">-&gt;</span><span class="n">length_</span><span class="p">;</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">end</span><span class="o">-&gt;</span><span class="n">next_</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">newLength</span> <span class="o">&lt;</span> <span class="n">maxLength</span> <span class="o">&amp;&amp;</span> <span class="n">end</span> <span class="o">!=</span> <span class="k">this</span><span class="p">);</span>

  <span class="n">uint64_t</span> <span class="n">newHeadroom</span> <span class="o">=</span> <span class="n">headroom</span><span class="p">();</span>
  <span class="n">uint64_t</span> <span class="n">newTailroom</span> <span class="o">=</span> <span class="n">end</span><span class="o">-&gt;</span><span class="n">prev_</span><span class="o">-&gt;</span><span class="n">tailroom</span><span class="p">();</span>
  <span class="n">uint64_t</span> <span class="n">newCapacity</span> <span class="o">=</span> <span class="n">newLength</span> <span class="o">+</span> <span class="n">newHeadroom</span> <span class="o">+</span> <span class="n">newTailroom</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">newCapacity</span> <span class="o">&gt;</span> <span class="n">UINT32_MAX</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">overflow_error</span><span class="p">(</span><span class="s">&quot;IOBuf chain too large to coalesce&quot;</span><span class="p">);</span>
  <span class="p">}</span></pre></div></td></tr>


<tr id="section-32"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-32">&#182;</a></div><p>Allocate space for the coalesced buffer.
We always convert to an external buffer, even if we happened to be an
internal buffer before.</p></td><td class="code"><div class="highlight"><pre>  <span class="n">uint8_t</span><span class="o">*</span> <span class="n">newBuf</span><span class="p">;</span>
  <span class="n">SharedInfo</span><span class="o">*</span> <span class="n">newInfo</span><span class="p">;</span>
  <span class="n">uint32_t</span> <span class="n">actualCapacity</span><span class="p">;</span>
  <span class="n">allocExtBuffer</span><span class="p">(</span><span class="n">newCapacity</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newBuf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newInfo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">actualCapacity</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-33"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-33">&#182;</a></div><p>Copy the data into the new buffer</p></td><td class="code"><div class="highlight"><pre>  <span class="n">uint8_t</span><span class="o">*</span> <span class="n">newData</span> <span class="o">=</span> <span class="n">newBuf</span> <span class="o">+</span> <span class="n">newHeadroom</span><span class="p">;</span>
  <span class="n">uint8_t</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">newData</span><span class="p">;</span>
  <span class="n">IOBuf</span><span class="o">*</span> <span class="n">current</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
  <span class="k">do</span> <span class="p">{</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">data_</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">length_</span><span class="p">);</span>
    <span class="n">p</span> <span class="o">+=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">length_</span><span class="p">;</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next_</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">current</span> <span class="o">!=</span> <span class="n">end</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-34"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-34">&#182;</a></div><p>Point at the new buffer</p></td><td class="code"><div class="highlight"><pre>  <span class="k">if</span> <span class="p">(</span><span class="n">flags_</span> <span class="o">&amp;</span> <span class="n">kFlagExt</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">decrementRefcount</span><span class="p">();</span>
  <span class="p">}</span></pre></div></td></tr>


<tr id="section-35"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-35">&#182;</a></div><p>Make sure kFlagExt is set, and kFlagUserOwned and kFlagFreeSharedInfo
are not set.</p></td><td class="code"><div class="highlight"><pre>  <span class="n">flags_</span> <span class="o">=</span> <span class="n">kFlagExt</span><span class="p">;</span>

  <span class="n">ext_</span><span class="p">.</span><span class="n">capacity</span> <span class="o">=</span> <span class="n">actualCapacity</span><span class="p">;</span>
  <span class="n">ext_</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">kExtAllocated</span><span class="p">;</span>
  <span class="n">ext_</span><span class="p">.</span><span class="n">buf</span> <span class="o">=</span> <span class="n">newBuf</span><span class="p">;</span>
  <span class="n">ext_</span><span class="p">.</span><span class="n">sharedInfo</span> <span class="o">=</span> <span class="n">newInfo</span><span class="p">;</span>
  <span class="n">data_</span> <span class="o">=</span> <span class="n">newData</span><span class="p">;</span>
  <span class="n">length_</span> <span class="o">=</span> <span class="n">newLength</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-36"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-36">&#182;</a></div><p>Separate from the rest of our chain.
Since we don't store the unique_ptr returned by separateChain(),
this will immediately delete the returned subchain.</p></td><td class="code"><div class="highlight"><pre>  <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">separateChain</span><span class="p">(</span><span class="n">next_</span><span class="p">,</span> <span class="n">end</span><span class="o">-&gt;</span><span class="n">prev_</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-37"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-37">&#182;</a></div><p>We should be only element left in the chain now</p></td><td class="code"><div class="highlight"><pre>  <span class="n">assert</span><span class="p">(</span><span class="n">length_</span> <span class="o">&gt;=</span> <span class="n">maxLength</span> <span class="o">||</span> <span class="o">!</span><span class="n">isChained</span><span class="p">());</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">IOBuf</span><span class="o">::</span><span class="n">decrementRefcount</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">flags_</span> <span class="o">&amp;</span> <span class="n">kFlagExt</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-38"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-38">&#182;</a></div><p>Externally owned buffers don't have a SharedInfo object and aren't managed
by the reference count</p></td><td class="code"><div class="highlight"><pre>  <span class="k">if</span> <span class="p">(</span><span class="n">flags_</span> <span class="o">&amp;</span> <span class="n">kFlagUserOwned</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">ext_</span><span class="p">.</span><span class="n">sharedInfo</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span></pre></div></td></tr>


<tr id="section-39"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-39">&#182;</a></div><p>Decrement the refcount</p></td><td class="code"><div class="highlight"><pre>  <span class="n">uint32_t</span> <span class="n">newcnt</span> <span class="o">=</span> <span class="n">ext_</span><span class="p">.</span><span class="n">sharedInfo</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">.</span><span class="n">fetch_sub</span><span class="p">(</span>
      <span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_acq_rel</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-40"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-40">&#182;</a></div><p>Note that fetch_sub() returns the value before we decremented.
If it is 1, we were the only remaining user; if it is greater there are
still other users.</p></td><td class="code"><div class="highlight"><pre>  <span class="k">if</span> <span class="p">(</span><span class="n">newcnt</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span></pre></div></td></tr>


<tr id="section-41"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-41">&#182;</a></div><p>We were the last user.  Free the buffer</p></td><td class="code"><div class="highlight"><pre>  <span class="k">if</span> <span class="p">(</span><span class="n">ext_</span><span class="p">.</span><span class="n">sharedInfo</span><span class="o">-&gt;</span><span class="n">freeFn</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
      <span class="n">ext_</span><span class="p">.</span><span class="n">sharedInfo</span><span class="o">-&gt;</span><span class="n">freeFn</span><span class="p">(</span><span class="n">ext_</span><span class="p">.</span><span class="n">buf</span><span class="p">,</span> <span class="n">ext_</span><span class="p">.</span><span class="n">sharedInfo</span><span class="o">-&gt;</span><span class="n">userData</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-42"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-42">&#182;</a></div><p>The user's free function should never throw.  Otherwise we might
throw from the IOBuf destructor.  Other code paths like coalesce()
also assume that decrementRefcount() cannot throw.</p></td><td class="code"><div class="highlight"><pre>      <span class="n">abort</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">free</span><span class="p">(</span><span class="n">ext_</span><span class="p">.</span><span class="n">buf</span><span class="p">);</span>
  <span class="p">}</span></pre></div></td></tr>


<tr id="section-43"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-43">&#182;</a></div><p>Free the SharedInfo if it was allocated separately.</p>

<p>This is only used by takeOwnership().</p>

<p>To avoid this special case handling in decrementRefcount(), we could have
takeOwnership() set a custom freeFn() that calls the user's free function
then frees the SharedInfo object.  (This would require that
takeOwnership() store the user's free function with its allocated
SharedInfo object.)  However, handling this specially with a flag seems
like it shouldn't be problematic.</p></td><td class="code"><div class="highlight"><pre>  <span class="k">if</span> <span class="p">(</span><span class="n">flags_</span> <span class="o">&amp;</span> <span class="n">kFlagFreeSharedInfo</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">delete</span> <span class="n">ext_</span><span class="p">.</span><span class="n">sharedInfo</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">IOBuf</span><span class="o">::</span><span class="n">reserveSlow</span><span class="p">(</span><span class="n">uint32_t</span> <span class="n">minHeadroom</span><span class="p">,</span> <span class="n">uint32_t</span> <span class="n">minTailroom</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">size_t</span> <span class="n">newCapacity</span> <span class="o">=</span> <span class="p">(</span><span class="n">size_t</span><span class="p">)</span><span class="n">length_</span> <span class="o">+</span> <span class="n">minHeadroom</span> <span class="o">+</span> <span class="n">minTailroom</span><span class="p">;</span>
  <span class="n">CHECK_LT</span><span class="p">(</span><span class="n">newCapacity</span><span class="p">,</span> <span class="n">UINT32_MAX</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-44"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-44">&#182;</a></div><p>We'll need to reallocate the buffer.
There are a few options.
- If we have enough total room, move the data around in the buffer
  and adjust the data_ pointer.
- If we're using an internal buffer, we'll switch to an external
  buffer with enough headroom and tailroom.
- If we have enough headroom (headroom() >= minHeadroom) but not too much
  (so we don't waste memory), we can try one of two things, depending on
  whether we use jemalloc or not:
  - If using jemalloc, we can try to expand in place, avoiding a memcpy()
  - If not using jemalloc and we don't have too much to copy,
    we'll use realloc() (note that realloc might have to copy
    headroom + data + tailroom, see smartRealloc in folly/Malloc.h)
- Otherwise, bite the bullet and reallocate.</p></td><td class="code"><div class="highlight"><pre>  <span class="k">if</span> <span class="p">(</span><span class="n">headroom</span><span class="p">()</span> <span class="o">+</span> <span class="n">tailroom</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">minHeadroom</span> <span class="o">+</span> <span class="n">minTailroom</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uint8_t</span><span class="o">*</span> <span class="n">newData</span> <span class="o">=</span> <span class="n">writableBuffer</span><span class="p">()</span> <span class="o">+</span> <span class="n">minHeadroom</span><span class="p">;</span>
    <span class="n">memmove</span><span class="p">(</span><span class="n">newData</span><span class="p">,</span> <span class="n">data_</span><span class="p">,</span> <span class="n">length_</span><span class="p">);</span>
    <span class="n">data_</span> <span class="o">=</span> <span class="n">newData</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">size_t</span> <span class="n">newAllocatedCapacity</span> <span class="o">=</span> <span class="n">goodExtBufferSize</span><span class="p">(</span><span class="n">newCapacity</span><span class="p">);</span>
  <span class="n">uint8_t</span><span class="o">*</span> <span class="n">newBuffer</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
  <span class="n">uint32_t</span> <span class="n">newHeadroom</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">uint32_t</span> <span class="n">oldHeadroom</span> <span class="o">=</span> <span class="n">headroom</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">((</span><span class="n">flags_</span> <span class="o">&amp;</span> <span class="n">kFlagExt</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">length_</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">oldHeadroom</span> <span class="o">&gt;=</span> <span class="n">minHeadroom</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">usingJEMalloc</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">size_t</span> <span class="n">headSlack</span> <span class="o">=</span> <span class="n">oldHeadroom</span> <span class="o">-</span> <span class="n">minHeadroom</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-45"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-45">&#182;</a></div><p>We assume that tailroom is more useful and more important than
tailroom (not least because realloc / rallocm allow us to grow the
buffer at the tail, but not at the head)  So, if we have more headroom
than we need, we consider that "wasted".  We arbitrarily define "too
much" headroom to be 25% of the capacity.</p></td><td class="code"><div class="highlight"><pre>      <span class="k">if</span> <span class="p">(</span><span class="n">headSlack</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">&lt;=</span> <span class="n">newCapacity</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">size_t</span> <span class="n">allocatedCapacity</span> <span class="o">=</span> <span class="n">capacity</span><span class="p">()</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">SharedInfo</span><span class="p">);</span>
        <span class="kt">void</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">ext_</span><span class="p">.</span><span class="n">buf</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">allocatedCapacity</span> <span class="o">&gt;=</span> <span class="n">jemallocMinInPlaceExpandable</span><span class="p">)</span> <span class="p">{</span>
          <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">rallocm</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newAllocatedCapacity</span><span class="p">,</span> <span class="n">newAllocatedCapacity</span><span class="p">,</span>
                          <span class="mi">0</span><span class="p">,</span> <span class="n">ALLOCM_NO_MOVE</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="n">ALLOCM_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">newBuffer</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">uint8_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
            <span class="n">newHeadroom</span> <span class="o">=</span> <span class="n">oldHeadroom</span><span class="p">;</span>
          <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="n">ALLOCM_ERR_OOM</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-46"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-46">&#182;</a></div><p>shouldn't happen as we don't actually allocate new memory
(due to ALLOCM<em>NO</em>MOVE)</p></td><td class="code"><div class="highlight"><pre>            <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">bad_alloc</span><span class="p">();</span>
          <span class="p">}</span></pre></div></td></tr>


<tr id="section-47"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-47">&#182;</a></div><p>if ALLOCM<em>ERR</em>NOT_MOVED, do nothing, fall back to
malloc/memcpy/free</p></td><td class="code"><div class="highlight"><pre>        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>  <span class="c1">// Not using jemalloc</span>
      <span class="n">size_t</span> <span class="n">copySlack</span> <span class="o">=</span> <span class="n">capacity</span><span class="p">()</span> <span class="o">-</span> <span class="n">length_</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">copySlack</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">length_</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">void</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">realloc</span><span class="p">(</span><span class="n">ext_</span><span class="p">.</span><span class="n">buf</span><span class="p">,</span> <span class="n">newAllocatedCapacity</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">nullptr</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">bad_alloc</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="n">newBuffer</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">uint8_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="n">newHeadroom</span> <span class="o">=</span> <span class="n">oldHeadroom</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span></pre></div></td></tr>


<tr id="section-48"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-48">&#182;</a></div><p>None of the previous reallocation strategies worked (or we're using
an internal buffer).  malloc/copy/free.</p></td><td class="code"><div class="highlight"><pre>  <span class="k">if</span> <span class="p">(</span><span class="n">newBuffer</span> <span class="o">==</span> <span class="n">nullptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">newAllocatedCapacity</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">nullptr</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">bad_alloc</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">newBuffer</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">uint8_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">newBuffer</span> <span class="o">+</span> <span class="n">minHeadroom</span><span class="p">,</span> <span class="n">data_</span><span class="p">,</span> <span class="n">length_</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">flags_</span> <span class="o">&amp;</span> <span class="n">kFlagExt</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">free</span><span class="p">(</span><span class="n">ext_</span><span class="p">.</span><span class="n">buf</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">newHeadroom</span> <span class="o">=</span> <span class="n">minHeadroom</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">SharedInfo</span><span class="o">*</span> <span class="n">info</span><span class="p">;</span>
  <span class="n">uint32_t</span> <span class="n">cap</span><span class="p">;</span>
  <span class="n">initExtBuffer</span><span class="p">(</span><span class="n">newBuffer</span><span class="p">,</span> <span class="n">newAllocatedCapacity</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cap</span><span class="p">);</span>

  <span class="n">flags_</span> <span class="o">=</span> <span class="n">kFlagExt</span><span class="p">;</span>

  <span class="n">ext_</span><span class="p">.</span><span class="n">capacity</span> <span class="o">=</span> <span class="n">cap</span><span class="p">;</span>
  <span class="n">ext_</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">kExtAllocated</span><span class="p">;</span>
  <span class="n">ext_</span><span class="p">.</span><span class="n">buf</span> <span class="o">=</span> <span class="n">newBuffer</span><span class="p">;</span>
  <span class="n">ext_</span><span class="p">.</span><span class="n">sharedInfo</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>
  <span class="n">data_</span> <span class="o">=</span> <span class="n">newBuffer</span> <span class="o">+</span> <span class="n">newHeadroom</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-49"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-49">&#182;</a></div><p>length_ is unchanged</p></td><td class="code"><div class="highlight"><pre><span class="p">}</span>

<span class="kt">void</span> <span class="n">IOBuf</span><span class="o">::</span><span class="n">allocExtBuffer</span><span class="p">(</span><span class="n">uint32_t</span> <span class="n">minCapacity</span><span class="p">,</span>
                           <span class="n">uint8_t</span><span class="o">**</span> <span class="n">bufReturn</span><span class="p">,</span>
                           <span class="n">SharedInfo</span><span class="o">**</span> <span class="n">infoReturn</span><span class="p">,</span>
                           <span class="n">uint32_t</span><span class="o">*</span> <span class="n">capacityReturn</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">size_t</span> <span class="n">mallocSize</span> <span class="o">=</span> <span class="n">goodExtBufferSize</span><span class="p">(</span><span class="n">minCapacity</span><span class="p">);</span>
  <span class="n">uint8_t</span><span class="o">*</span> <span class="n">buf</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">uint8_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">malloc</span><span class="p">(</span><span class="n">mallocSize</span><span class="p">));</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="n">buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">bad_alloc</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="n">initExtBuffer</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">mallocSize</span><span class="p">,</span> <span class="n">infoReturn</span><span class="p">,</span> <span class="n">capacityReturn</span><span class="p">);</span>
  <span class="o">*</span><span class="n">bufReturn</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">size_t</span> <span class="n">IOBuf</span><span class="o">::</span><span class="n">goodExtBufferSize</span><span class="p">(</span><span class="n">uint32_t</span> <span class="n">minCapacity</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-50"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-50">&#182;</a></div><p>Determine how much space we should allocate.  We'll store the SharedInfo
for the external buffer just after the buffer itself.  (We store it just
after the buffer rather than just before so that the code can still just
use free(ext_.buf) to free the buffer.)</p></td><td class="code"><div class="highlight"><pre>  <span class="n">size_t</span> <span class="n">minSize</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">minCapacity</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">SharedInfo</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-51"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-51">&#182;</a></div><p>Add room for padding so that the SharedInfo will be aligned on an 8-byte
boundary.</p></td><td class="code"><div class="highlight"><pre>  <span class="n">minSize</span> <span class="o">=</span> <span class="p">(</span><span class="n">minSize</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">7</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-52"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-52">&#182;</a></div><p>Use goodMallocSize() to bump up the capacity to a decent size to request
from malloc, so we can use all of the space that malloc will probably give
us anyway.</p></td><td class="code"><div class="highlight"><pre>  <span class="k">return</span> <span class="n">goodMallocSize</span><span class="p">(</span><span class="n">minSize</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">IOBuf</span><span class="o">::</span><span class="n">initExtBuffer</span><span class="p">(</span><span class="n">uint8_t</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">mallocSize</span><span class="p">,</span>
                          <span class="n">SharedInfo</span><span class="o">**</span> <span class="n">infoReturn</span><span class="p">,</span>
                          <span class="n">uint32_t</span><span class="o">*</span> <span class="n">capacityReturn</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-53"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-53">&#182;</a></div><p>Find the SharedInfo storage at the end of the buffer
and construct the SharedInfo.</p></td><td class="code"><div class="highlight"><pre>  <span class="n">uint8_t</span><span class="o">*</span> <span class="n">infoStart</span> <span class="o">=</span> <span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">mallocSize</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">SharedInfo</span><span class="p">);</span>
  <span class="n">SharedInfo</span><span class="o">*</span> <span class="n">sharedInfo</span> <span class="o">=</span> <span class="k">new</span><span class="p">(</span><span class="n">infoStart</span><span class="p">)</span> <span class="n">SharedInfo</span><span class="p">;</span>

  <span class="n">size_t</span> <span class="n">actualCapacity</span> <span class="o">=</span> <span class="n">infoStart</span> <span class="o">-</span> <span class="n">buf</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-54"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-54">&#182;</a></div><p>On the unlikely possibility that the actual capacity is larger than can
fit in a uint32_t after adding room for the refcount and calling
goodMallocSize(), truncate downwards if necessary.</p></td><td class="code"><div class="highlight"><pre>  <span class="k">if</span> <span class="p">(</span><span class="n">actualCapacity</span> <span class="o">&gt;=</span> <span class="n">UINT32_MAX</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">capacityReturn</span> <span class="o">=</span> <span class="n">UINT32_MAX</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">capacityReturn</span> <span class="o">=</span> <span class="n">actualCapacity</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="o">*</span><span class="n">infoReturn</span> <span class="o">=</span> <span class="n">sharedInfo</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">}</span> <span class="c1">// folly</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/folly",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
ternal data.</span>
<span class="cm">   *</span>
<span class="cm">   * end is a pointer to the end of the IOBuf&#39;s internal data buffer.</span>
<span class="cm">   */</span>
  <span class="n">explicit</span> <span class="n">IOBuf</span><span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span> <span class="n">end</span><span class="p">);</span>

  <span class="cm">/**</span>
<span class="cm">   * Create a new IOBuf pointing to an external buffer.</span>
<span class="cm">   *</span>
<span class="cm">   * The caller is responsible for holding a reference count for this new</span>
<span class="cm">   * IOBuf.  The IOBuf constructor does not automatically increment the</span>
<span class="cm">   * reference count.</span>
<span class="cm">   */</span>
  <span class="n">IOBuf</span><span class="p">(</span><span class="n">ExtBufTypeEnum</span> <span class="n">type</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">,</span>
        <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">capacity</span><span class="p">,</span>
        <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">length</span><span class="p">,</span>
        <span class="n">SharedInfo</span><span class="o">*</span> <span class="n">sharedInfo</span><span class="p">);</span>

  <span class="kt">void</span> <span class="n">unshareOneSlow</span><span class="p">();</span>
  <span class="kt">void</span> <span class="n">unshareChained</span><span class="p">();</span>
  <span class="kt">void</span> <span class="n">coalesceSlow</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">maxLength</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">());</span>
  <span class="kt">void</span> <span class="n">decrementRefcount</span><span class="p">();</span>
  <span class="kt">void</span> <span class="n">reserveSlow</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">minHeadroom</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">minTailroom</span><span class="p">);</span>

  <span class="k">static</span> <span class="kt">size_t</span> <span class="n">goodExtBufferSize</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">minCapacity</span><span class="p">);</span>
  <span class="k">static</span> <span class="kt">void</span> <span class="n">initExtBuffer</span><span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">mallocSize</span><span class="p">,</span>
                            <span class="n">SharedInfo</span><span class="o">**</span> <span class="n">infoReturn</span><span class="p">,</span>
                            <span class="kt">uint32_t</span><span class="o">*</span> <span class="n">capacityReturn</span><span class="p">);</span>
  <span class="k">static</span> <span class="kt">void</span> <span class="n">allocExtBuffer</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">minCapacity</span><span class="p">,</span>
                             <span class="kt">uint8_t</span><span class="o">**</span> <span class="n">bufReturn</span><span class="p">,</span>
                             <span class="n">SharedInfo</span><span class="o">**</span> <span class="n">infoReturn</span><span class="p">,</span>
                             <span class="kt">uint32_t</span><span class="o">*</span> <span class="n">capacityReturn</span><span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">   * Member variables</span>
<span class="cm">   */</span>

  <span class="cm">/*</span>
<span class="cm">   * Links to the next and the previous IOBuf in this chain.</span>
<span class="cm">   *</span>
<span class="cm">   * The chain is circularly linked (the last element in the chain points back</span>
<span class="cm">   * at the head), and next_ and prev_ can never be NULL.  If this IOBuf is the</span>
<span class="cm">   * only element in the chain, next_ and prev_ will both point to this.</span>
<span class="cm">   */</span>
  <span class="n">IOBuf</span><span class="o">*</span> <span class="n">next_</span><span class="p">;</span>
  <span class="n">IOBuf</span><span class="o">*</span> <span class="n">prev_</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">   * A pointer to the start of the data referenced by this IOBuf, and the</span>
<span class="cm">   * length of the data.</span>
<span class="cm">   *</span>
<span class="cm">   * This may refer to any subsection of the actual buffer capacity.</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">data_</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">length_</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">flags_</span><span class="p">;</span>

  <span class="k">union</span> <span class="p">{</span>
    <span class="n">ExternalBuf</span> <span class="n">ext_</span><span class="p">;</span>
    <span class="n">InternalBuf</span> <span class="n">int_</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="k">struct</span> <span class="n">DeleterBase</span> <span class="p">{</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">DeleterBase</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">dispose</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">UniquePtr</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="n">UniquePtrDeleter</span> <span class="o">:</span> <span class="n">public</span> <span class="n">DeleterBase</span> <span class="p">{</span>
    <span class="k">typedef</span> <span class="kr">typename</span> <span class="n">UniquePtr</span><span class="o">::</span><span class="n">pointer</span> <span class="n">Pointer</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="kr">typename</span> <span class="n">UniquePtr</span><span class="o">::</span><span class="n">deleter_type</span> <span class="n">Deleter</span><span class="p">;</span>

    <span class="n">explicit</span> <span class="nf">UniquePtrDeleter</span><span class="p">(</span><span class="n">Deleter</span> <span class="n">deleter</span><span class="p">)</span> <span class="o">:</span> <span class="n">deleter_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">deleter</span><span class="p">)){</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">dispose</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">try</span> <span class="p">{</span>
        <span class="n">deleter_</span><span class="p">(</span><span class="n">static_cast</span><span class="o">&lt;</span><span class="n">Pointer</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
        <span class="n">delete</span> <span class="n">this</span><span class="p">;</span>
      <span class="p">}</span> <span class="n">catch</span> <span class="p">(...)</span> <span class="p">{</span>
        <span class="n">abort</span><span class="p">();</span>
      <span class="p">}</span>
    <span class="p">}</span>

   <span class="nl">private:</span>
    <span class="n">Deleter</span> <span class="n">deleter_</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="k">static</span> <span class="kt">void</span> <span class="nf">freeUniquePtrBuffer</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">userData</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">static_cast</span><span class="o">&lt;</span><span class="n">DeleterBase</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">userData</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dispose</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">UniquePtr</span><span class="o">&gt;</span>
<span class="kr">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">detail</span><span class="o">::</span><span class="n">IsUniquePtrToSL</span><span class="o">&lt;</span><span class="n">UniquePtr</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
                        <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IOBuf</span><span class="o">&gt;&gt;::</span><span class="n">type</span>
<span class="n">IOBuf</span><span class="o">::</span><span class="n">takeOwnership</span><span class="p">(</span><span class="n">UniquePtr</span><span class="o">&amp;&amp;</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kr">typename</span> <span class="n">UniquePtr</span><span class="o">::</span><span class="n">element_type</span><span class="p">);</span>
  <span class="n">CHECK_LT</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">()));</span>
  <span class="k">auto</span> <span class="n">deleter</span> <span class="o">=</span> <span class="n">new</span> <span class="n">UniquePtrDeleter</span><span class="o">&lt;</span><span class="n">UniquePtr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">buf</span><span class="p">.</span><span class="n">get_deleter</span><span class="p">());</span>
  <span class="k">return</span> <span class="n">takeOwnership</span><span class="p">(</span><span class="n">buf</span><span class="p">.</span><span class="n">release</span><span class="p">(),</span>
                       <span class="n">size</span><span class="p">,</span>
                       <span class="o">&amp;</span><span class="n">IOBuf</span><span class="o">::</span><span class="n">freeUniquePtrBuffer</span><span class="p">,</span>
                       <span class="n">deleter</span><span class="p">);</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IOBuf</span><span class="o">&gt;</span> <span class="n">IOBuf</span><span class="o">::</span><span class="n">copyBuffer</span><span class="p">(</span>
    <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">headroom</span><span class="p">,</span>
    <span class="kt">uint32_t</span> <span class="n">minTailroom</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">uint32_t</span> <span class="n">capacity</span> <span class="o">=</span> <span class="n">headroom</span> <span class="o">+</span> <span class="n">size</span> <span class="o">+</span> <span class="n">minTailroom</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IOBuf</span><span class="o">&gt;</span> <span class="n">buf</span> <span class="o">=</span> <span class="n">create</span><span class="p">(</span><span class="n">capacity</span><span class="p">);</span>
  <span class="n">buf</span><span class="o">-&gt;</span><span class="n">advance</span><span class="p">(</span><span class="n">headroom</span><span class="p">);</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">writableData</span><span class="p">(),</span> <span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
  <span class="n">buf</span><span class="o">-&gt;</span><span class="n">append</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">}</span> <span class="c1">// folly</span>

<span class="cp">#endif </span><span class="c1">// FOLLY_IO_IOBUF_H_</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/folly",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
