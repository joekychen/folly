<!DOCTYPE html>
<html><head><title>joekychen/folly » folly › experimental › io › IOBuf.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>IOBuf.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2012 Facebook, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="cm"> * you may not use this file except in compliance with the License.</span>
<span class="cm"> * You may obtain a copy of the License at</span>
<span class="cm"> *</span>
<span class="cm"> *   http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="cm"> *</span>
<span class="cm"> * Unless required by applicable law or agreed to in writing, software</span>
<span class="cm"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="cm"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="cm"> * See the License for the specific language governing permissions and</span>
<span class="cm"> * limitations under the License.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef FOLLY_IO_IOBUF_H_</span>
<span class="cp">#define FOLLY_IO_IOBUF_H_</span>

<span class="cp">#include &lt;glog/logging.h&gt;</span>
<span class="cp">#include &lt;atomic&gt;</span>
<span class="cp">#include &lt;cassert&gt;</span>
<span class="cp">#include &lt;cinttypes&gt;</span>
<span class="cp">#include &lt;cstddef&gt;</span>
<span class="cp">#include &lt;cstring&gt;</span>
<span class="cp">#include &lt;memory&gt;</span>
<span class="cp">#include &lt;limits&gt;</span>
<span class="cp">#include &lt;type_traits&gt;</span>

<span class="n">namespace</span> <span class="n">folly</span> <span class="p">{</span>

<span class="cm">/**</span>
<span class="cm"> * An IOBuf is a pointer to a buffer of data.</span>
<span class="cm"> *</span>
<span class="cm"> * IOBuf objects are intended to be used primarily for networking code, and are</span>
<span class="cm"> * modelled somewhat after FreeBSD&#39;s mbuf data structure, and Linux&#39;s sk_buff</span>
<span class="cm"> * structure.</span>
<span class="cm"> *</span>
<span class="cm"> * IOBuf objects facilitate zero-copy network programming, by allowing multiple</span>
<span class="cm"> * IOBuf objects to point to the same underlying buffer of data, using a</span>
<span class="cm"> * reference count to track when the buffer is no longer needed and can be</span>
<span class="cm"> * freed.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Data Layout</span>
<span class="cm"> * -----------</span>
<span class="cm"> *</span>
<span class="cm"> * The IOBuf itself is a small object containing a pointer to the buffer and</span>
<span class="cm"> * information about which segment of the buffer contains valid data.</span>
<span class="cm"> *</span>
<span class="cm"> * The data layout looks like this:</span>
<span class="cm"> *</span>
<span class="cm"> *  +-------+</span>
<span class="cm"> *  | IOBuf |</span>
<span class="cm"> *  +-------+</span>
<span class="cm"> *   /</span>
<span class="cm"> *  |</span>
<span class="cm"> *  v</span>
<span class="cm"> *  +------------+--------------------+-----------+</span>
<span class="cm"> *  | headroom   |        data        |  tailroom |</span>
<span class="cm"> *  +------------+--------------------+-----------+</span>
<span class="cm"> *  ^            ^                    ^           ^</span>
<span class="cm"> *  buffer()   data()               tail()      bufferEnd()</span>
<span class="cm"> *</span>
<span class="cm"> *  The length() method returns the length of the valid data; capacity()</span>
<span class="cm"> *  returns the entire capacity of the buffer (from buffer() to bufferEnd()).</span>
<span class="cm"> *  The headroom() and tailroom() methods return the amount of unused capacity</span>
<span class="cm"> *  available before and after the data.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Buffer Sharing</span>
<span class="cm"> * --------------</span>
<span class="cm"> *</span>
<span class="cm"> * The buffer itself is reference counted, and multiple IOBuf objects may point</span>
<span class="cm"> * to the same buffer.  Each IOBuf may point to a different section of valid</span>
<span class="cm"> * data within the underlying buffer.  For example, if multiple protocol</span>
<span class="cm"> * requests are read from the network into a single buffer, a separate IOBuf</span>
<span class="cm"> * may be created for each request, all sharing the same underlying buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * In other words, when multiple IOBufs share the same underlying buffer, the</span>
<span class="cm"> * data() and tail() methods on each IOBuf may point to a different segment of</span>
<span class="cm"> * the data.  However, the buffer() and bufferEnd() methods will point to the</span>
<span class="cm"> * same location for all IOBufs sharing the same underlying buffer.</span>
<span class="cm"> *</span>
<span class="cm"> *       +-----------+     +---------+</span>
<span class="cm"> *       |  IOBuf 1  |     | IOBuf 2 |</span>
<span class="cm"> *       +-----------+     +---------+</span>
<span class="cm"> *        |         | _____/        |</span>
<span class="cm"> *   data |    tail |/    data      | tail</span>
<span class="cm"> *        v         v               v</span>
<span class="cm"> *  +-------------------------------------+</span>
<span class="cm"> *  |     |         |               |     |</span>
<span class="cm"> *  +-------------------------------------+</span>
<span class="cm"> *</span>
<span class="cm"> * If you only read data from an IOBuf, you don&#39;t need to worry about other</span>
<span class="cm"> * IOBuf objects possibly sharing the same underlying buffer.  However, if you</span>
<span class="cm"> * ever write to the buffer you need to first ensure that no other IOBufs point</span>
<span class="cm"> * to the same buffer.  The unshare() method may be used to ensure that you</span>
<span class="cm"> * have an unshared buffer.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * IOBuf Chains</span>
<span class="cm"> * ------------</span>
<span class="cm"> *</span>
<span class="cm"> * IOBuf objects also contain pointers to next and previous IOBuf objects.</span>
<span class="cm"> * This can be used to represent a single logical piece of data that its stored</span>
<span class="cm"> * in non-contiguous chunks in separate buffers.</span>
<span class="cm"> *</span>
<span class="cm"> * A single IOBuf object can only belong to one chain at a time.</span>
<span class="cm"> *</span>
<span class="cm"> * IOBuf chains are always circular.  The &quot;prev&quot; pointer in the head of the</span>
<span class="cm"> * chain points to the tail of the chain.  However, it is up to the user to</span>
<span class="cm"> * decide which IOBuf is the head.  Internally the IOBuf code does not care</span>
<span class="cm"> * which element is the head.</span>
<span class="cm"> *</span>
<span class="cm"> * The lifetime of all IOBufs in the chain are linked: when one element in the</span>
<span class="cm"> * chain is deleted, all other chained elements are also deleted.  Conceptually</span>
<span class="cm"> * it is simplest to treat this as if the head of the chain owns all other</span>
<span class="cm"> * IOBufs in the chain.  When you delete the head of the chain, it will delete</span>
<span class="cm"> * the other elements as well.  For this reason, prependChain() and</span>
<span class="cm"> * appendChain() take ownership of of the new elements being added to this</span>
<span class="cm"> * chain.</span>
<span class="cm"> *</span>
<span class="cm"> * When the coalesce() method is used to coalesce an entire IOBuf chain into a</span>
<span class="cm"> * single IOBuf, all other IOBufs in the chain are eliminated and automatically</span>
<span class="cm"> * deleted.  The unshare() method may coalesce the chain; if it does it will</span>
<span class="cm"> * similarly delete all IOBufs eliminated from the chain.</span>
<span class="cm"> *</span>
<span class="cm"> * As discussed in the following section, it is up to the user to maintain a</span>
<span class="cm"> * lock around the entire IOBuf chain if multiple threads need to access the</span>
<span class="cm"> * chain.  IOBuf does not provide any internal locking.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Synchronization</span>
<span class="cm"> * ---------------</span>
<span class="cm"> *</span>
<span class="cm"> * When used in multithread programs, a single IOBuf object should only be used</span>
<span class="cm"> * in a single thread at a time.  If a caller uses a single IOBuf across</span>
<span class="cm"> * multiple threads the caller is responsible for using an external lock to</span>
<span class="cm"> * synchronize access to the IOBuf.</span>
<span class="cm"> *</span>
<span class="cm"> * Two separate IOBuf objects may be accessed concurrently in separate threads</span>
<span class="cm"> * without locking, even if they point to the same underlying buffer.  The</span>
<span class="cm"> * buffer reference count is always accessed atomically, and no other</span>
<span class="cm"> * operations should affect other IOBufs that point to the same data segment.</span>
<span class="cm"> * The caller is responsible for using unshare() to ensure that the data buffer</span>
<span class="cm"> * is not shared by other IOBufs before writing to it, and this ensures that</span>
<span class="cm"> * the data itself is not modified in one thread while also being accessed from</span>
<span class="cm"> * another thread.</span>
<span class="cm"> *</span>
<span class="cm"> * For IOBuf chains, no two IOBufs in the same chain should be accessed</span>
<span class="cm"> * simultaneously in separate threads.  The caller must maintain a lock around</span>
<span class="cm"> * the entire chain if the chain, or individual IOBufs in the chain, may be</span>
<span class="cm"> * accessed by multiple threads.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * IOBuf Object Allocation/Sharing</span>
<span class="cm"> * -------------------------------</span>
<span class="cm"> *</span>
<span class="cm"> * IOBuf objects themselves are always allocated on the heap.  The IOBuf</span>
<span class="cm"> * constructors are private, so IOBuf objects may not be created on the stack.</span>
<span class="cm"> * In part this is done since some IOBuf objects use small-buffer optimization</span>
<span class="cm"> * and contain the buffer data immediately after the IOBuf object itself.  The</span>
<span class="cm"> * coalesce() and unshare() methods also expect to be able to delete subsequent</span>
<span class="cm"> * IOBuf objects in the chain if they are no longer needed due to coalescing.</span>
<span class="cm"> *</span>
<span class="cm"> * The IOBuf structure also does not provide room for an intrusive refcount on</span>
<span class="cm"> * the IOBuf object itself, only the underlying data buffer is reference</span>
<span class="cm"> * counted.  If users want to share the same IOBuf object between multiple</span>
<span class="cm"> * parts of the code, they are responsible for managing this sharing on their</span>
<span class="cm"> * own.  (For example, by using a shared_ptr.  Alternatively, users always have</span>
<span class="cm"> * the option of using clone() to create a second IOBuf that points to the same</span>
<span class="cm"> * underlying buffer.)</span>
<span class="cm"> *</span>
<span class="cm"> * With jemalloc, allocating small objects like IOBuf objects should be</span>
<span class="cm"> * relatively fast, and the cost of allocating IOBuf objects on the heap and</span>
<span class="cm"> * cloning new IOBufs should be relatively cheap.</span>
<span class="cm"> */</span>
<span class="n">namespace</span> <span class="n">detail</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>Is T a unique_ptr&lt;> to a standard-layout type?</p></td><td class="code"><div class="highlight"><pre><span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="p">,</span> <span class="n">class</span> <span class="n">Enable</span><span class="o">=</span><span class="kt">void</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">IsUniquePtrToSL</span>
  <span class="o">:</span> <span class="n">public</span> <span class="n">std</span><span class="o">::</span><span class="n">false_type</span> <span class="p">{</span> <span class="p">};</span>
<span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="p">,</span> <span class="n">class</span> <span class="n">D</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">IsUniquePtrToSL</span><span class="o">&lt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">D</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="kr">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_standard_layout</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span>
  <span class="o">:</span> <span class="n">public</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span> <span class="p">{</span> <span class="p">};</span>
<span class="p">}</span>  <span class="c1">// namespace detail</span>

<span class="n">class</span> <span class="n">IOBuf</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">FreeFunction</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">userData</span><span class="p">);</span>

  <span class="cm">/**</span>
<span class="cm">   * Allocate a new IOBuf object with the requested capacity.</span>
<span class="cm">   *</span>
<span class="cm">   * Returns a new IOBuf object that must be (eventually) deleted by the</span>
<span class="cm">   * caller.  The returned IOBuf may actually have slightly more capacity than</span>
<span class="cm">   * requested.</span>
<span class="cm">   *</span>
<span class="cm">   * The data pointer will initially point to the start of the newly allocated</span>
<span class="cm">   * buffer, and will have a data length of 0.</span>
<span class="cm">   *</span>
<span class="cm">   * Throws std::bad_alloc on error.</span>
<span class="cm">   */</span>
  <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IOBuf</span><span class="o">&gt;</span> <span class="n">create</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">capacity</span><span class="p">);</span>

  <span class="cm">/**</span>
<span class="cm">   * Create a new IOBuf pointing to an existing data buffer.</span>
<span class="cm">   *</span>
<span class="cm">   * The new IOBuffer will assume ownership of the buffer, and free it by</span>
<span class="cm">   * calling the specified FreeFunction when the last IOBuf pointing to this</span>
<span class="cm">   * buffer is destroyed.  The function will be called with a pointer to the</span>
<span class="cm">   * buffer as the first argument, and the supplied userData value as the</span>
<span class="cm">   * second argument.  The free function must never throw exceptions.</span>
<span class="cm">   *</span>
<span class="cm">   * If no FreeFunction is specified, the buffer will be freed using free().</span>
<span class="cm">   *</span>
<span class="cm">   * The IOBuf data pointer will initially point to the start of the buffer,</span>
<span class="cm">   * and the length will be the full capacity of the buffer.</span>
<span class="cm">   *</span>
<span class="cm">   * On error, std::bad_alloc will be thrown.  If freeOnError is true (the</span>
<span class="cm">   * default) the buffer will be freed before throwing the error.</span>
<span class="cm">   */</span>
  <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IOBuf</span><span class="o">&gt;</span> <span class="n">takeOwnership</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">capacity</span><span class="p">,</span>
                                              <span class="n">FreeFunction</span> <span class="n">freeFn</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
                                              <span class="kt">void</span><span class="o">*</span> <span class="n">userData</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
                                              <span class="n">bool</span> <span class="n">freeOnError</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>

  <span class="cm">/**</span>
<span class="cm">   * Create a new IOBuf pointing to an existing data buffer made up of</span>
<span class="cm">   * count objects of a given standard-layout type.</span>
<span class="cm">   *</span>
<span class="cm">   * This is dangerous -- it is essentially equivalent to doing</span>
<span class="cm">   * reinterpret_cast&lt;unsigned char*&gt; on your data -- but it&#39;s often useful</span>
<span class="cm">   * for serialization / deserialization.</span>
<span class="cm">   *</span>
<span class="cm">   * The new IOBuffer will assume ownership of the buffer, and free it</span>
<span class="cm">   * appropriately (by calling the UniquePtr&#39;s custom deleter, or by calling</span>
<span class="cm">   * delete or delete[] appropriately if there is no custom deleter)</span>
<span class="cm">   * when the buffer is destroyed.  The custom deleter, if any, must never</span>
<span class="cm">   * throw exceptions.</span>
<span class="cm">   *</span>
<span class="cm">   * The IOBuf data pointer will initially point to the start of the buffer,</span>
<span class="cm">   * and the length will be the full capacity of the buffer (count *</span>
<span class="cm">   * sizeof(T)).</span>
<span class="cm">   *</span>
<span class="cm">   * On error, std::bad_alloc will be thrown, and the buffer will be freed</span>
<span class="cm">   * before throwing the error.</span>
<span class="cm">   */</span>
  <span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">UniquePtr</span><span class="o">&gt;</span>
  <span class="k">static</span> <span class="kr">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">detail</span><span class="o">::</span><span class="n">IsUniquePtrToSL</span><span class="o">&lt;</span><span class="n">UniquePtr</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
                                 <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IOBuf</span><span class="o">&gt;&gt;::</span><span class="n">type</span>
  <span class="n">takeOwnership</span><span class="p">(</span><span class="n">UniquePtr</span><span class="o">&amp;&amp;</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>

  <span class="cm">/**</span>
<span class="cm">   * Create a new IOBuf object that points to an existing user-owned buffer.</span>
<span class="cm">   *</span>
<span class="cm">   * This should only be used when the caller knows the lifetime of the IOBuf</span>
<span class="cm">   * object ahead of time and can ensure that all IOBuf objects that will point</span>
<span class="cm">   * to this buffer will be destroyed before the buffer itself is destroyed.</span>
<span class="cm">   *</span>
<span class="cm">   * This buffer will not be freed automatically when the last IOBuf</span>
<span class="cm">   * referencing it is destroyed.  It is the caller&#39;s responsibility to free</span>
<span class="cm">   * the buffer after the last IOBuf has been destroyed.</span>
<span class="cm">   *</span>
<span class="cm">   * The IOBuf data pointer will initially point to the start of the buffer,</span>
<span class="cm">   * and the length will be the full capacity of the buffer.</span>
<span class="cm">   *</span>
<span class="cm">   * An IOBuf created using wrapBuffer() will always be reported as shared.</span>
<span class="cm">   * unshare() may be used to create a writable copy of the buffer.</span>
<span class="cm">   *</span>
<span class="cm">   * On error, std::bad_alloc will be thrown.</span>
<span class="cm">   */</span>
  <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IOBuf</span><span class="o">&gt;</span> <span class="n">wrapBuffer</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">capacity</span><span class="p">);</span>

  <span class="cm">/**</span>
<span class="cm">   * Convenience function to create a new IOBuf object that copies data from a</span>
<span class="cm">   * user-supplied buffer, optionally allocating a given amount of</span>
<span class="cm">   * headroom and tailroom.</span>
<span class="cm">   */</span>
  <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IOBuf</span><span class="o">&gt;</span> <span class="n">copyBuffer</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">,</span>
                                           <span class="kt">uint32_t</span> <span class="n">headroom</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                           <span class="kt">uint32_t</span> <span class="n">minTailroom</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span>

  <span class="cm">/**</span>
<span class="cm">   * Convenience function to free a chain of IOBufs held by a unique_ptr.</span>
<span class="cm">   */</span>
  <span class="k">static</span> <span class="kt">void</span> <span class="nf">destroy</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IOBuf</span><span class="o">&gt;&amp;&amp;</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">destroyer</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Destroy this IOBuf.</span>
<span class="cm">   *</span>
<span class="cm">   * Deleting an IOBuf will automatically destroy all IOBufs in the chain.</span>
<span class="cm">   * (See the comments above regarding the ownership model of IOBuf chains.</span>
<span class="cm">   * All subsequent IOBufs in the chain are considered to be owned by the head</span>
<span class="cm">   * of the chain.  Users should only explicitly delete the head of a chain.)</span>
<span class="cm">   *</span>
<span class="cm">   * When each individual IOBuf is destroyed, it will release its reference</span>
<span class="cm">   * count on the underlying buffer.  If it was the last user of the buffer,</span>
<span class="cm">   * the buffer will be freed.</span>
<span class="cm">   */</span>
  <span class="o">~</span><span class="n">IOBuf</span><span class="p">();</span>

  <span class="cm">/**</span>
<span class="cm">   * Check whether the chain is empty (i.e., whether the IOBufs in the</span>
<span class="cm">   * chain have a total data length of zero).</span>
<span class="cm">   *</span>
<span class="cm">   * This method is semantically equivalent to</span>
<span class="cm">   *   i-&gt;computeChainDataLength()==0</span>
<span class="cm">   * but may run faster because it can short-circuit as soon as it</span>
<span class="cm">   * encounters a buffer with length()!=0</span>
<span class="cm">   */</span>
  <span class="n">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/**</span>
<span class="cm">   * Get the pointer to the start of the data.</span>
<span class="cm">   */</span>
  <span class="k">const</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">data</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">data_</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Get a writable pointer to the start of the data.</span>
<span class="cm">   *</span>
<span class="cm">   * The caller is responsible for calling unshare() first to ensure that it is</span>
<span class="cm">   * actually safe to write to the buffer.</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">writableData</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">data_</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Get the pointer to the end of the data.</span>
<span class="cm">   */</span>
  <span class="k">const</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">tail</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">data_</span> <span class="o">+</span> <span class="n">length_</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Get a writable pointer to the end of the data.</span>
<span class="cm">   *</span>
<span class="cm">   * The caller is responsible for calling unshare() first to ensure that it is</span>
<span class="cm">   * actually safe to write to the buffer.</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">writableTail</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">data_</span> <span class="o">+</span> <span class="n">length_</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Get the data length.</span>
<span class="cm">   */</span>
  <span class="kt">uint32_t</span> <span class="n">length</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">length_</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Get the amount of head room.</span>
<span class="cm">   *</span>
<span class="cm">   * Returns the number of bytes in the buffer before the start of the data.</span>
<span class="cm">   */</span>
  <span class="kt">uint32_t</span> <span class="n">headroom</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">data_</span> <span class="o">-</span> <span class="n">buffer</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Get the amount of tail room.</span>
<span class="cm">   *</span>
<span class="cm">   * Returns the number of bytes in the buffer after the end of the data.</span>
<span class="cm">   */</span>
  <span class="kt">uint32_t</span> <span class="n">tailroom</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">bufferEnd</span><span class="p">()</span> <span class="o">-</span> <span class="n">tail</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Get the pointer to the start of the buffer.</span>
<span class="cm">   *</span>
<span class="cm">   * Note that this is the pointer to the very beginning of the usable buffer,</span>
<span class="cm">   * not the start of valid data within the buffer.  Use the data() method to</span>
<span class="cm">   * get a pointer to the start of the data within the buffer.</span>
<span class="cm">   */</span>
  <span class="k">const</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">buffer</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">flags_</span> <span class="o">&amp;</span> <span class="n">kFlagExt</span><span class="p">)</span> <span class="o">?</span> <span class="n">ext_</span><span class="p">.</span><span class="n">buf</span> <span class="o">:</span> <span class="n">int_</span><span class="p">.</span><span class="n">buf</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Get a writable pointer to the start of the buffer.</span>
<span class="cm">   *</span>
<span class="cm">   * The caller is responsible for calling unshare() first to ensure that it is</span>
<span class="cm">   * actually safe to write to the buffer.</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">writableBuffer</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">flags_</span> <span class="o">&amp;</span> <span class="n">kFlagExt</span><span class="p">)</span> <span class="o">?</span> <span class="n">ext_</span><span class="p">.</span><span class="n">buf</span> <span class="o">:</span> <span class="n">int_</span><span class="p">.</span><span class="n">buf</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Get the pointer to the end of the buffer.</span>
<span class="cm">   *</span>
<span class="cm">   * Note that this is the pointer to the very end of the usable buffer,</span>
<span class="cm">   * not the end of valid data within the buffer.  Use the tail() method to</span>
<span class="cm">   * get a pointer to the end of the data within the buffer.</span>
<span class="cm">   */</span>
  <span class="k">const</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">bufferEnd</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">flags_</span> <span class="o">&amp;</span> <span class="n">kFlagExt</span><span class="p">)</span> <span class="o">?</span>
      <span class="n">ext_</span><span class="p">.</span><span class="n">buf</span> <span class="o">+</span> <span class="n">ext_</span><span class="p">.</span><span class="n">capacity</span> <span class="o">:</span>
      <span class="n">int_</span><span class="p">.</span><span class="n">buf</span> <span class="o">+</span> <span class="n">kMaxInternalDataSize</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Get the total size of the buffer.</span>
<span class="cm">   *</span>
<span class="cm">   * This returns the total usable length of the buffer.  Use the length()</span>
<span class="cm">   * method to get the length of the actual valid data in this IOBuf.</span>
<span class="cm">   */</span>
  <span class="kt">uint32_t</span> <span class="n">capacity</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">flags_</span> <span class="o">&amp;</span> <span class="n">kFlagExt</span><span class="p">)</span> <span class="o">?</span>  <span class="n">ext_</span><span class="p">.</span><span class="n">capacity</span> <span class="o">:</span> <span class="n">kMaxInternalDataSize</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Get a pointer to the next IOBuf in this chain.</span>
<span class="cm">   */</span>
  <span class="n">IOBuf</span><span class="o">*</span> <span class="n">next</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">next_</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">const</span> <span class="n">IOBuf</span><span class="o">*</span> <span class="n">next</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">next_</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Get a pointer to the previous IOBuf in this chain.</span>
<span class="cm">   */</span>
  <span class="n">IOBuf</span><span class="o">*</span> <span class="n">prev</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">prev_</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">const</span> <span class="n">IOBuf</span><span class="o">*</span> <span class="n">prev</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">prev_</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Shift the data forwards in the buffer.</span>
<span class="cm">   *</span>
<span class="cm">   * This shifts the data pointer forwards in the buffer to increase the</span>
<span class="cm">   * headroom.  This is commonly used to increase the headroom in a newly</span>
<span class="cm">   * allocated buffer.</span>
<span class="cm">   *</span>
<span class="cm">   * The caller is responsible for ensuring that there is sufficient</span>
<span class="cm">   * tailroom in the buffer before calling advance().</span>
<span class="cm">   *</span>
<span class="cm">   * If there is a non-zero data length, advance() will use memmove() to shift</span>
<span class="cm">   * the data forwards in the buffer.  In this case, the caller is responsible</span>
<span class="cm">   * for making sure the buffer is unshared, so it will not affect other IOBufs</span>
<span class="cm">   * that may be sharing the same underlying buffer.</span>
<span class="cm">   */</span>
  <span class="kt">void</span> <span class="n">advance</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>In debug builds, assert if there is a problem.</p></td><td class="code"><div class="highlight"><pre>    <span class="n">assert</span><span class="p">(</span><span class="n">amount</span> <span class="o">&lt;=</span> <span class="n">tailroom</span><span class="p">());</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">length_</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">memmove</span><span class="p">(</span><span class="n">data_</span> <span class="o">+</span> <span class="n">amount</span><span class="p">,</span> <span class="n">data_</span><span class="p">,</span> <span class="n">length_</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">data_</span> <span class="o">+=</span> <span class="n">amount</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Shift the data backwards in the buffer.</span>
<span class="cm">   *</span>
<span class="cm">   * The caller is responsible for ensuring that there is sufficient headroom</span>
<span class="cm">   * in the buffer before calling retreat().</span>
<span class="cm">   *</span>
<span class="cm">   * If there is a non-zero data length, retreat() will use memmove() to shift</span>
<span class="cm">   * the data backwards in the buffer.  In this case, the caller is responsible</span>
<span class="cm">   * for making sure the buffer is unshared, so it will not affect other IOBufs</span>
<span class="cm">   * that may be sharing the same underlying buffer.</span>
<span class="cm">   */</span>
  <span class="kt">void</span> <span class="n">retreat</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>In debug builds, assert if there is a problem.</p></td><td class="code"><div class="highlight"><pre>    <span class="n">assert</span><span class="p">(</span><span class="n">amount</span> <span class="o">&lt;=</span> <span class="n">headroom</span><span class="p">());</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">length_</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">memmove</span><span class="p">(</span><span class="n">data_</span> <span class="o">-</span> <span class="n">amount</span><span class="p">,</span> <span class="n">data_</span><span class="p">,</span> <span class="n">length_</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">data_</span> <span class="o">-=</span> <span class="n">amount</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Adjust the data pointer to include more valid data at the beginning.</span>
<span class="cm">   *</span>
<span class="cm">   * This moves the data pointer backwards to include more of the available</span>
<span class="cm">   * buffer.  The caller is responsible for ensuring that there is sufficient</span>
<span class="cm">   * headroom for the new data.  The caller is also responsible for populating</span>
<span class="cm">   * this section with valid data.</span>
<span class="cm">   *</span>
<span class="cm">   * This does not modify any actual data in the buffer.</span>
<span class="cm">   */</span>
  <span class="kt">void</span> <span class="n">prepend</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">CHECK</span><span class="p">(</span><span class="n">amount</span> <span class="o">&lt;=</span> <span class="n">headroom</span><span class="p">());</span>
    <span class="n">data_</span> <span class="o">-=</span> <span class="n">amount</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Adjust the tail pointer to include more valid data at the end.</span>
<span class="cm">   *</span>
<span class="cm">   * This moves the tail pointer forwards to include more of the available</span>
<span class="cm">   * buffer.  The caller is responsible for ensuring that there is sufficient</span>
<span class="cm">   * tailroom for the new data.  The caller is also responsible for populating</span>
<span class="cm">   * this section with valid data.</span>
<span class="cm">   *</span>
<span class="cm">   * This does not modify any actual data in the buffer.</span>
<span class="cm">   */</span>
  <span class="kt">void</span> <span class="n">append</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">CHECK</span><span class="p">(</span><span class="n">amount</span> <span class="o">&lt;=</span> <span class="n">tailroom</span><span class="p">());</span>
    <span class="n">length_</span> <span class="o">+=</span> <span class="n">amount</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Adjust the data pointer forwards to include less valid data.</span>
<span class="cm">   *</span>
<span class="cm">   * This moves the data pointer forwards so that the first amount bytes are no</span>
<span class="cm">   * longer considered valid data.  The caller is responsible for ensuring that</span>
<span class="cm">   * amount is less than or equal to the actual data length.</span>
<span class="cm">   *</span>
<span class="cm">   * This does not modify any actual data in the buffer.</span>
<span class="cm">   */</span>
  <span class="kt">void</span> <span class="n">trimStart</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">CHECK</span><span class="p">(</span><span class="n">amount</span> <span class="o">&lt;=</span> <span class="n">length_</span><span class="p">);</span>
    <span class="n">data_</span> <span class="o">+=</span> <span class="n">amount</span><span class="p">;</span>
    <span class="n">length_</span> <span class="o">-=</span> <span class="n">amount</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Adjust the tail pointer backwards to include less valid data.</span>
<span class="cm">   *</span>
<span class="cm">   * This moves the tail pointer backwards so that the last amount bytes are no</span>
<span class="cm">   * longer considered valid data.  The caller is responsible for ensuring that</span>
<span class="cm">   * amount is less than or equal to the actual data length.</span>
<span class="cm">   *</span>
<span class="cm">   * This does not modify any actual data in the buffer.</span>
<span class="cm">   */</span>
  <span class="kt">void</span> <span class="n">trimEnd</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">CHECK</span><span class="p">(</span><span class="n">amount</span> <span class="o">&lt;=</span> <span class="n">length_</span><span class="p">);</span>
    <span class="n">length_</span> <span class="o">-=</span> <span class="n">amount</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Clear the buffer.</span>
<span class="cm">   *</span>
<span class="cm">   * Postcondition: headroom() == 0, length() == 0, tailroom() == capacity()</span>
<span class="cm">   */</span>
  <span class="kt">void</span> <span class="n">clear</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">data_</span> <span class="o">=</span> <span class="n">writableBuffer</span><span class="p">();</span>
    <span class="n">length_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Ensure that this buffer has at least minHeadroom headroom bytes and at</span>
<span class="cm">   * least minTailroom tailroom bytes.  The buffer must be writable</span>
<span class="cm">   * (you must call unshare() before this, if necessary).</span>
<span class="cm">   *</span>
<span class="cm">   * Postcondition: headroom() &gt;= minHeadroom, tailroom() &gt;= minTailroom,</span>
<span class="cm">   * the data (between data() and data() + length()) is preserved.</span>
<span class="cm">   */</span>
  <span class="kt">void</span> <span class="n">reserve</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">minHeadroom</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">minTailroom</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-5"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-5">&#182;</a></div><p>Maybe we don't need to do anything.</p></td><td class="code"><div class="highlight"><pre>    <span class="k">if</span> <span class="p">(</span><span class="n">headroom</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">minHeadroom</span> <span class="o">&amp;&amp;</span> <span class="n">tailroom</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">minTailroom</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span></pre></div></td></tr>


<tr id="section-6"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-6">&#182;</a></div><p>If the buffer is empty but we have enough total room (head + tail),
move the data_ pointer around.</p></td><td class="code"><div class="highlight"><pre>    <span class="k">if</span> <span class="p">(</span><span class="n">length</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
        <span class="n">headroom</span><span class="p">()</span> <span class="o">+</span> <span class="n">tailroom</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">minHeadroom</span> <span class="o">+</span> <span class="n">minTailroom</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">data_</span> <span class="o">=</span> <span class="n">writableBuffer</span><span class="p">()</span> <span class="o">+</span> <span class="n">minHeadroom</span><span class="p">;</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span></pre></div></td></tr>


<tr id="section-7"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-7">&#182;</a></div><p>Bah, we have to do actual work.</p></td><td class="code"><div class="highlight"><pre>    <span class="n">reserveSlow</span><span class="p">(</span><span class="n">minHeadroom</span><span class="p">,</span> <span class="n">minTailroom</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Return true if this IOBuf is part of a chain of multiple IOBufs, or false</span>
<span class="cm">   * if this is the only IOBuf in its chain.</span>
<span class="cm">   */</span>
  <span class="n">bool</span> <span class="n">isChained</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">((</span><span class="n">next_</span> <span class="o">==</span> <span class="n">this</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">prev_</span> <span class="o">==</span> <span class="n">this</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">next_</span> <span class="o">!=</span> <span class="n">this</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Get the number of IOBufs in this chain.</span>
<span class="cm">   *</span>
<span class="cm">   * Beware that this method has to walk the entire chain.</span>
<span class="cm">   * Use isChained() if you just want to check if this IOBuf is part of a chain</span>
<span class="cm">   * or not.</span>
<span class="cm">   */</span>
  <span class="kt">uint32_t</span> <span class="n">countChainElements</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/**</span>
<span class="cm">   * Get the length of all the data in this IOBuf chain.</span>
<span class="cm">   *</span>
<span class="cm">   * Beware that this method has to walk the entire chain.</span>
<span class="cm">   */</span>
  <span class="kt">uint64_t</span> <span class="n">computeChainDataLength</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/**</span>
<span class="cm">   * Insert another IOBuf chain immediately before this IOBuf.</span>
<span class="cm">   *</span>
<span class="cm">   * For example, if there are two IOBuf chains (A, B, C) and (D, E, F),</span>
<span class="cm">   * and B-&gt;prependChain(D) is called, the (D, E, F) chain will be subsumed</span>
<span class="cm">   * and become part of the chain starting at A, which will now look like</span>
<span class="cm">   * (A, D, E, F, B, C)</span>
<span class="cm">   *</span>
<span class="cm">   * Note that since IOBuf chains are circular, head-&gt;prependChain(other) can</span>
<span class="cm">   * be used to append the other chain at the very end of the chain pointed to</span>
<span class="cm">   * by head.  For example, if there are two IOBuf chains (A, B, C) and</span>
<span class="cm">   * (D, E, F), and A-&gt;prependChain(D) is called, the chain starting at A will</span>
<span class="cm">   * now consist of (A, B, C, D, E, F)</span>
<span class="cm">   *</span>
<span class="cm">   * The elements in the specified IOBuf chain will become part of this chain,</span>
<span class="cm">   * and will be owned by the head of this chain.  When this chain is</span>
<span class="cm">   * destroyed, all elements in the supplied chain will also be destroyed.</span>
<span class="cm">   *</span>
<span class="cm">   * For this reason, appendChain() only accepts an rvalue-reference to a</span>
<span class="cm">   * unique_ptr(), to make it clear that it is taking ownership of the supplied</span>
<span class="cm">   * chain.  If you have a raw pointer, you can pass in a new temporary</span>
<span class="cm">   * unique_ptr around the raw pointer.  If you have an existing,</span>
<span class="cm">   * non-temporary unique_ptr, you must call std::move(ptr) to make it clear</span>
<span class="cm">   * that you are destroying the original pointer.</span>
<span class="cm">   */</span>
  <span class="kt">void</span> <span class="n">prependChain</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IOBuf</span><span class="o">&gt;&amp;&amp;</span> <span class="n">iobuf</span><span class="p">);</span>

  <span class="cm">/**</span>
<span class="cm">   * Append another IOBuf chain immediately after this IOBuf.</span>
<span class="cm">   *</span>
<span class="cm">   * For example, if there are two IOBuf chains (A, B, C) and (D, E, F),</span>
<span class="cm">   * and B-&gt;appendChain(D) is called, the (D, E, F) chain will be subsumed</span>
<span class="cm">   * and become part of the chain starting at A, which will now look like</span>
<span class="cm">   * (A, B, D, E, F, C)</span>
<span class="cm">   *</span>
<span class="cm">   * The elements in the specified IOBuf chain will become part of this chain,</span>
<span class="cm">   * and will be owned by the head of this chain.  When this chain is</span>
<span class="cm">   * destroyed, all elements in the supplied chain will also be destroyed.</span>
<span class="cm">   *</span>
<span class="cm">   * For this reason, appendChain() only accepts an rvalue-reference to a</span>
<span class="cm">   * unique_ptr(), to make it clear that it is taking ownership of the supplied</span>
<span class="cm">   * chain.  If you have a raw pointer, you can pass in a new temporary</span>
<span class="cm">   * unique_ptr around the raw pointer.  If you have an existing,</span>
<span class="cm">   * non-temporary unique_ptr, you must call std::move(ptr) to make it clear</span>
<span class="cm">   * that you are destroying the original pointer.</span>
<span class="cm">   */</span>
  <span class="kt">void</span> <span class="nf">appendChain</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IOBuf</span><span class="o">&gt;&amp;&amp;</span> <span class="n">iobuf</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-8"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-8">&#182;</a></div><p>Just use prependChain() on the next element in our chain</p></td><td class="code"><div class="highlight"><pre>    <span class="n">next_</span><span class="o">-&gt;</span><span class="n">prependChain</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">iobuf</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Remove this IOBuf from its current chain.</span>
<span class="cm">   *</span>
<span class="cm">   * Since ownership of all elements an IOBuf chain is normally maintained by</span>
<span class="cm">   * the head of the chain, unlink() transfers ownership of this IOBuf from the</span>
<span class="cm">   * chain and gives it to the caller.  A new unique_ptr to the IOBuf is</span>
<span class="cm">   * returned to the caller.  The caller must store the returned unique_ptr (or</span>
<span class="cm">   * call release() on it) to take ownership, otherwise the IOBuf will be</span>
<span class="cm">   * immediately destroyed.</span>
<span class="cm">   *</span>
<span class="cm">   * Since unlink transfers ownership of the IOBuf to the caller, be careful</span>
<span class="cm">   * not to call unlink() on the head of a chain if you already maintain</span>
<span class="cm">   * ownership on the head of the chain via other means.  The pop() method</span>
<span class="cm">   * is a better choice for that situation.</span>
<span class="cm">   */</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IOBuf</span><span class="o">&gt;</span> <span class="n">unlink</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">next_</span><span class="o">-&gt;</span><span class="n">prev_</span> <span class="o">=</span> <span class="n">prev_</span><span class="p">;</span>
    <span class="n">prev_</span><span class="o">-&gt;</span><span class="n">next_</span> <span class="o">=</span> <span class="n">next_</span><span class="p">;</span>
    <span class="n">prev_</span> <span class="o">=</span> <span class="n">this</span><span class="p">;</span>
    <span class="n">next_</span> <span class="o">=</span> <span class="n">this</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IOBuf</span><span class="o">&gt;</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Remove this IOBuf from its current chain and return a unique_ptr to</span>
<span class="cm">   * the IOBuf that formerly followed it in the chain.</span>
<span class="cm">   */</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IOBuf</span><span class="o">&gt;</span> <span class="n">pop</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">IOBuf</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">next_</span><span class="p">;</span>
    <span class="n">next_</span><span class="o">-&gt;</span><span class="n">prev_</span> <span class="o">=</span> <span class="n">prev_</span><span class="p">;</span>
    <span class="n">prev_</span><span class="o">-&gt;</span><span class="n">next_</span> <span class="o">=</span> <span class="n">next_</span><span class="p">;</span>
    <span class="n">prev_</span> <span class="o">=</span> <span class="n">this</span><span class="p">;</span>
    <span class="n">next_</span> <span class="o">=</span> <span class="n">this</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IOBuf</span><span class="o">&gt;</span><span class="p">((</span><span class="n">next</span> <span class="o">==</span> <span class="n">this</span><span class="p">)</span> <span class="o">?</span> <span class="nb">NULL</span> <span class="o">:</span> <span class="n">next</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Remove a subchain from this chain.</span>
<span class="cm">   *</span>
<span class="cm">   * Remove the subchain starting at head and ending at tail from this chain.</span>
<span class="cm">   *</span>
<span class="cm">   * Returns a unique_ptr pointing to head.  (In other words, ownership of the</span>
<span class="cm">   * head of the subchain is transferred to the caller.)  If the caller ignores</span>
<span class="cm">   * the return value and lets the unique_ptr be destroyed, the subchain will</span>
<span class="cm">   * be immediately destroyed.</span>
<span class="cm">   *</span>
<span class="cm">   * The subchain referenced by the specified head and tail must be part of the</span>
<span class="cm">   * same chain as the current IOBuf, but must not contain the current IOBuf.</span>
<span class="cm">   * However, the specified head and tail may be equal to each other (i.e.,</span>
<span class="cm">   * they may be a subchain of length 1).</span>
<span class="cm">   */</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IOBuf</span><span class="o">&gt;</span> <span class="n">separateChain</span><span class="p">(</span><span class="n">IOBuf</span><span class="o">*</span> <span class="n">head</span><span class="p">,</span> <span class="n">IOBuf</span><span class="o">*</span> <span class="n">tail</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">head</span> <span class="o">!=</span> <span class="n">this</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">tail</span> <span class="o">!=</span> <span class="n">this</span><span class="p">);</span>

    <span class="n">head</span><span class="o">-&gt;</span><span class="n">prev_</span><span class="o">-&gt;</span><span class="n">next_</span> <span class="o">=</span> <span class="n">tail</span><span class="o">-&gt;</span><span class="n">next_</span><span class="p">;</span>
    <span class="n">tail</span><span class="o">-&gt;</span><span class="n">next_</span><span class="o">-&gt;</span><span class="n">prev_</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">prev_</span><span class="p">;</span>

    <span class="n">head</span><span class="o">-&gt;</span><span class="n">prev_</span> <span class="o">=</span> <span class="n">tail</span><span class="p">;</span>
    <span class="n">tail</span><span class="o">-&gt;</span><span class="n">next_</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IOBuf</span><span class="o">&gt;</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Return true if at least one of the IOBufs in this chain are shared,</span>
<span class="cm">   * or false if all of the IOBufs point to unique buffers.</span>
<span class="cm">   *</span>
<span class="cm">   * Use isSharedOne() to only check this IOBuf rather than the entire chain.</span>
<span class="cm">   */</span>
  <span class="n">bool</span> <span class="n">isShared</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">IOBuf</span><span class="o">*</span> <span class="n">current</span> <span class="o">=</span> <span class="n">this</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">isSharedOne</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">next_</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">current</span> <span class="o">==</span> <span class="n">this</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Return true if other IOBufs are also pointing to the buffer used by this</span>
<span class="cm">   * IOBuf, and false otherwise.</span>
<span class="cm">   *</span>
<span class="cm">   * If this IOBuf points at a buffer owned by another (non-IOBuf) part of the</span>
<span class="cm">   * code (i.e., if the IOBuf was created using wrapBuffer(), or was cloned</span>
<span class="cm">   * from such an IOBuf), it is always considered shared.</span>
<span class="cm">   *</span>
<span class="cm">   * This only checks the current IOBuf, and not other IOBufs in the chain.</span>
<span class="cm">   */</span>
  <span class="n">bool</span> <span class="n">isSharedOne</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-9"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-9">&#182;</a></div><p>If this is a user-owned buffer, it is always considered shared</p></td><td class="code"><div class="highlight"><pre>    <span class="k">if</span> <span class="p">(</span><span class="n">flags_</span> <span class="o">&amp;</span> <span class="n">kFlagUserOwned</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">flags_</span> <span class="o">&amp;</span> <span class="n">kFlagExt</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">ext_</span><span class="p">.</span><span class="n">sharedInfo</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Ensure that this IOBuf has a unique buffer that is not shared by other</span>
<span class="cm">   * IOBufs.</span>
<span class="cm">   *</span>
<span class="cm">   * unshare() operates on an entire chain of IOBuf objects.  If the chain is</span>
<span class="cm">   * shared, it may also coalesce the chain when making it unique.  If the</span>
<span class="cm">   * chain is coalesced, subsequent IOBuf objects in the current chain will be</span>
<span class="cm">   * automatically deleted.</span>
<span class="cm">   *</span>
<span class="cm">   * Note that buffers owned by other (non-IOBuf) users are automatically</span>
<span class="cm">   * considered shared.</span>
<span class="cm">   *</span>
<span class="cm">   * Throws std::bad_alloc on error.  On error the IOBuf chain will be</span>
<span class="cm">   * unmodified.</span>
<span class="cm">   *</span>
<span class="cm">   * Currently unshare may also throw std::overflow_error if it tries to</span>
<span class="cm">   * coalesce.  (TODO: In the future it would be nice if unshare() were smart</span>
<span class="cm">   * enough not to coalesce the entire buffer if the data is too large.</span>
<span class="cm">   * However, in practice this seems unlikely to become an issue.)</span>
<span class="cm">   */</span>
  <span class="kt">void</span> <span class="n">unshare</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">isChained</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">unshareChained</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">unshareOne</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Ensure that this IOBuf has a unique buffer that is not shared by other</span>
<span class="cm">   * IOBufs.</span>
<span class="cm">   *</span>
<span class="cm">   * unshareOne() operates on a single IOBuf object.  This IOBuf will have a</span>
<span class="cm">   * unique buffer after unshareOne() returns, but other IOBufs in the chain</span>
<span class="cm">   * may still be shared after unshareOne() returns.</span>
<span class="cm">   *</span>
<span class="cm">   * Throws std::bad_alloc on error.  On error the IOBuf will be unmodified.</span>
<span class="cm">   */</span>
  <span class="kt">void</span> <span class="n">unshareOne</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">isSharedOne</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">unshareOneSlow</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Coalesce this IOBuf chain into a single buffer.</span>
<span class="cm">   *</span>
<span class="cm">   * This method moves all of the data in this IOBuf chain into a single</span>
<span class="cm">   * contiguous buffer, if it is not already in one buffer.  After coalesce()</span>
<span class="cm">   * returns, this IOBuf will be a chain of length one.  Other IOBufs in the</span>
<span class="cm">   * chain will be automatically deleted.</span>
<span class="cm">   *</span>
<span class="cm">   * After coalescing, the IOBuf will have at least as much headroom as the</span>
<span class="cm">   * first IOBuf in the chain, and at least as much tailroom as the last IOBuf</span>
<span class="cm">   * in the chain.</span>
<span class="cm">   *</span>
<span class="cm">   * Throws std::bad_alloc on error.  On error the IOBuf chain will be</span>
<span class="cm">   * unmodified.  Throws std::overflow_error if the length of the entire chain</span>
<span class="cm">   * larger than can be described by a uint32_t capacity.</span>
<span class="cm">   */</span>
  <span class="kt">void</span> <span class="n">coalesce</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isChained</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">coalesceSlow</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Ensure that this chain has at least maxLength bytes available as a</span>
<span class="cm">   * contiguous memory range.</span>
<span class="cm">   *</span>
<span class="cm">   * This method coalesces whole buffers in the chain into this buffer as</span>
<span class="cm">   * necessary until this buffer&#39;s length() is at least maxLength.</span>
<span class="cm">   *</span>
<span class="cm">   * After coalescing, the IOBuf will have at least as much headroom as the</span>
<span class="cm">   * first IOBuf in the chain, and at least as much tailroom as the last IOBuf</span>
<span class="cm">   * that was coalesced.</span>
<span class="cm">   *</span>
<span class="cm">   * Throws std::bad_alloc on error.  On error the IOBuf chain will be</span>
<span class="cm">   * unmodified.  Throws std::overflow_error if the length of the coalesced</span>
<span class="cm">   * portion of the chain is larger than can be described by a uint32_t</span>
<span class="cm">   * capacity.  (Although maxLength is uint32_t, gather() doesn&#39;t split</span>
<span class="cm">   * buffers, so coalescing whole buffers may result in a capacity that can&#39;t</span>
<span class="cm">   * be described in uint32_t.</span>
<span class="cm">   *</span>
<span class="cm">   * Upon return, either enough of the chain was coalesced into a contiguous</span>
<span class="cm">   * region, or the entire chain was coalesced.  That is,</span>
<span class="cm">   * length() &gt;= maxLength || !isChained() is true.</span>
<span class="cm">   */</span>
  <span class="kt">void</span> <span class="n">gather</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">maxLength</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isChained</span><span class="p">()</span> <span class="o">||</span> <span class="n">length_</span> <span class="o">&gt;=</span> <span class="n">maxLength</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">coalesceSlow</span><span class="p">(</span><span class="n">maxLength</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Return a new IOBuf chain sharing the same data as this chain.</span>
<span class="cm">   *</span>
<span class="cm">   * The new IOBuf chain will normally point to the same underlying data</span>
<span class="cm">   * buffers as the original chain.  (The one exception to this is if some of</span>
<span class="cm">   * the IOBufs in this chain contain small internal data buffers which cannot</span>
<span class="cm">   * be shared.)</span>
<span class="cm">   */</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IOBuf</span><span class="o">&gt;</span> <span class="n">clone</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

  <span class="cm">/**</span>
<span class="cm">   * Return a new IOBuf with the same data as this IOBuf.</span>
<span class="cm">   *</span>
<span class="cm">   * The new IOBuf returned will not be part of a chain (even if this IOBuf is</span>
<span class="cm">   * part of a larger chain).</span>
<span class="cm">   */</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IOBuf</span><span class="o">&gt;</span> <span class="n">cloneOne</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-10"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-10">&#182;</a></div><p>Overridden operator new and delete.
These directly use malloc() and free() to allocate the space for IOBuf
objects.  This is needed since IOBuf::create() manually uses malloc when
allocating IOBuf objects with an internal buffer.</p></td><td class="code"><div class="highlight"><pre>  <span class="kt">void</span><span class="o">*</span> <span class="n">operator</span> <span class="n">new</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
  <span class="kt">void</span><span class="o">*</span> <span class="n">operator</span> <span class="n">new</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">);</span>
  <span class="kt">void</span> <span class="n">operator</span> <span class="n">delete</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">);</span>

 <span class="nl">private:</span>
  <span class="k">enum</span> <span class="n">FlagsEnum</span> <span class="p">{</span>
    <span class="n">kFlagExt</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>
    <span class="n">kFlagUserOwned</span> <span class="o">=</span> <span class="mh">0x2</span><span class="p">,</span>
    <span class="n">kFlagFreeSharedInfo</span> <span class="o">=</span> <span class="mh">0x4</span><span class="p">,</span>
  <span class="p">};</span></pre></div></td></tr>


<tr id="section-11"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-11">&#182;</a></div><p>Values for the ExternalBuf type field.
We currently don't really use this for anything, other than to have it
around for debugging purposes.  We store it at the moment just because we
have the 4 extra bytes in the ExternalBuf struct that would just be
padding otherwise.</p></td><td class="code"><div class="highlight"><pre>  <span class="k">enum</span> <span class="n">ExtBufTypeEnum</span> <span class="p">{</span>
    <span class="n">kExtAllocated</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">kExtUserSupplied</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">kExtUserOwned</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
  <span class="p">};</span>

  <span class="k">struct</span> <span class="n">SharedInfo</span> <span class="p">{</span>
    <span class="n">SharedInfo</span><span class="p">();</span>
    <span class="n">SharedInfo</span><span class="p">(</span><span class="n">FreeFunction</span> <span class="n">fn</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-12"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-12">&#182;</a></div><p>A pointer to a function to call to free the buffer when the refcount
hits 0.  If this is NULL, free() will be used instead.</p></td><td class="code"><div class="highlight"><pre>    <span class="n">FreeFunction</span> <span class="n">freeFn</span><span class="p">;</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">userData</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="n">refcount</span><span class="p">;</span>
  <span class="p">};</span>
  <span class="k">struct</span> <span class="n">ExternalBuf</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">capacity</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">type</span><span class="p">;</span>
    <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">buf</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-13"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-13">&#182;</a></div><p>SharedInfo may be NULL if kFlagUserOwned is set.  It is non-NULL
in all other cases.</p></td><td class="code"><div class="highlight"><pre>    <span class="n">SharedInfo</span><span class="o">*</span> <span class="n">sharedInfo</span><span class="p">;</span>
  <span class="p">};</span>
  <span class="k">struct</span> <span class="n">InternalBuf</span> <span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="n">buf</span><span class="p">[]</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">));</span>
  <span class="p">};</span></pre></div></td></tr>


<tr id="section-14"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-14">&#182;</a></div><p>The maximum size for an IOBuf object, including any internal data buffer</p></td><td class="code"><div class="highlight"><pre>  <span class="k">static</span> <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">kMaxIOBufSize</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">kMaxInternalDataSize</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-15"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-15">&#182;</a></div><p>Forbidden copy constructor and assignment opererator</p></td><td class="code"><div class="highlight"><pre>  <span class="n">IOBuf</span><span class="p">(</span><span class="n">IOBuf</span> <span class="k">const</span> <span class="o">&amp;</span><span class="p">);</span>
  <span class="n">IOBuf</span><span class="o">&amp;</span> <span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="n">IOBuf</span> <span class="k">const</span> <span class="o">&amp;</span><span class="p">);</span>

  <span class="cm">/**</span>
<span class="cm">   * Create a new IOBuf with internal data.</span>
<span class="cm">   *</span>
<span class="cm">   * end is a pointer to the end of the IOBuf&#39;s internal data buffer.</span>
<span class="cm">   */</span>
  <span class="n">explicit</span> <span class="n">IOBuf</span><span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span> <span class="n">end</span><span class="p">);</span>

  <span class="cm">/**</span>
<span class="cm">   * Create a new IOBuf pointing to an external buffer.</span>
<span class="cm">   *</span>
<span class="cm">   * The caller is responsible for holding a reference count for this new</span>
<span class="cm">   * IOBuf.  The IOBuf constructor does not automatically increment the</span>
<span class="cm">   * reference count.</span>
<span class="cm">   */</span>
  <span class="n">IOBuf</span><span class="p">(</span><span class="n">ExtBufTypeEnum</span> <span class="n">type</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">,</span>
        <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">capacity</span><span class="p">,</span>
        <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">length</span><span class="p">,</span>
        <span class="n">SharedInfo</span><span class="o">*</span> <span class="n">sharedInfo</span><span class="p">);</span>

  <span class="kt">void</span> <span class="n">unshareOneSlow</span><span class="p">();</span>
  <span class="kt">void</span> <span class="n">unshareChained</span><span class="p">();</span>
  <span class="kt">void</span> <span class="n">coalesceSlow</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">maxLength</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">());</span>
  <span class="kt">void</span> <span class="n">decrementRefcount</span><span class="p">();</span>
  <span class="kt">void</span> <span class="n">reserveSlow</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">minHeadroom</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">minTailroom</span><span class="p">);</span>

  <span class="k">static</span> <span class="kt">size_t</span> <span class="n">goodExtBufferSize</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">minCapacity</span><span class="p">);</span>
  <span class="k">static</span> <span class="kt">void</span> <span class="n">initExtBuffer</span><span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">mallocSize</span><span class="p">,</span>
                            <span class="n">SharedInfo</span><span class="o">**</span> <span class="n">infoReturn</span><span class="p">,</span>
                            <span class="kt">uint32_t</span><span class="o">*</span> <span class="n">capacityReturn</span><span class="p">);</span>
  <span class="k">static</span> <span class="kt">void</span> <span class="n">allocExtBuffer</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">minCapacity</span><span class="p">,</span>
                             <span class="kt">uint8_t</span><span class="o">**</span> <span class="n">bufReturn</span><span class="p">,</span>
                             <span class="n">SharedInfo</span><span class="o">**</span> <span class="n">infoReturn</span><span class="p">,</span>
                             <span class="kt">uint32_t</span><span class="o">*</span> <span class="n">capacityReturn</span><span class="p">);</span>

  <span class="cm">/*</span>
<span class="cm">   * Member variables</span>
<span class="cm">   */</span>

  <span class="cm">/*</span>
<span class="cm">   * Links to the next and the previous IOBuf in this chain.</span>
<span class="cm">   *</span>
<span class="cm">   * The chain is circularly linked (the last element in the chain points back</span>
<span class="cm">   * at the head), and next_ and prev_ can never be NULL.  If this IOBuf is the</span>
<span class="cm">   * only element in the chain, next_ and prev_ will both point to this.</span>
<span class="cm">   */</span>
  <span class="n">IOBuf</span><span class="o">*</span> <span class="n">next_</span><span class="p">;</span>
  <span class="n">IOBuf</span><span class="o">*</span> <span class="n">prev_</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">   * A pointer to the start of the data referenced by this IOBuf, and the</span>
<span class="cm">   * length of the data.</span>
<span class="cm">   *</span>
<span class="cm">   * This may refer to any subsection of the actual buffer capacity.</span>
<span class="cm">   */</span>
  <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">data_</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">length_</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">flags_</span><span class="p">;</span>

  <span class="k">union</span> <span class="p">{</span>
    <span class="n">ExternalBuf</span> <span class="n">ext_</span><span class="p">;</span>
    <span class="n">InternalBuf</span> <span class="n">int_</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="k">struct</span> <span class="n">DeleterBase</span> <span class="p">{</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">DeleterBase</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">dispose</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">UniquePtr</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="n">UniquePtrDeleter</span> <span class="o">:</span> <span class="n">public</span> <span class="n">DeleterBase</span> <span class="p">{</span>
    <span class="k">typedef</span> <span class="kr">typename</span> <span class="n">UniquePtr</span><span class="o">::</span><span class="n">pointer</span> <span class="n">Pointer</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="kr">typename</span> <span class="n">UniquePtr</span><span class="o">::</span><span class="n">deleter_type</span> <span class="n">Deleter</span><span class="p">;</span>

    <span class="n">explicit</span> <span class="nf">UniquePtrDeleter</span><span class="p">(</span><span class="n">Deleter</span> <span class="n">deleter</span><span class="p">)</span> <span class="o">:</span> <span class="n">deleter_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">deleter</span><span class="p">)){</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">dispose</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">try</span> <span class="p">{</span>
        <span class="n">deleter_</span><span class="p">(</span><span class="n">static_cast</span><span class="o">&lt;</span><span class="n">Pointer</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>
        <span class="n">delete</span> <span class="n">this</span><span class="p">;</span>
      <span class="p">}</span> <span class="n">catch</span> <span class="p">(...)</span> <span class="p">{</span>
        <span class="n">abort</span><span class="p">();</span>
      <span class="p">}</span>
    <span class="p">}</span>

   <span class="nl">private:</span>
    <span class="n">Deleter</span> <span class="n">deleter_</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="k">static</span> <span class="kt">void</span> <span class="nf">freeUniquePtrBuffer</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">userData</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">static_cast</span><span class="o">&lt;</span><span class="n">DeleterBase</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">userData</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dispose</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">UniquePtr</span><span class="o">&gt;</span>
<span class="kr">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">detail</span><span class="o">::</span><span class="n">IsUniquePtrToSL</span><span class="o">&lt;</span><span class="n">UniquePtr</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
                        <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IOBuf</span><span class="o">&gt;&gt;::</span><span class="n">type</span>
<span class="n">IOBuf</span><span class="o">::</span><span class="n">takeOwnership</span><span class="p">(</span><span class="n">UniquePtr</span><span class="o">&amp;&amp;</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kr">typename</span> <span class="n">UniquePtr</span><span class="o">::</span><span class="n">element_type</span><span class="p">);</span>
  <span class="n">CHECK_LT</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">()));</span>
  <span class="k">auto</span> <span class="n">deleter</span> <span class="o">=</span> <span class="n">new</span> <span class="n">UniquePtrDeleter</span><span class="o">&lt;</span><span class="n">UniquePtr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">buf</span><span class="p">.</span><span class="n">get_deleter</span><span class="p">());</span>
  <span class="k">return</span> <span class="n">takeOwnership</span><span class="p">(</span><span class="n">buf</span><span class="p">.</span><span class="n">release</span><span class="p">(),</span>
                       <span class="n">size</span><span class="p">,</span>
                       <span class="o">&amp;</span><span class="n">IOBuf</span><span class="o">::</span><span class="n">freeUniquePtrBuffer</span><span class="p">,</span>
                       <span class="n">deleter</span><span class="p">);</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IOBuf</span><span class="o">&gt;</span> <span class="n">IOBuf</span><span class="o">::</span><span class="n">copyBuffer</span><span class="p">(</span>
    <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">headroom</span><span class="p">,</span>
    <span class="kt">uint32_t</span> <span class="n">minTailroom</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">uint32_t</span> <span class="n">capacity</span> <span class="o">=</span> <span class="n">headroom</span> <span class="o">+</span> <span class="n">size</span> <span class="o">+</span> <span class="n">minTailroom</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IOBuf</span><span class="o">&gt;</span> <span class="n">buf</span> <span class="o">=</span> <span class="n">create</span><span class="p">(</span><span class="n">capacity</span><span class="p">);</span>
  <span class="n">buf</span><span class="o">-&gt;</span><span class="n">advance</span><span class="p">(</span><span class="n">headroom</span><span class="p">);</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">writableData</span><span class="p">(),</span> <span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
  <span class="n">buf</span><span class="o">-&gt;</span><span class="n">append</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">}</span> <span class="c1">// folly</span>

<span class="cp">#endif </span><span class="c1">// FOLLY_IO_IOBUF_H_</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/folly",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
