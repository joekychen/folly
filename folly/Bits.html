<!DOCTYPE html>
<html><head><title>joekychen/folly » folly › Bits.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>Bits.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2012 Facebook, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="cm"> * you may not use this file except in compliance with the License.</span>
<span class="cm"> * You may obtain a copy of the License at</span>
<span class="cm"> *</span>
<span class="cm"> *   http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="cm"> *</span>
<span class="cm"> * Unless required by applicable law or agreed to in writing, software</span>
<span class="cm"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="cm"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="cm"> * See the License for the specific language governing permissions and</span>
<span class="cm"> * limitations under the License.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * Various low-level, bit-manipulation routines.</span>
<span class="cm"> *</span>
<span class="cm"> * findFirstSet(x)</span>
<span class="cm"> *    find first (least significant) bit set in a value of an integral type,</span>
<span class="cm"> *    1-based (like ffs()).  0 = no bits are set (x == 0)</span>
<span class="cm"> *</span>
<span class="cm"> * findLastSet(x)</span>
<span class="cm"> *    find last (most significant) bit set in a value of an integral type,</span>
<span class="cm"> *    1-based.  0 = no bits are set (x == 0)</span>
<span class="cm"> *    for x != 0, findFirstSet(x) == 1 + floor(log2(x))</span>
<span class="cm"> *</span>
<span class="cm"> * nextPowTwo(x)</span>
<span class="cm"> *    Finds the next power of two &gt;= x.</span>
<span class="cm"> *</span>
<span class="cm"> * Endian</span>
<span class="cm"> *    convert between native, big, and little endian representation</span>
<span class="cm"> *    Endian::big(x)      big &lt;-&gt; native</span>
<span class="cm"> *    Endian::little(x)   little &lt;-&gt; native</span>
<span class="cm"> *    Endian::swap(x)     big &lt;-&gt; little</span>
<span class="cm"> *</span>
<span class="cm"> * BitIterator</span>
<span class="cm"> *    Wrapper around an iterator over an integral type that iterates</span>
<span class="cm"> *    over its underlying bits in MSb to LSb order</span>
<span class="cm"> *</span>
<span class="cm"> * findFirstSet(BitIterator begin, BitIterator end)</span>
<span class="cm"> *    return a BitIterator pointing to the first 1 bit in [begin, end), or</span>
<span class="cm"> *    end if all bits in [begin, end) are 0</span>
<span class="cm"> *</span>
<span class="cm"> * @author Tudor Bosman (tudorb@fb.com)</span>
<span class="cm"> */</span>

<span class="cp">#ifndef FOLLY_BITS_H_</span>
<span class="cp">#define FOLLY_BITS_H_</span>

<span class="cp">#include &quot;folly/Portability.h&quot;</span>

<span class="cp">#ifndef _GNU_SOURCE</span>
<span class="cp">#define _GNU_SOURCE 1</span>
<span class="cp">#endif</span>

<span class="cp">#include &quot;folly/detail/BitIteratorDetail.h&quot;</span>
<span class="cp">#include &quot;folly/Likely.h&quot;</span>

<span class="cp">#include &lt;byteswap.h&gt;</span>
<span class="cp">#include &lt;cassert&gt;</span>
<span class="cp">#include &lt;cinttypes&gt;</span>
<span class="cp">#include &lt;cstring&gt;  </span><span class="c1">// for ffs, ffsl, ffsll</span>
<span class="cp">#include &lt;endian.h&gt;</span>
<span class="cp">#include &lt;iterator&gt;</span>
<span class="cp">#include &lt;limits&gt;</span>
<span class="cp">#include &lt;type_traits&gt;</span>
<span class="cp">#include &lt;boost/iterator/iterator_adaptor.hpp&gt;</span>
<span class="cp">#include &lt;stdint.h&gt;</span>

<span class="n">namespace</span> <span class="n">folly</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>Generate overloads for findFirstSet as wrappers around
appropriate ffs, ffsl, ffsll functions from glibc.
We first define these overloads for signed types (because ffs, ffsl, ffsll
take int, long, and long long as arguments, respectively) and then
define an overload for unsigned that forwards to the overload for the
corresponding signed type.</p></td><td class="code"><div class="highlight"><pre><span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span>
  <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_integral</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&amp;&amp;</span>
   <span class="n">std</span><span class="o">::</span><span class="n">is_signed</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&amp;&amp;</span>
   <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">digits</span> <span class="o">&lt;=</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">digits</span><span class="p">)),</span>
  <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">type</span>
  <span class="n">findFirstSet</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">::</span><span class="n">ffs</span><span class="p">(</span><span class="n">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
<span class="p">}</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span>
  <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_integral</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&amp;&amp;</span>
   <span class="n">std</span><span class="o">::</span><span class="n">is_signed</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&amp;&amp;</span>
   <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">digits</span> <span class="o">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">digits</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
   <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">digits</span> <span class="o">&lt;=</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;::</span><span class="n">digits</span><span class="p">)),</span>
  <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">type</span>
  <span class="n">findFirstSet</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">::</span><span class="n">ffsl</span><span class="p">(</span><span class="n">static_cast</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#ifdef FOLLY_HAVE_FFSLL</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span>
  <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_integral</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&amp;&amp;</span>
   <span class="n">std</span><span class="o">::</span><span class="n">is_signed</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&amp;&amp;</span>
   <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">digits</span> <span class="o">&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">long</span><span class="o">&gt;::</span><span class="n">digits</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
   <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">digits</span> <span class="o">&lt;=</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;::</span><span class="n">digits</span><span class="p">)),</span>
  <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">type</span>
  <span class="n">findFirstSet</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">::</span><span class="n">ffsll</span><span class="p">(</span><span class="n">static_cast</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span>
  <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_integral</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&amp;&amp;</span>
   <span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">is_signed</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">),</span>
  <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">type</span>
  <span class="n">findFirstSet</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>Note that conversion from an unsigned type to the corresponding signed
type is technically implementation-defined, but will likely work
on any impementation that uses two's complement.</p></td><td class="code"><div class="highlight"><pre>  <span class="k">return</span> <span class="n">findFirstSet</span><span class="p">(</span><span class="n">static_cast</span><span class="o">&lt;</span><span class="kr">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">make_signed</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
<span class="p">}</span>

<span class="n">namespace</span> <span class="n">detail</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>Portable, but likely slow...</p></td><td class="code"><div class="highlight"><pre><span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">findLastSetPortable</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>  <span class="c1">// 1-based index, except for x==0</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">r</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">}</span>  <span class="c1">// namespace detail</span>

<span class="cp">#ifdef __GNUC__</span></pre></div></td></tr>


<tr id="section-5"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-5">&#182;</a></div><p>findLastSet: return the 1-based index of the highest bit set
for x > 0, findLastSet(x) == 1 + floor(log2(x))</p></td><td class="code"><div class="highlight"><pre><span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span>
  <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_integral</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&amp;&amp;</span>
   <span class="n">std</span><span class="o">::</span><span class="n">is_unsigned</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&amp;&amp;</span>
   <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">digits</span> <span class="o">&lt;=</span>
    <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">digits</span><span class="p">)),</span>
  <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">type</span>
  <span class="n">findLastSet</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">x</span> <span class="o">?</span> <span class="mi">8</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="o">-</span> <span class="n">__builtin_clz</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span>
  <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_integral</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&amp;&amp;</span>
   <span class="n">std</span><span class="o">::</span><span class="n">is_unsigned</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&amp;&amp;</span>
   <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">digits</span> <span class="o">&gt;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">digits</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
   <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">digits</span> <span class="o">&lt;=</span>
    <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="o">&gt;::</span><span class="n">digits</span><span class="p">)),</span>
  <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">type</span>
  <span class="n">findLastSet</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">x</span> <span class="o">?</span> <span class="mi">8</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="o">-</span> <span class="n">__builtin_clzl</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span>
  <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_integral</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&amp;&amp;</span>
   <span class="n">std</span><span class="o">::</span><span class="n">is_unsigned</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&amp;&amp;</span>
   <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">digits</span> <span class="o">&gt;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="o">&gt;::</span><span class="n">digits</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
   <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">digits</span> <span class="o">&lt;=</span>
    <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;::</span><span class="n">digits</span><span class="p">)),</span>
  <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">type</span>
  <span class="n">findLastSet</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">x</span> <span class="o">?</span> <span class="mi">8</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="o">-</span> <span class="n">__builtin_clzll</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else  </span><span class="cm">/* !__GNUC__ */</span><span class="cp"></span>

<span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span>
  <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_integral</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&amp;&amp;</span>
   <span class="n">std</span><span class="o">::</span><span class="n">is_unsigned</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">),</span>
  <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">type</span>
  <span class="n">findLastSet</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">detail</span><span class="o">:</span><span class="n">findLastSetPortable</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span>
  <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_integral</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&amp;&amp;</span>
   <span class="n">std</span><span class="o">::</span><span class="n">is_signed</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">),</span>
  <span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">type</span>
  <span class="n">findLastSet</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">findLastSet</span><span class="p">(</span><span class="n">static_cast</span><span class="o">&lt;</span><span class="kr">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unsigned</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
<span class="p">}</span>

<span class="n">namespace</span> <span class="n">detail</span> <span class="p">{</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span>
<span class="kr">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">is_integral</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&amp;&amp;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_unsigned</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
  <span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span>
<span class="n">nextPowTwoPortable</span><span class="p">(</span><span class="n">T</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="o">--</span><span class="n">v</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;&lt;=</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">v</span> <span class="o">|=</span> <span class="p">(</span><span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">);</span>
    <span class="n">v</span> <span class="o">|=</span> <span class="p">(</span><span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">));</span>
    <span class="n">v</span> <span class="o">|=</span> <span class="p">(</span><span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">));</span>
    <span class="n">v</span> <span class="o">|=</span> <span class="p">(</span><span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">));</span>
    <span class="n">v</span> <span class="o">|=</span> <span class="p">(</span><span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">));</span>
    <span class="n">v</span> <span class="o">|=</span> <span class="p">(</span><span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">));</span>
    <span class="n">v</span> <span class="o">|=</span> <span class="p">(</span><span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">));</span>
    <span class="n">v</span> <span class="o">|=</span> <span class="p">(</span><span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">v</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">}</span>  <span class="c1">// namespace detail</span>

<span class="cp">#ifdef __GNUC__</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span>
<span class="kr">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">is_integral</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&amp;&amp;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_unsigned</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
  <span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span>
<span class="n">nextPowTwo</span><span class="p">(</span><span class="n">T</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">1ul</span> <span class="o">&lt;&lt;</span> <span class="n">findLastSet</span><span class="p">(</span><span class="n">v</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else </span><span class="cm">/* __GNUC__ */</span><span class="cp"></span>

<span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span>
<span class="kr">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">is_integral</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&amp;&amp;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_unsigned</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
  <span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span>
<span class="n">nextPowTwo</span><span class="p">(</span><span class="n">T</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">detail</span><span class="o">::</span><span class="n">nextPowTwoPortable</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* __GNUC__ */</span><span class="cp"></span>



<span class="cm">/**</span>
<span class="cm"> * Endianness detection and manipulation primitives.</span>
<span class="cm"> */</span>
<span class="n">namespace</span> <span class="n">detail</span> <span class="p">{</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">EndianIntBase</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">static</span> <span class="n">T</span> <span class="n">swap</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">);</span>
<span class="p">};</span>

<span class="cp">#define FB_GEN(t, fn) \</span>
<span class="cp">template&lt;&gt; inline t EndianIntBase&lt;t&gt;::swap(t x) { return fn(x); }</span></pre></div></td></tr>


<tr id="section-6"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-6">&#182;</a></div><p>fn(x) expands to (x) if the second argument is empty, which is exactly
what we want for [u]int8_t</p></td><td class="code"><div class="highlight"><pre><span class="n">FB_GEN</span><span class="p">(</span> <span class="kt">int8_t</span><span class="p">,)</span>
<span class="n">FB_GEN</span><span class="p">(</span><span class="kt">uint8_t</span><span class="p">,)</span>
<span class="n">FB_GEN</span><span class="p">(</span> <span class="kt">int64_t</span><span class="p">,</span> <span class="n">bswap_64</span><span class="p">)</span>
<span class="n">FB_GEN</span><span class="p">(</span><span class="kt">uint64_t</span><span class="p">,</span> <span class="n">bswap_64</span><span class="p">)</span>
<span class="n">FB_GEN</span><span class="p">(</span> <span class="kt">int32_t</span><span class="p">,</span> <span class="n">bswap_32</span><span class="p">)</span>
<span class="n">FB_GEN</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="n">bswap_32</span><span class="p">)</span>
<span class="n">FB_GEN</span><span class="p">(</span> <span class="kt">int16_t</span><span class="p">,</span> <span class="n">bswap_16</span><span class="p">)</span>
<span class="n">FB_GEN</span><span class="p">(</span><span class="kt">uint16_t</span><span class="p">,</span> <span class="n">bswap_16</span><span class="p">)</span>

<span class="cp">#undef FB_GEN</span>

<span class="cp">#if __BYTE_ORDER == __LITTLE_ENDIAN</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">EndianInt</span> <span class="o">:</span> <span class="n">public</span> <span class="n">detail</span><span class="o">::</span><span class="n">EndianIntBase</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">static</span> <span class="n">T</span> <span class="n">big</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">EndianInt</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="p">}</span>
  <span class="k">static</span> <span class="n">T</span> <span class="n">little</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="cp">#elif __BYTE_ORDER == __BIG_ENDIAN</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">EndianInt</span> <span class="o">:</span> <span class="n">public</span> <span class="n">detail</span><span class="o">::</span><span class="n">EndianIntBase</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">static</span> <span class="n">T</span> <span class="n">big</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">static</span> <span class="n">T</span> <span class="n">little</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">EndianInt</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="p">}</span>
<span class="p">};</span>

<span class="cp">#else</span>
<span class="cp"># error Your machine uses a weird endianness!</span>
<span class="cp">#endif  </span><span class="cm">/* __BYTE_ORDER */</span><span class="cp"></span>

<span class="p">}</span>  <span class="c1">// namespace detail</span></pre></div></td></tr>


<tr id="section-7"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-7">&#182;</a></div><p>big* convert between native and big-endian representations
little* convert between native and little-endian representations
swap* convert between big-endian and little-endian representations</p>

<p>ntohs, htons == big16
ntohl, htonl == big32</p></td><td class="code"><div class="highlight"><pre><span class="cp">#define FB_GEN1(fn, t, sz) \</span>
<span class="cp">  static t fn##sz(t x) { return fn&lt;t&gt;(x); } \</span>

<span class="cp">#define FB_GEN2(t, sz) \</span>
<span class="cp">  FB_GEN1(swap, t, sz) \</span>
<span class="cp">  FB_GEN1(big, t, sz) \</span>
<span class="cp">  FB_GEN1(little, t, sz)</span>

<span class="cp">#define FB_GEN(sz) \</span>
<span class="cp">  FB_GEN2(uint##sz##_t, sz) \</span>
<span class="cp">  FB_GEN2(int##sz##_t, sz)</span>

<span class="n">class</span> <span class="n">Endian</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">enum</span> <span class="n">class</span> <span class="n">Order</span> <span class="o">:</span> <span class="kt">uint8_t</span> <span class="p">{</span>
    <span class="n">LITTLE</span><span class="p">,</span>
    <span class="n">BIG</span>
  <span class="p">};</span>

  <span class="k">static</span> <span class="n">constexpr</span> <span class="n">Order</span> <span class="n">order</span> <span class="o">=</span>
<span class="cp">#if __BYTE_ORDER == __LITTLE_ENDIAN</span>
    <span class="n">Order</span><span class="o">::</span><span class="n">LITTLE</span><span class="p">;</span>
<span class="cp">#elif __BYTE_ORDER == __BIG_ENDIAN</span>
    <span class="n">Order</span><span class="o">::</span><span class="n">BIG</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="cp"># error Your machine uses a weird endianness!</span>
<span class="cp">#endif  </span><span class="cm">/* __BYTE_ORDER */</span><span class="cp"></span>

  <span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">static</span> <span class="n">T</span> <span class="n">swap</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">detail</span><span class="o">::</span><span class="n">EndianInt</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">swap</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">static</span> <span class="n">T</span> <span class="n">big</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">detail</span><span class="o">::</span><span class="n">EndianInt</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">big</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">static</span> <span class="n">T</span> <span class="n">little</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">detail</span><span class="o">::</span><span class="n">EndianInt</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">little</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">FB_GEN</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>
  <span class="n">FB_GEN</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
  <span class="n">FB_GEN</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
  <span class="n">FB_GEN</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="p">};</span>

<span class="cp">#undef FB_GEN</span>
<span class="cp">#undef FB_GEN2</span>
<span class="cp">#undef FB_GEN1</span>

<span class="cm">/**</span>
<span class="cm"> * Fast bit iteration facility.</span>
<span class="cm"> */</span>


<span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">BaseIter</span><span class="o">&gt;</span> <span class="n">class</span> <span class="n">BitIterator</span><span class="p">;</span>
<span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">BaseIter</span><span class="o">&gt;</span>
<span class="n">BitIterator</span><span class="o">&lt;</span><span class="n">BaseIter</span><span class="o">&gt;</span> <span class="n">findFirstSet</span><span class="p">(</span><span class="n">BitIterator</span><span class="o">&lt;</span><span class="n">BaseIter</span><span class="o">&gt;</span><span class="p">,</span>
                                   <span class="n">BitIterator</span><span class="o">&lt;</span><span class="n">BaseIter</span><span class="o">&gt;</span><span class="p">);</span>
<span class="cm">/**</span>
<span class="cm"> * Wrapper around an iterator over an integer type that iterates</span>
<span class="cm"> * over its underlying bits in LSb to MSb order.</span>
<span class="cm"> *</span>
<span class="cm"> * BitIterator models the same iterator concepts as the base iterator.</span>
<span class="cm"> */</span>
<span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">BaseIter</span><span class="o">&gt;</span>
<span class="n">class</span> <span class="n">BitIterator</span>
  <span class="o">:</span> <span class="n">public</span> <span class="n">bititerator_detail</span><span class="o">::</span><span class="n">BitIteratorBase</span><span class="o">&lt;</span><span class="n">BaseIter</span><span class="o">&gt;::</span><span class="n">type</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="cm">/**</span>
<span class="cm">   * Return the number of bits in an element of the underlying iterator.</span>
<span class="cm">   */</span>
  <span class="k">static</span> <span class="kt">size_t</span> <span class="n">bitsPerBlock</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span>
      <span class="kr">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unsigned</span><span class="o">&lt;</span>
        <span class="kr">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">BaseIter</span><span class="o">&gt;::</span><span class="n">value_type</span>
      <span class="o">&gt;::</span><span class="n">type</span>
    <span class="o">&gt;::</span><span class="n">digits</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="cm">/**</span>
<span class="cm">   * Construct a BitIterator that points at a given bit offset (default 0)</span>
<span class="cm">   * in iter.</span>
<span class="cm">   */</span>
  <span class="n">explicit</span> <span class="n">BitIterator</span><span class="p">(</span><span class="k">const</span> <span class="n">BaseIter</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">bitOffset</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">bititerator_detail</span><span class="o">::</span><span class="n">BitIteratorBase</span><span class="o">&lt;</span><span class="n">BaseIter</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">(</span><span class="n">iter</span><span class="p">),</span>
      <span class="n">bitOffset_</span><span class="p">(</span><span class="n">bitOffset</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">bitOffset_</span> <span class="o">&lt;</span> <span class="n">bitsPerBlock</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="kt">size_t</span> <span class="n">bitOffset</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">bitOffset_</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">advanceToNextBlock</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">bitOffset_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="o">++</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">base_reference</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">BitIterator</span><span class="o">&amp;</span> <span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">BaseIter</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">this</span><span class="o">-&gt;~</span><span class="n">BitIterator</span><span class="p">();</span>
    <span class="n">new</span> <span class="p">(</span><span class="n">this</span><span class="p">)</span> <span class="n">BitIterator</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span>
  <span class="p">}</span>

 <span class="nl">private:</span>
  <span class="n">friend</span> <span class="n">class</span> <span class="n">boost</span><span class="o">::</span><span class="n">iterator_core_access</span><span class="p">;</span>
  <span class="n">friend</span> <span class="n">BitIterator</span> <span class="n">findFirstSet</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">BitIterator</span><span class="p">,</span> <span class="n">BitIterator</span><span class="p">);</span>

  <span class="k">typedef</span> <span class="n">bititerator_detail</span><span class="o">::</span><span class="n">BitReference</span><span class="o">&lt;</span>
      <span class="kr">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">BaseIter</span><span class="o">&gt;::</span><span class="n">reference</span><span class="p">,</span>
      <span class="kr">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">BaseIter</span><span class="o">&gt;::</span><span class="n">value_type</span>
    <span class="o">&gt;</span> <span class="n">BitRef</span><span class="p">;</span>

  <span class="kt">void</span> <span class="nf">advanceInBlock</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">bitOffset_</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">bitOffset_</span> <span class="o">&lt;</span> <span class="n">bitsPerBlock</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="n">BitRef</span> <span class="n">dereference</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">BitRef</span><span class="p">(</span><span class="o">*</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">base_reference</span><span class="p">(),</span> <span class="n">bitOffset_</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">advance</span><span class="p">(</span><span class="kt">ssize_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">bpb</span> <span class="o">=</span> <span class="n">bitsPerBlock</span><span class="p">();</span>
    <span class="kt">ssize_t</span> <span class="n">blocks</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="n">bpb</span><span class="p">;</span>
    <span class="n">bitOffset_</span> <span class="o">+=</span> <span class="n">n</span> <span class="o">%</span> <span class="n">bpb</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">bitOffset_</span> <span class="o">&gt;=</span> <span class="n">bpb</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">bitOffset_</span> <span class="o">-=</span> <span class="n">bpb</span><span class="p">;</span>
      <span class="o">++</span><span class="n">blocks</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">this</span><span class="o">-&gt;</span><span class="n">base_reference</span><span class="p">()</span> <span class="o">+=</span> <span class="n">blocks</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">increment</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">bitOffset_</span> <span class="o">==</span> <span class="n">bitsPerBlock</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">advanceToNextBlock</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">decrement</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">bitOffset_</span><span class="o">--</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">bitOffset_</span> <span class="o">=</span> <span class="n">bitsPerBlock</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
      <span class="o">--</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">base_reference</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">bool</span> <span class="n">equal</span><span class="p">(</span><span class="k">const</span> <span class="n">BitIterator</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">bitOffset_</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">bitOffset_</span> <span class="o">&amp;&amp;</span>
            <span class="n">this</span><span class="o">-&gt;</span><span class="n">base_reference</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">base_reference</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="kt">ssize_t</span> <span class="n">distance_to</span><span class="p">(</span><span class="k">const</span> <span class="n">BitIterator</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span>
      <span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">base_reference</span><span class="p">()</span> <span class="o">-</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">base_reference</span><span class="p">())</span> <span class="o">*</span> <span class="n">bitsPerBlock</span><span class="p">()</span> <span class="o">+</span>
      <span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">bitOffset_</span> <span class="o">-</span> <span class="n">bitOffset_</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">ssize_t</span> <span class="n">bitOffset_</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Helper function, so you can write</span>
<span class="cm"> * auto bi = makeBitIterator(container.begin());</span>
<span class="cm"> */</span>
<span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">BaseIter</span><span class="o">&gt;</span>
<span class="n">BitIterator</span><span class="o">&lt;</span><span class="n">BaseIter</span><span class="o">&gt;</span> <span class="n">makeBitIterator</span><span class="p">(</span><span class="k">const</span> <span class="n">BaseIter</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">BitIterator</span><span class="o">&lt;</span><span class="n">BaseIter</span><span class="o">&gt;</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * Find first bit set in a range of bit iterators.</span>
<span class="cm"> * 4.5x faster than the obvious std::find(begin, end, true);</span>
<span class="cm"> */</span>
<span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">BaseIter</span><span class="o">&gt;</span>
<span class="n">BitIterator</span><span class="o">&lt;</span><span class="n">BaseIter</span><span class="o">&gt;</span> <span class="n">findFirstSet</span><span class="p">(</span><span class="n">BitIterator</span><span class="o">&lt;</span><span class="n">BaseIter</span><span class="o">&gt;</span> <span class="n">begin</span><span class="p">,</span>
                                   <span class="n">BitIterator</span><span class="o">&lt;</span><span class="n">BaseIter</span><span class="o">&gt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-8"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-8">&#182;</a></div><p>shortcut to avoid ugly static_cast&lt;></p></td><td class="code"><div class="highlight"><pre>  <span class="k">static</span> <span class="k">const</span> <span class="kr">typename</span> <span class="n">BaseIter</span><span class="o">::</span><span class="n">value_type</span> <span class="n">one</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">begin</span><span class="p">.</span><span class="n">base</span><span class="p">()</span> <span class="o">!=</span> <span class="n">end</span><span class="p">.</span><span class="n">base</span><span class="p">())</span> <span class="p">{</span>
    <span class="kr">typename</span> <span class="n">BaseIter</span><span class="o">::</span><span class="n">value_type</span> <span class="n">v</span> <span class="o">=</span> <span class="o">*</span><span class="n">begin</span><span class="p">.</span><span class="n">base</span><span class="p">();</span></pre></div></td></tr>


<tr id="section-9"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-9">&#182;</a></div><p>mask out the bits that don't matter (&lt; begin.bitOffset)</p></td><td class="code"><div class="highlight"><pre>    <span class="n">v</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">((</span><span class="n">one</span> <span class="o">&lt;&lt;</span> <span class="n">begin</span><span class="p">.</span><span class="n">bitOffset</span><span class="p">())</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="kt">size_t</span> <span class="n">firstSet</span> <span class="o">=</span> <span class="n">findFirstSet</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">firstSet</span><span class="p">)</span> <span class="p">{</span>
      <span class="o">--</span><span class="n">firstSet</span><span class="p">;</span>  <span class="c1">// now it&#39;s 0-based</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">firstSet</span> <span class="o">&gt;=</span> <span class="n">begin</span><span class="p">.</span><span class="n">bitOffset</span><span class="p">());</span>
      <span class="n">begin</span><span class="p">.</span><span class="n">advanceInBlock</span><span class="p">(</span><span class="n">firstSet</span> <span class="o">-</span> <span class="n">begin</span><span class="p">.</span><span class="n">bitOffset</span><span class="p">());</span>
      <span class="k">return</span> <span class="n">begin</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">begin</span><span class="p">.</span><span class="n">advanceToNextBlock</span><span class="p">();</span>
  <span class="p">}</span></pre></div></td></tr>


<tr id="section-10"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-10">&#182;</a></div><p>now begin points to the same block as end</p></td><td class="code"><div class="highlight"><pre>  <span class="k">if</span> <span class="p">(</span><span class="n">end</span><span class="p">.</span><span class="n">bitOffset</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// assume end is dereferenceable</span>
    <span class="kr">typename</span> <span class="n">BaseIter</span><span class="o">::</span><span class="n">value_type</span> <span class="n">v</span> <span class="o">=</span> <span class="o">*</span><span class="n">begin</span><span class="p">.</span><span class="n">base</span><span class="p">();</span></pre></div></td></tr>


<tr id="section-11"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-11">&#182;</a></div><p>mask out the bits that don't matter (&lt; begin.bitOffset)</p></td><td class="code"><div class="highlight"><pre>    <span class="n">v</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">((</span><span class="n">one</span> <span class="o">&lt;&lt;</span> <span class="n">begin</span><span class="p">.</span><span class="n">bitOffset</span><span class="p">())</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-12"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-12">&#182;</a></div><p>mask out the bits that don't matter (>= end.bitOffset)</p></td><td class="code"><div class="highlight"><pre>    <span class="n">v</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">one</span> <span class="o">&lt;&lt;</span> <span class="n">end</span><span class="p">.</span><span class="n">bitOffset</span><span class="p">())</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">firstSet</span> <span class="o">=</span> <span class="n">findFirstSet</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">firstSet</span><span class="p">)</span> <span class="p">{</span>
      <span class="o">--</span><span class="n">firstSet</span><span class="p">;</span>  <span class="c1">// now it&#39;s 0-based</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">firstSet</span> <span class="o">&gt;=</span> <span class="n">begin</span><span class="p">.</span><span class="n">bitOffset</span><span class="p">());</span>
      <span class="n">begin</span><span class="p">.</span><span class="n">advanceInBlock</span><span class="p">(</span><span class="n">firstSet</span> <span class="o">-</span> <span class="n">begin</span><span class="p">.</span><span class="n">bitOffset</span><span class="p">());</span>
      <span class="k">return</span> <span class="n">begin</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">end</span><span class="p">;</span>
<span class="p">}</span>


<span class="n">namespace</span> <span class="n">detail</span> <span class="p">{</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="p">,</span> <span class="n">class</span> <span class="n">Enable</span><span class="o">=</span><span class="kt">void</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">Unaligned</span><span class="p">;</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Unaligned</span><span class="o">&lt;</span>
  <span class="n">T</span><span class="p">,</span>
  <span class="kr">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_pod</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">T</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="p">}</span>  <span class="c1">// namespace detail</span>

<span class="cm">/**</span>
<span class="cm"> * Read an unaligned value of type T and return it.</span>
<span class="cm"> */</span>
<span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span> <span class="n">loadUnaligned</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">static_assert</span><span class="p">(</span><span class="n">alignof</span><span class="p">(</span><span class="n">detail</span><span class="o">::</span><span class="n">Unaligned</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Invalid alignment&quot;</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">detail</span><span class="o">::</span><span class="n">Unaligned</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Write an unaligned value of type T.</span>
<span class="cm"> */</span>
<span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">storeUnaligned</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">T</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">static_assert</span><span class="p">(</span><span class="n">alignof</span><span class="p">(</span><span class="n">detail</span><span class="o">::</span><span class="n">Unaligned</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Invalid alignment&quot;</span><span class="p">);</span>
  <span class="n">static_cast</span><span class="o">&lt;</span><span class="n">detail</span><span class="o">::</span><span class="n">Unaligned</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">}</span>  <span class="c1">// namespace folly</span>

<span class="cp">#endif </span><span class="cm">/* FOLLY_BITS_H_ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/folly",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
