<!DOCTYPE html>
<html><head><title>joekychen/folly » folly › detail › ThreadLocalDetail.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>ThreadLocalDetail.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2012 Facebook, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="cm"> * you may not use this file except in compliance with the License.</span>
<span class="cm"> * You may obtain a copy of the License at</span>
<span class="cm"> *</span>
<span class="cm"> *   http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="cm"> *</span>
<span class="cm"> * Unless required by applicable law or agreed to in writing, software</span>
<span class="cm"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="cm"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="cm"> * See the License for the specific language governing permissions and</span>
<span class="cm"> * limitations under the License.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef FOLLY_DETAIL_THREADLOCALDETAIL_H_</span>
<span class="cp">#define FOLLY_DETAIL_THREADLOCALDETAIL_H_</span>

<span class="cp">#include &lt;limits.h&gt;</span>
<span class="cp">#include &lt;pthread.h&gt;</span>
<span class="cp">#include &lt;list&gt;</span>
<span class="cp">#include &lt;string&gt;</span>
<span class="cp">#include &lt;vector&gt;</span>

<span class="cp">#include &lt;boost/thread/mutex.hpp&gt;</span>

<span class="cp">#include &lt;glog/logging.h&gt;</span>

<span class="cp">#include &quot;folly/Foreach.h&quot;</span>
<span class="cp">#include &quot;folly/Malloc.h&quot;</span>

<span class="n">namespace</span> <span class="n">folly</span> <span class="p">{</span>
<span class="n">namespace</span> <span class="n">threadlocal_detail</span> <span class="p">{</span>

<span class="cm">/**</span>
<span class="cm"> * Base class for deleters.</span>
<span class="cm"> */</span>
<span class="n">class</span> <span class="n">DeleterBase</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">DeleterBase</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">dispose</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">TLPDestructionMode</span> <span class="n">mode</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Simple deleter class that calls delete on the passed-in pointer.</span>
<span class="cm"> */</span>
<span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">Ptr</span><span class="o">&gt;</span>
<span class="n">class</span> <span class="n">SimpleDeleter</span> <span class="o">:</span> <span class="n">public</span> <span class="n">DeleterBase</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">dispose</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">TLPDestructionMode</span> <span class="n">mode</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">delete</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="n">Ptr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Custom deleter that calls a given callable.</span>
<span class="cm"> */</span>
<span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">Ptr</span><span class="p">,</span> <span class="n">class</span> <span class="n">Deleter</span><span class="o">&gt;</span>
<span class="n">class</span> <span class="n">CustomDeleter</span> <span class="o">:</span> <span class="n">public</span> <span class="n">DeleterBase</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="n">explicit</span> <span class="n">CustomDeleter</span><span class="p">(</span><span class="n">Deleter</span> <span class="n">d</span><span class="p">)</span> <span class="o">:</span> <span class="n">deleter_</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">dispose</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">TLPDestructionMode</span> <span class="n">mode</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">deleter_</span><span class="p">(</span><span class="n">static_cast</span><span class="o">&lt;</span><span class="n">Ptr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">),</span> <span class="n">mode</span><span class="p">);</span>
  <span class="p">}</span>
 <span class="nl">private:</span>
  <span class="n">Deleter</span> <span class="n">deleter_</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/**</span>
<span class="cm"> * POD wrapper around an element (a void*) and an associated deleter.</span>
<span class="cm"> * This must be POD, as we memset() it to 0 and memcpy() it around.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ElementWrapper</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="n">dispose</span><span class="p">(</span><span class="n">TLPDestructionMode</span> <span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">DCHECK</span><span class="p">(</span><span class="n">deleter</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
      <span class="n">deleter</span><span class="o">-&gt;</span><span class="n">dispose</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">ownsDeleter</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">delete</span> <span class="n">deleter</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
      <span class="n">deleter</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
      <span class="n">ownsDeleter</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">Ptr</span><span class="o">&gt;</span>
  <span class="kt">void</span> <span class="n">set</span><span class="p">(</span><span class="n">Ptr</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">DCHECK</span><span class="p">(</span><span class="n">ptr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">DCHECK</span><span class="p">(</span><span class="n">deleter</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>We leak a single object here but that is ok.  If we used an
object directly, there is a chance that the destructor will be
called on that static object before any of the ElementWrappers
are disposed and that isn't so nice.</p></td><td class="code"><div class="highlight"><pre>      <span class="k">static</span> <span class="k">auto</span> <span class="n">d</span> <span class="o">=</span> <span class="n">new</span> <span class="n">SimpleDeleter</span><span class="o">&lt;</span><span class="n">Ptr</span><span class="o">&gt;</span><span class="p">();</span>
      <span class="n">ptr</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
      <span class="n">deleter</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
      <span class="n">ownsDeleter</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">Ptr</span><span class="p">,</span> <span class="n">class</span> <span class="n">Deleter</span><span class="o">&gt;</span>
  <span class="kt">void</span> <span class="n">set</span><span class="p">(</span><span class="n">Ptr</span> <span class="n">p</span><span class="p">,</span> <span class="n">Deleter</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">DCHECK</span><span class="p">(</span><span class="n">ptr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">DCHECK</span><span class="p">(</span><span class="n">deleter</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">ptr</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
      <span class="n">deleter</span> <span class="o">=</span> <span class="n">new</span> <span class="n">CustomDeleter</span><span class="o">&lt;</span><span class="n">Ptr</span><span class="p">,</span><span class="n">Deleter</span><span class="o">&gt;</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
      <span class="n">ownsDeleter</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">;</span>
  <span class="n">DeleterBase</span><span class="o">*</span> <span class="n">deleter</span><span class="p">;</span>
  <span class="n">bool</span> <span class="n">ownsDeleter</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Per-thread entry.  Each thread using a StaticMeta object has one.</span>
<span class="cm"> * This is written from the owning thread only (under the lock), read</span>
<span class="cm"> * from the owning thread (no lock necessary), and read from other threads</span>
<span class="cm"> * (under the lock).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ThreadEntry</span> <span class="p">{</span>
  <span class="n">ElementWrapper</span><span class="o">*</span> <span class="n">elements</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">elementsCapacity</span><span class="p">;</span>
  <span class="n">ThreadEntry</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
  <span class="n">ThreadEntry</span><span class="o">*</span> <span class="n">prev</span><span class="p">;</span>
<span class="p">};</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>Held in a singleton to track our global instances.
We have one of these per "Tag", by default one for the whole system
(Tag=void).</p>

<p>Creating and destroying ThreadLocalPtr objects, as well as thread exit
for threads that use ThreadLocalPtr objects collide on a lock inside
StaticMeta; you can specify multiple Tag types to break that lock.</p></td><td class="code"><div class="highlight"><pre><span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">Tag</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">StaticMeta</span> <span class="p">{</span>
  <span class="k">static</span> <span class="n">StaticMeta</span><span class="o">&lt;</span><span class="n">Tag</span><span class="o">&gt;&amp;</span> <span class="n">instance</span><span class="p">()</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>Leak it on exit, there's only one per process and we don't have to
worry about synchronization with exiting threads.</p></td><td class="code"><div class="highlight"><pre>    <span class="k">static</span> <span class="n">bool</span> <span class="n">constructed</span> <span class="o">=</span> <span class="p">(</span><span class="n">inst</span> <span class="o">=</span> <span class="n">new</span> <span class="n">StaticMeta</span><span class="o">&lt;</span><span class="n">Tag</span><span class="o">&gt;</span><span class="p">());</span>
    <span class="k">return</span> <span class="o">*</span><span class="n">inst</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">int</span> <span class="n">nextId_</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">freeIds_</span><span class="p">;</span>
  <span class="n">boost</span><span class="o">::</span><span class="n">mutex</span> <span class="n">lock_</span><span class="p">;</span>
  <span class="n">pthread_key_t</span> <span class="n">pthreadKey_</span><span class="p">;</span>
  <span class="n">ThreadEntry</span> <span class="n">head_</span><span class="p">;</span>

  <span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="n">ThreadEntry</span><span class="o">*</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">head_</span><span class="p">;</span>
    <span class="n">t</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">head_</span><span class="p">.</span><span class="n">prev</span><span class="p">;</span>
    <span class="n">head_</span><span class="p">.</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
    <span class="n">head_</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="nf">erase</span><span class="p">(</span><span class="n">ThreadEntry</span><span class="o">*</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>
    <span class="n">t</span><span class="o">-&gt;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">static</span> <span class="n">__thread</span> <span class="n">ThreadEntry</span> <span class="n">threadEntry_</span><span class="p">;</span>
  <span class="k">static</span> <span class="n">StaticMeta</span><span class="o">&lt;</span><span class="n">Tag</span><span class="o">&gt;*</span> <span class="n">inst</span><span class="p">;</span>

  <span class="n">StaticMeta</span><span class="p">()</span> <span class="o">:</span> <span class="n">nextId_</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">head_</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">head_</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">head_</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">pthread_key_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pthreadKey_</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">onThreadExit</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">msg</span><span class="p">;</span>
      <span class="k">switch</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">EAGAIN</span>:
          <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
          <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="s">&quot;PTHREAD_KEYS_MAX (%d) is exceeded&quot;</span><span class="p">,</span>
                   <span class="n">PTHREAD_KEYS_MAX</span><span class="p">);</span>
          <span class="n">msg</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
          <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">ENOMEM</span>:
          <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;Out-of-memory&quot;</span><span class="p">;</span>
          <span class="k">break</span><span class="p">;</span>
        <span class="nl">default:</span>
          <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;(unknown error)&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;pthread_key_create failed: &quot;</span> <span class="o">+</span> <span class="n">msg</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="o">~</span><span class="n">StaticMeta</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">LOG</span><span class="p">(</span><span class="n">FATAL</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;StaticMeta lives forever!&quot;</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">static</span> <span class="kt">void</span> <span class="n">onThreadExit</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="o">&amp;</span> <span class="n">meta</span> <span class="o">=</span> <span class="n">instance</span><span class="p">();</span>
    <span class="n">DCHECK_EQ</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">meta</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-5"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-5">&#182;</a></div><p>We wouldn't call pthread_setspecific unless we actually called get()</p></td><td class="code"><div class="highlight"><pre>    <span class="n">DCHECK_NE</span><span class="p">(</span><span class="n">threadEntry_</span><span class="p">.</span><span class="n">elementsCapacity</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">{</span>
      <span class="n">boost</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">g</span><span class="p">(</span><span class="n">meta</span><span class="p">.</span><span class="n">lock_</span><span class="p">);</span>
      <span class="n">meta</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">threadEntry_</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-6"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-6">&#182;</a></div><p>No need to hold the lock any longer; threadEntry_ is private to this
thread now that it's been removed from meta.</p></td><td class="code"><div class="highlight"><pre>    <span class="p">}</span>
    <span class="n">FOR_EACH_RANGE</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">threadEntry_</span><span class="p">.</span><span class="n">elementsCapacity</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">threadEntry_</span><span class="p">.</span><span class="n">elements</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dispose</span><span class="p">(</span><span class="n">TLPDestructionMode</span><span class="o">::</span><span class="n">THIS_THREAD</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">free</span><span class="p">(</span><span class="n">threadEntry_</span><span class="p">.</span><span class="n">elements</span><span class="p">);</span>
    <span class="n">threadEntry_</span><span class="p">.</span><span class="n">elements</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">pthread_setspecific</span><span class="p">(</span><span class="n">meta</span><span class="p">.</span><span class="n">pthreadKey_</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">static</span> <span class="kt">int</span> <span class="n">create</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
    <span class="k">auto</span> <span class="o">&amp;</span> <span class="n">meta</span> <span class="o">=</span> <span class="n">instance</span><span class="p">();</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">g</span><span class="p">(</span><span class="n">meta</span><span class="p">.</span><span class="n">lock_</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">meta</span><span class="p">.</span><span class="n">freeIds_</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">id</span> <span class="o">=</span> <span class="n">meta</span><span class="p">.</span><span class="n">freeIds_</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
      <span class="n">meta</span><span class="p">.</span><span class="n">freeIds_</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">id</span> <span class="o">=</span> <span class="n">meta</span><span class="p">.</span><span class="n">nextId_</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">id</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">static</span> <span class="kt">void</span> <span class="n">destroy</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">try</span> <span class="p">{</span>
      <span class="k">auto</span> <span class="o">&amp;</span> <span class="n">meta</span> <span class="o">=</span> <span class="n">instance</span><span class="p">();</span></pre></div></td></tr>


<tr id="section-7"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-7">&#182;</a></div><p>Elements in other threads that use this id.</p></td><td class="code"><div class="highlight"><pre>      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ElementWrapper</span><span class="o">&gt;</span> <span class="n">elements</span><span class="p">;</span>
      <span class="p">{</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">g</span><span class="p">(</span><span class="n">meta</span><span class="p">.</span><span class="n">lock_</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">ThreadEntry</span><span class="o">*</span> <span class="n">e</span> <span class="o">=</span> <span class="n">meta</span><span class="p">.</span><span class="n">head_</span><span class="p">.</span><span class="n">next</span><span class="p">;</span> <span class="n">e</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">meta</span><span class="p">.</span><span class="n">head_</span><span class="p">;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">&lt;</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">elementsCapacity</span> <span class="o">&amp;&amp;</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">elements</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">elements</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">elements</span><span class="p">[</span><span class="n">id</span><span class="p">]);</span></pre></div></td></tr>


<tr id="section-8"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-8">&#182;</a></div><p>Writing another thread's ThreadEntry from here is fine;
the only other potential reader is the owning thread --
from onThreadExit (which grabs the lock, so is properly
synchronized with us) or from get() -- but using get() on a
ThreadLocalPtr object that's being destroyed is a bug, so
undefined behavior is fair game.</p></td><td class="code"><div class="highlight"><pre>            <span class="n">e</span><span class="o">-&gt;</span><span class="n">elements</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
            <span class="n">e</span><span class="o">-&gt;</span><span class="n">elements</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">deleter</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">meta</span><span class="p">.</span><span class="n">freeIds_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
      <span class="p">}</span></pre></div></td></tr>


<tr id="section-9"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-9">&#182;</a></div><p>Delete elements outside the lock</p></td><td class="code"><div class="highlight"><pre>      <span class="n">FOR_EACH</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">elements</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">it</span><span class="o">-&gt;</span><span class="n">dispose</span><span class="p">(</span><span class="n">TLPDestructionMode</span><span class="o">::</span><span class="n">ALL_THREADS</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="n">catch</span> <span class="p">(...)</span> <span class="p">{</span> <span class="c1">// Just in case we get a lock error or something anyway...</span>
      <span class="n">LOG</span><span class="p">(</span><span class="n">WARNING</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Destructor discarding an exception that was thrown.&quot;</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">static</span> <span class="n">ElementWrapper</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">prevSize</span> <span class="o">=</span> <span class="n">threadEntry_</span><span class="p">.</span><span class="n">elementsCapacity</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">prevSize</span> <span class="o">&lt;=</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">size_t</span> <span class="n">newSize</span> <span class="o">=</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">((</span><span class="n">id</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.7</span><span class="p">);</span>
      <span class="k">auto</span> <span class="o">&amp;</span> <span class="n">meta</span> <span class="o">=</span> <span class="n">instance</span><span class="p">();</span>
      <span class="n">ElementWrapper</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-10"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-10">&#182;</a></div><p>Rely on jemalloc to zero the memory if possible -- maybe it knows
it's already zeroed and saves us some work.</p></td><td class="code"><div class="highlight"><pre>      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">usingJEMalloc</span><span class="p">()</span> <span class="o">||</span>
          <span class="n">prevSize</span> <span class="o">&lt;</span> <span class="n">jemallocMinInPlaceExpandable</span> <span class="o">||</span>
          <span class="p">(</span><span class="n">rallocm</span><span class="p">(</span>
              <span class="n">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">**&gt;</span><span class="p">(</span><span class="n">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">threadEntry_</span><span class="p">.</span><span class="n">elements</span><span class="p">)),</span>
              <span class="nb">NULL</span><span class="p">,</span> <span class="n">newSize</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ElementWrapper</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
              <span class="n">ALLOCM_NO_MOVE</span> <span class="o">|</span> <span class="n">ALLOCM_ZERO</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ALLOCM_SUCCESS</span><span class="p">))</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-11"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-11">&#182;</a></div><p>Sigh, must realloc, but we can't call realloc here, as elements is
still linked in meta, so another thread might access invalid memory
after realloc succeeds.  We'll copy by hand and update threadEntry_
under the lock.</p></td><td class="code"><div class="highlight"><pre>        <span class="k">if</span> <span class="p">((</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="n">ElementWrapper</span><span class="o">*&gt;</span><span class="p">(</span>
              <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ElementWrapper</span><span class="p">)</span> <span class="o">*</span> <span class="n">newSize</span><span class="p">)))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">memcpy</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">threadEntry_</span><span class="p">.</span><span class="n">elements</span><span class="p">,</span>
                 <span class="k">sizeof</span><span class="p">(</span><span class="n">ElementWrapper</span><span class="p">)</span> <span class="o">*</span> <span class="n">prevSize</span><span class="p">);</span>
          <span class="n">memset</span><span class="p">(</span><span class="n">ptr</span> <span class="o">+</span> <span class="n">prevSize</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                 <span class="p">(</span><span class="n">newSize</span> <span class="o">-</span> <span class="n">prevSize</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ElementWrapper</span><span class="p">));</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="n">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">bad_alloc</span><span class="p">();</span>
        <span class="p">}</span>
      <span class="p">}</span></pre></div></td></tr>


<tr id="section-12"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-12">&#182;</a></div><p>Success, update the entry</p></td><td class="code"><div class="highlight"><pre>      <span class="p">{</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">g</span><span class="p">(</span><span class="n">meta</span><span class="p">.</span><span class="n">lock_</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">prevSize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">meta</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="o">&amp;</span><span class="n">threadEntry_</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">using</span> <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">;</span>
          <span class="n">swap</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">threadEntry_</span><span class="p">.</span><span class="n">elements</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">threadEntry_</span><span class="p">.</span><span class="n">elementsCapacity</span> <span class="o">=</span> <span class="n">newSize</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">prevSize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pthread_setspecific</span><span class="p">(</span><span class="n">meta</span><span class="p">.</span><span class="n">pthreadKey_</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">meta</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">threadEntry_</span><span class="p">.</span><span class="n">elements</span><span class="p">[</span><span class="n">id</span><span class="p">];</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">Tag</span><span class="o">&gt;</span> <span class="n">__thread</span> <span class="n">ThreadEntry</span> <span class="n">StaticMeta</span><span class="o">&lt;</span><span class="n">Tag</span><span class="o">&gt;::</span><span class="n">threadEntry_</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">Tag</span><span class="o">&gt;</span> <span class="n">StaticMeta</span><span class="o">&lt;</span><span class="n">Tag</span><span class="o">&gt;*</span> <span class="n">StaticMeta</span><span class="o">&lt;</span><span class="n">Tag</span><span class="o">&gt;::</span><span class="n">inst</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>

<span class="p">}</span>  <span class="c1">// namespace threadlocal_detail</span>
<span class="p">}</span>  <span class="c1">// namespace folly</span>

<span class="cp">#endif </span><span class="cm">/* FOLLY_DETAIL_THREADLOCALDETAIL_H_ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/folly",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
