<!DOCTYPE html>
<html><head><title>joekychen/folly » folly › detail › DiscriminatedPtrDetail.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>DiscriminatedPtrDetail.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2012 Facebook, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="cm"> * you may not use this file except in compliance with the License.</span>
<span class="cm"> * You may obtain a copy of the License at</span>
<span class="cm"> *</span>
<span class="cm"> *   http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="cm"> *</span>
<span class="cm"> * Unless required by applicable law or agreed to in writing, software</span>
<span class="cm"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="cm"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="cm"> * See the License for the specific language governing permissions and</span>
<span class="cm"> * limitations under the License.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef FOLLY_DETAIL_DISCRIMINATEDPTRDETAIL_H_</span>
<span class="cp">#define FOLLY_DETAIL_DISCRIMINATEDPTRDETAIL_H_</span>

<span class="cp">#include &lt;type_traits&gt;</span>

<span class="n">namespace</span> <span class="n">folly</span> <span class="p">{</span>
<span class="n">namespace</span> <span class="n">dptr_detail</span> <span class="p">{</span>

<span class="cm">/**</span>
<span class="cm"> * Given a target type and a list of types, return the 1-based index of the</span>
<span class="cm"> * type in the list of types.  Fail to compile if the target type doesn&#39;t</span>
<span class="cm"> * appear in the list.</span>
<span class="cm"> *</span>
<span class="cm"> * GetIndex&lt;int, void, char, int&gt;::value == 3</span>
<span class="cm"> * GetIndex&lt;int, void, char&gt;::value -&gt; fails to compile</span>
<span class="cm"> */</span>
<span class="n">template</span> <span class="o">&lt;</span><span class="kr">typename</span><span class="p">...</span> <span class="n">Types</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">GetTypeIndex</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>When recursing, we never reach the 0- or 1- template argument base case
unless the target type is not in the list.  If the target type is in the
list, we stop recursing when it is at the head of the remaining type
list via the GetTypeIndex<T, T, Types...> partial specialization.</p></td><td class="code"><div class="highlight"><pre><span class="n">template</span> <span class="o">&lt;</span><span class="kr">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kr">typename</span><span class="p">...</span> <span class="n">Types</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">GetTypeIndex</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">size_t</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="kr">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kr">typename</span> <span class="n">U</span><span class="p">,</span> <span class="kr">typename</span><span class="p">...</span> <span class="n">Types</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">GetTypeIndex</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">size_t</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">GetTypeIndex</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Types</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>
<span class="p">};</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>Generalize std::is_same for variable number of type arguments</p></td><td class="code"><div class="highlight"><pre><span class="n">template</span> <span class="o">&lt;</span><span class="kr">typename</span><span class="p">...</span> <span class="n">Types</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">IsSameType</span><span class="p">;</span>

<span class="n">template</span> <span class="o">&lt;&gt;</span>
<span class="k">struct</span> <span class="n">IsSameType</span><span class="o">&lt;&gt;</span> <span class="p">{</span>
  <span class="k">static</span> <span class="k">const</span> <span class="n">bool</span> <span class="n">value</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="kr">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">IsSameType</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">static</span> <span class="k">const</span> <span class="n">bool</span> <span class="n">value</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="kr">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kr">typename</span> <span class="n">U</span><span class="p">,</span> <span class="kr">typename</span><span class="p">...</span> <span class="n">Types</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">IsSameType</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">static</span> <span class="k">const</span> <span class="n">bool</span> <span class="n">value</span> <span class="o">=</span>
    <span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">U</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&amp;&amp;</span> <span class="n">IsSameType</span><span class="o">&lt;</span><span class="n">U</span><span class="p">,</span> <span class="n">Types</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>
<span class="p">};</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>Define type as the type of all T in (non-empty) Types..., asserting that
all types in Types... are the same.</p></td><td class="code"><div class="highlight"><pre><span class="n">template</span> <span class="o">&lt;</span><span class="kr">typename</span><span class="p">...</span> <span class="n">Types</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">SameType</span><span class="p">;</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="kr">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kr">typename</span><span class="p">...</span> <span class="n">Types</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">SameType</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">typedef</span> <span class="n">T</span> <span class="n">type</span><span class="p">;</span>
  <span class="n">static_assert</span><span class="p">(</span><span class="n">IsSameType</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Types</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
                <span class="s">&quot;Not all types in pack are the same&quot;</span><span class="p">);</span>
<span class="p">};</span></pre></div></td></tr>


<tr id="section-5"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-5">&#182;</a></div><p>Determine the result type of applying a visitor of type V on a pointer
to type T.</p></td><td class="code"><div class="highlight"><pre><span class="n">template</span> <span class="o">&lt;</span><span class="kr">typename</span> <span class="n">V</span><span class="p">,</span> <span class="kr">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">VisitorResult1</span> <span class="p">{</span>
  <span class="k">typedef</span> <span class="kr">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">result_of</span><span class="o">&lt;</span><span class="n">V</span> <span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">type</span><span class="p">;</span>
<span class="p">};</span></pre></div></td></tr>


<tr id="section-6"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-6">&#182;</a></div><p>Determine the result type of applying a visitor of type V on a const pointer
to type T.</p></td><td class="code"><div class="highlight"><pre><span class="n">template</span> <span class="o">&lt;</span><span class="kr">typename</span> <span class="n">V</span><span class="p">,</span> <span class="kr">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">ConstVisitorResult1</span> <span class="p">{</span>
  <span class="k">typedef</span> <span class="kr">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">result_of</span><span class="o">&lt;</span><span class="n">V</span> <span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">*</span><span class="p">)</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">type</span><span class="p">;</span>
<span class="p">};</span></pre></div></td></tr>


<tr id="section-7"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-7">&#182;</a></div><p>Determine the result type of applying a visitor of type V on pointers of
all types in Types..., asserting that the type is the same for all types
in Types...</p></td><td class="code"><div class="highlight"><pre><span class="n">template</span> <span class="o">&lt;</span><span class="kr">typename</span> <span class="n">V</span><span class="p">,</span> <span class="kr">typename</span><span class="p">...</span> <span class="n">Types</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">VisitorResult</span> <span class="p">{</span>
  <span class="k">typedef</span> <span class="kr">typename</span> <span class="n">SameType</span><span class="o">&lt;</span>
    <span class="kr">typename</span> <span class="n">VisitorResult1</span><span class="o">&lt;</span><span class="n">V</span><span class="p">,</span><span class="n">Types</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">type</span><span class="p">;</span>
<span class="p">};</span></pre></div></td></tr>


<tr id="section-8"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-8">&#182;</a></div><p>Determine the result type of applying a visitor of type V on const pointers
of all types in Types..., asserting that the type is the same for all types
in Types...</p></td><td class="code"><div class="highlight"><pre><span class="n">template</span> <span class="o">&lt;</span><span class="kr">typename</span> <span class="n">V</span><span class="p">,</span> <span class="kr">typename</span><span class="p">...</span> <span class="n">Types</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">ConstVisitorResult</span> <span class="p">{</span>
  <span class="k">typedef</span> <span class="kr">typename</span> <span class="n">SameType</span><span class="o">&lt;</span>
    <span class="kr">typename</span> <span class="n">ConstVisitorResult1</span><span class="o">&lt;</span><span class="n">V</span><span class="p">,</span><span class="n">Types</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">type</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="kr">typename</span> <span class="n">V</span><span class="p">,</span> <span class="kr">typename</span> <span class="n">R</span><span class="p">,</span> <span class="kr">typename</span><span class="p">...</span> <span class="n">Types</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">ApplyVisitor1</span><span class="p">;</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="kr">typename</span> <span class="n">V</span><span class="p">,</span> <span class="kr">typename</span> <span class="n">R</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">ApplyVisitor1</span><span class="o">&lt;</span><span class="n">V</span><span class="p">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">R</span> <span class="n">operator</span><span class="p">()(</span><span class="kt">size_t</span> <span class="n">index</span><span class="p">,</span> <span class="n">V</span><span class="o">&amp;&amp;</span> <span class="n">visitor</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">CHECK</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>  <span class="c1">// NOTREACHED</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="kr">typename</span> <span class="n">V</span><span class="p">,</span> <span class="kr">typename</span> <span class="n">R</span><span class="p">,</span> <span class="kr">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kr">typename</span><span class="p">...</span> <span class="n">Types</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">ApplyVisitor1</span><span class="o">&lt;</span><span class="n">V</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">R</span> <span class="n">operator</span><span class="p">()(</span><span class="kt">size_t</span> <span class="n">index</span><span class="p">,</span> <span class="n">V</span><span class="o">&amp;&amp;</span> <span class="n">visitor</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="n">visitor</span><span class="p">(</span><span class="n">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">))</span> <span class="o">:</span>
            <span class="n">ApplyVisitor1</span><span class="o">&lt;</span><span class="n">V</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">()(</span>
              <span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span><span class="p">(</span><span class="n">visitor</span><span class="p">),</span> <span class="n">ptr</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="kr">typename</span> <span class="n">V</span><span class="p">,</span> <span class="kr">typename</span> <span class="n">R</span><span class="p">,</span> <span class="kr">typename</span><span class="p">...</span> <span class="n">Types</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">ApplyConstVisitor1</span><span class="p">;</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="kr">typename</span> <span class="n">V</span><span class="p">,</span> <span class="kr">typename</span> <span class="n">R</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">ApplyConstVisitor1</span><span class="o">&lt;</span><span class="n">V</span><span class="p">,</span> <span class="n">R</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">R</span> <span class="n">operator</span><span class="p">()(</span><span class="kt">size_t</span> <span class="n">index</span><span class="p">,</span> <span class="n">V</span><span class="o">&amp;&amp;</span> <span class="n">visitor</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">CHECK</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>  <span class="c1">// NOTREACHED</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="kr">typename</span> <span class="n">V</span><span class="p">,</span> <span class="kr">typename</span> <span class="n">R</span><span class="p">,</span> <span class="kr">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kr">typename</span><span class="p">...</span> <span class="n">Types</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">ApplyConstVisitor1</span><span class="o">&lt;</span><span class="n">V</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">R</span> <span class="n">operator</span><span class="p">()(</span><span class="kt">size_t</span> <span class="n">index</span><span class="p">,</span> <span class="n">V</span><span class="o">&amp;&amp;</span> <span class="n">visitor</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">?</span> <span class="n">visitor</span><span class="p">(</span><span class="n">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">))</span> <span class="o">:</span>
            <span class="n">ApplyConstVisitor1</span><span class="o">&lt;</span><span class="n">V</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span><span class="p">()(</span>
              <span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span><span class="p">(</span><span class="n">visitor</span><span class="p">),</span> <span class="n">ptr</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="kr">typename</span> <span class="n">V</span><span class="p">,</span> <span class="kr">typename</span><span class="p">...</span> <span class="n">Types</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">ApplyVisitor</span>
  <span class="o">:</span> <span class="n">ApplyVisitor1</span><span class="o">&lt;</span>
      <span class="n">V</span><span class="p">,</span> <span class="kr">typename</span> <span class="n">VisitorResult</span><span class="o">&lt;</span><span class="n">V</span><span class="p">,</span> <span class="n">Types</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">,</span> <span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="p">};</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="kr">typename</span> <span class="n">V</span><span class="p">,</span> <span class="kr">typename</span><span class="p">...</span> <span class="n">Types</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">ApplyConstVisitor</span>
  <span class="o">:</span> <span class="n">ApplyConstVisitor1</span><span class="o">&lt;</span>
      <span class="n">V</span><span class="p">,</span> <span class="kr">typename</span> <span class="n">ConstVisitorResult</span><span class="o">&lt;</span><span class="n">V</span><span class="p">,</span> <span class="n">Types</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">,</span> <span class="n">Types</span><span class="p">...</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="p">};</span>

<span class="p">}</span>  <span class="c1">// namespace dptr_detail</span>
<span class="p">}</span>  <span class="c1">// namespace folly</span>

<span class="cp">#endif </span><span class="cm">/* FOLLY_DETAIL_DISCRIMINATEDPTRDETAIL_H_ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/folly",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
