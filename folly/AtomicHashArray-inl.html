<!DOCTYPE html>
<html><head><title>joekychen/folly » folly › AtomicHashArray-inl.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>AtomicHashArray-inl.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2012 Facebook, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="cm"> * you may not use this file except in compliance with the License.</span>
<span class="cm"> * You may obtain a copy of the License at</span>
<span class="cm"> *</span>
<span class="cm"> *   http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="cm"> *</span>
<span class="cm"> * Unless required by applicable law or agreed to in writing, software</span>
<span class="cm"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="cm"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="cm"> * See the License for the specific language governing permissions and</span>
<span class="cm"> * limitations under the License.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef FOLLY_ATOMICHASHARRAY_H_</span>
<span class="cp">#error &quot;This should only be included by AtomicHashArray.h&quot;</span>
<span class="cp">#endif</span>

<span class="cp">#include &quot;folly/Bits.h&quot;</span>
<span class="cp">#include &quot;folly/detail/AtomicHashUtils.h&quot;</span>

<span class="n">namespace</span> <span class="n">folly</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>AtomicHashArray private constructor --</p></td><td class="code"><div class="highlight"><pre><span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">KeyT</span><span class="p">,</span> <span class="n">class</span> <span class="n">ValueT</span><span class="p">,</span> <span class="n">class</span> <span class="n">HashFcn</span><span class="o">&gt;</span>
<span class="n">AtomicHashArray</span><span class="o">&lt;</span><span class="n">KeyT</span><span class="p">,</span> <span class="n">ValueT</span><span class="p">,</span> <span class="n">HashFcn</span><span class="o">&gt;::</span>
<span class="n">AtomicHashArray</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">capacity</span><span class="p">,</span> <span class="n">KeyT</span> <span class="n">emptyKey</span><span class="p">,</span> <span class="n">KeyT</span> <span class="n">lockedKey</span><span class="p">,</span>
                <span class="n">KeyT</span> <span class="n">erasedKey</span><span class="p">,</span> <span class="kt">double</span> <span class="n">maxLoadFactor</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">cacheSize</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">capacity_</span><span class="p">(</span><span class="n">capacity</span><span class="p">),</span> <span class="n">maxEntries_</span><span class="p">(</span><span class="kt">size_t</span><span class="p">(</span><span class="n">maxLoadFactor</span> <span class="o">*</span> <span class="n">capacity_</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)),</span>
      <span class="n">kEmptyKey_</span><span class="p">(</span><span class="n">emptyKey</span><span class="p">),</span> <span class="n">kLockedKey_</span><span class="p">(</span><span class="n">lockedKey</span><span class="p">),</span> <span class="n">kErasedKey_</span><span class="p">(</span><span class="n">erasedKey</span><span class="p">),</span>
      <span class="n">kAnchorMask_</span><span class="p">(</span><span class="n">nextPowTwo</span><span class="p">(</span><span class="n">capacity_</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">numEntries_</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cacheSize</span><span class="p">),</span>
      <span class="n">numPendingEntries_</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cacheSize</span><span class="p">),</span> <span class="n">isFull_</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">numErases_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * findInternal --</span>
<span class="cm"> *</span>
<span class="cm"> *   Sets ret.second to value found and ret.index to index</span>
<span class="cm"> *   of key and returns true, or if key does not exist returns false and</span>
<span class="cm"> *   ret.index is set to capacity_.</span>
<span class="cm"> */</span>
<span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">KeyT</span><span class="p">,</span> <span class="n">class</span> <span class="n">ValueT</span><span class="p">,</span> <span class="n">class</span> <span class="n">HashFcn</span><span class="o">&gt;</span>
<span class="kr">typename</span> <span class="n">AtomicHashArray</span><span class="o">&lt;</span><span class="n">KeyT</span><span class="p">,</span> <span class="n">ValueT</span><span class="p">,</span> <span class="n">HashFcn</span><span class="o">&gt;::</span><span class="n">SimpleRetT</span>
<span class="n">AtomicHashArray</span><span class="o">&lt;</span><span class="n">KeyT</span><span class="p">,</span> <span class="n">ValueT</span><span class="p">,</span> <span class="n">HashFcn</span><span class="o">&gt;::</span>
<span class="n">findInternal</span><span class="p">(</span><span class="k">const</span> <span class="n">KeyT</span> <span class="n">key_in</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">DCHECK_NE</span><span class="p">(</span><span class="n">key_in</span><span class="p">,</span> <span class="n">kEmptyKey_</span><span class="p">);</span>
  <span class="n">DCHECK_NE</span><span class="p">(</span><span class="n">key_in</span><span class="p">,</span> <span class="n">kLockedKey_</span><span class="p">);</span>
  <span class="n">DCHECK_NE</span><span class="p">(</span><span class="n">key_in</span><span class="p">,</span> <span class="n">kErasedKey_</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">keyToAnchorIdx</span><span class="p">(</span><span class="n">key_in</span><span class="p">),</span> <span class="n">numProbes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
       <span class="p">;</span>
       <span class="n">idx</span> <span class="o">=</span> <span class="n">probeNext</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">numProbes</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">KeyT</span> <span class="n">key</span> <span class="o">=</span> <span class="n">acquireLoadKey</span><span class="p">(</span><span class="n">cells_</span><span class="p">[</span><span class="n">idx</span><span class="p">]);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">LIKELY</span><span class="p">(</span><span class="n">key</span> <span class="o">==</span> <span class="n">key_in</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">SimpleRetT</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="n">key</span> <span class="o">==</span> <span class="n">kEmptyKey_</span><span class="p">))</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>if we hit an empty element, this key does not exist</p></td><td class="code"><div class="highlight"><pre>      <span class="k">return</span> <span class="n">SimpleRetT</span><span class="p">(</span><span class="n">capacity_</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="o">++</span><span class="n">numProbes</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="n">numProbes</span> <span class="o">&gt;=</span> <span class="n">capacity_</span><span class="p">))</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>probed every cell...fail</p></td><td class="code"><div class="highlight"><pre>      <span class="k">return</span> <span class="n">SimpleRetT</span><span class="p">(</span><span class="n">capacity_</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * insertInternal --</span>
<span class="cm"> *</span>
<span class="cm"> *   Returns false on failure due to key collision or full.</span>
<span class="cm"> *   Also sets ret.index to the index of the key.  If the map is full, sets</span>
<span class="cm"> *   ret.index = capacity_.  Also sets ret.second to cell value, thus if insert</span>
<span class="cm"> *   successful this will be what we just inserted, if there is a key collision</span>
<span class="cm"> *   this will be the previously inserted value, and if the map is full it is</span>
<span class="cm"> *   default.</span>
<span class="cm"> */</span>
<span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">KeyT</span><span class="p">,</span> <span class="n">class</span> <span class="n">ValueT</span><span class="p">,</span> <span class="n">class</span> <span class="n">HashFcn</span><span class="o">&gt;</span>
<span class="kr">typename</span> <span class="n">AtomicHashArray</span><span class="o">&lt;</span><span class="n">KeyT</span><span class="p">,</span> <span class="n">ValueT</span><span class="p">,</span> <span class="n">HashFcn</span><span class="o">&gt;::</span><span class="n">SimpleRetT</span>
<span class="n">AtomicHashArray</span><span class="o">&lt;</span><span class="n">KeyT</span><span class="p">,</span> <span class="n">ValueT</span><span class="p">,</span> <span class="n">HashFcn</span><span class="o">&gt;::</span>
<span class="n">insertInternal</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">record</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="kt">short</span> <span class="n">NO_NEW_INSERTS</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">short</span> <span class="n">NO_PENDING_INSERTS</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">KeyT</span> <span class="n">key_in</span> <span class="o">=</span> <span class="n">record</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
  <span class="n">CHECK_NE</span><span class="p">(</span><span class="n">key_in</span><span class="p">,</span> <span class="n">kEmptyKey_</span><span class="p">);</span>
  <span class="n">CHECK_NE</span><span class="p">(</span><span class="n">key_in</span><span class="p">,</span> <span class="n">kLockedKey_</span><span class="p">);</span>
  <span class="n">CHECK_NE</span><span class="p">(</span><span class="n">key_in</span><span class="p">,</span> <span class="n">kErasedKey_</span><span class="p">);</span>

  <span class="kt">size_t</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">keyToAnchorIdx</span><span class="p">(</span><span class="n">key_in</span><span class="p">);</span>
  <span class="kt">size_t</span> <span class="n">numProbes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="n">DCHECK_LT</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">capacity_</span><span class="p">);</span>
    <span class="n">value_type</span><span class="o">*</span> <span class="n">cell</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cells_</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">relaxedLoadKey</span><span class="p">(</span><span class="o">*</span><span class="n">cell</span><span class="p">)</span> <span class="o">==</span> <span class="n">kEmptyKey_</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-5"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-5">&#182;</a></div><p>NOTE: isFull_ is set based on numEntries<em>.readFast(), so it's
possible to insert more than maxEntries</em> entries. However, it's not
possible to insert past capacity_.</p></td><td class="code"><div class="highlight"><pre>      <span class="o">++</span><span class="n">numPendingEntries_</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">isFull_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">))</span> <span class="p">{</span>
        <span class="o">--</span><span class="n">numPendingEntries_</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-6"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-6">&#182;</a></div><p>Before deciding whether this insert succeeded, this thread needs to
wait until no other thread can add a new entry.</p></td><td class="code"><div class="highlight"><pre></pre></div></td></tr>


<tr id="section-7"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-7">&#182;</a></div><p>Correctness assumes isFull_ is true at this point. If
another thread now does ++numPendingEntries<em>, we expect it
to pass the isFull</em>.load() test above. (It shouldn't insert
a new entry.)</p></td><td class="code"><div class="highlight"><pre>        <span class="n">FOLLY_SPIN_WAIT</span><span class="p">(</span>
          <span class="n">isFull_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">)</span> <span class="o">!=</span> <span class="n">NO_PENDING_INSERTS</span>
            <span class="o">&amp;&amp;</span> <span class="n">numPendingEntries_</span><span class="p">.</span><span class="n">readFull</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span>
        <span class="p">);</span>
        <span class="n">isFull_</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">NO_PENDING_INSERTS</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">relaxedLoadKey</span><span class="p">(</span><span class="o">*</span><span class="n">cell</span><span class="p">)</span> <span class="o">==</span> <span class="n">kEmptyKey_</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-8"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-8">&#182;</a></div><p>Don't insert past max load factor</p></td><td class="code"><div class="highlight"><pre>          <span class="k">return</span> <span class="n">SimpleRetT</span><span class="p">(</span><span class="n">capacity_</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-9"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-9">&#182;</a></div><p>An unallocated cell. Try once to lock it. If we succeed, insert here.
If we fail, fall through to comparison below; maybe the insert that
just beat us was for this very key....</p></td><td class="code"><div class="highlight"><pre>        <span class="k">if</span> <span class="p">(</span><span class="n">tryLockCell</span><span class="p">(</span><span class="n">cell</span><span class="p">))</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-10"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-10">&#182;</a></div><p>Write the value - done before unlocking</p></td><td class="code"><div class="highlight"><pre>          <span class="n">try</span> <span class="p">{</span>
            <span class="n">DCHECK</span><span class="p">(</span><span class="n">relaxedLoadKey</span><span class="p">(</span><span class="o">*</span><span class="n">cell</span><span class="p">)</span> <span class="o">==</span> <span class="n">kLockedKey_</span><span class="p">);</span>
            <span class="cm">/*</span>
<span class="cm">             * This happens using the copy constructor because we won&#39;t have</span>
<span class="cm">             * constructed a lhs to use an assignment operator on when</span>
<span class="cm">             * values are being set.</span>
<span class="cm">             */</span>
            <span class="n">new</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">cell</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">)</span> <span class="n">ValueT</span><span class="p">(</span><span class="n">record</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
            <span class="n">unlockCell</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">key_in</span><span class="p">);</span> <span class="c1">// Sets the new key</span>
          <span class="p">}</span> <span class="n">catch</span> <span class="p">(...)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-11"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-11">&#182;</a></div><p>Transition back to empty key---requires handling
locked->empty below.</p></td><td class="code"><div class="highlight"><pre>            <span class="n">unlockCell</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">kEmptyKey_</span><span class="p">);</span>
            <span class="o">--</span><span class="n">numPendingEntries_</span><span class="p">;</span>
            <span class="n">throw</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="n">DCHECK</span><span class="p">(</span><span class="n">relaxedLoadKey</span><span class="p">(</span><span class="o">*</span><span class="n">cell</span><span class="p">)</span> <span class="o">==</span> <span class="n">key_in</span><span class="p">);</span>
          <span class="o">--</span><span class="n">numPendingEntries_</span><span class="p">;</span>
          <span class="o">++</span><span class="n">numEntries_</span><span class="p">;</span>  <span class="c1">// This is a thread cached atomic increment :)</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">numEntries_</span><span class="p">.</span><span class="n">readFast</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">maxEntries_</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">isFull_</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">NO_NEW_INSERTS</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="n">SimpleRetT</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="o">--</span><span class="n">numPendingEntries_</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">DCHECK</span><span class="p">(</span><span class="n">relaxedLoadKey</span><span class="p">(</span><span class="o">*</span><span class="n">cell</span><span class="p">)</span> <span class="o">!=</span> <span class="n">kEmptyKey_</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">kLockedKey_</span> <span class="o">==</span> <span class="n">acquireLoadKey</span><span class="p">(</span><span class="o">*</span><span class="n">cell</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">FOLLY_SPIN_WAIT</span><span class="p">(</span>
        <span class="n">kLockedKey_</span> <span class="o">==</span> <span class="n">acquireLoadKey</span><span class="p">(</span><span class="o">*</span><span class="n">cell</span><span class="p">)</span>
      <span class="p">);</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">KeyT</span> <span class="n">thisKey</span> <span class="o">=</span> <span class="n">acquireLoadKey</span><span class="p">(</span><span class="o">*</span><span class="n">cell</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">thisKey</span> <span class="o">==</span> <span class="n">key_in</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-12"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-12">&#182;</a></div><p>Found an existing entry for our key, but we don't overwrite the
previous value.</p></td><td class="code"><div class="highlight"><pre>      <span class="k">return</span> <span class="n">SimpleRetT</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">thisKey</span> <span class="o">==</span> <span class="n">kEmptyKey_</span> <span class="o">||</span> <span class="n">thisKey</span> <span class="o">==</span> <span class="n">kLockedKey_</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-13"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-13">&#182;</a></div><p>We need to try again (i.e., don't increment numProbes or
advance idx): this case can happen if the constructor for
ValueT threw for this very cell (the rethrow block above).</p></td><td class="code"><div class="highlight"><pre>      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="o">++</span><span class="n">numProbes</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="n">numProbes</span> <span class="o">&gt;=</span> <span class="n">capacity_</span><span class="p">))</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-14"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-14">&#182;</a></div><p>probed every cell...fail</p></td><td class="code"><div class="highlight"><pre>      <span class="k">return</span> <span class="n">SimpleRetT</span><span class="p">(</span><span class="n">capacity_</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">idx</span> <span class="o">=</span> <span class="n">probeNext</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">numProbes</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * erase --</span>
<span class="cm"> *</span>
<span class="cm"> *   This will attempt to erase the given key key_in if the key is found. It</span>
<span class="cm"> *   returns 1 iff the key was located and marked as erased, and 0 otherwise.</span>
<span class="cm"> *</span>
<span class="cm"> *   Memory is not freed or reclaimed by erase, i.e. the cell containing the</span>
<span class="cm"> *   erased key will never be reused. If there&#39;s an associated value, we won&#39;t</span>
<span class="cm"> *   touch it either.</span>
<span class="cm"> */</span>
<span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">KeyT</span><span class="p">,</span> <span class="n">class</span> <span class="n">ValueT</span><span class="p">,</span> <span class="n">class</span> <span class="n">HashFcn</span><span class="o">&gt;</span>
<span class="kt">size_t</span> <span class="n">AtomicHashArray</span><span class="o">&lt;</span><span class="n">KeyT</span><span class="p">,</span> <span class="n">ValueT</span><span class="p">,</span> <span class="n">HashFcn</span><span class="o">&gt;::</span>
<span class="n">erase</span><span class="p">(</span><span class="n">KeyT</span> <span class="n">key_in</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">CHECK_NE</span><span class="p">(</span><span class="n">key_in</span><span class="p">,</span> <span class="n">kEmptyKey_</span><span class="p">);</span>
  <span class="n">CHECK_NE</span><span class="p">(</span><span class="n">key_in</span><span class="p">,</span> <span class="n">kLockedKey_</span><span class="p">);</span>
  <span class="n">CHECK_NE</span><span class="p">(</span><span class="n">key_in</span><span class="p">,</span> <span class="n">kErasedKey_</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">keyToAnchorIdx</span><span class="p">(</span><span class="n">key_in</span><span class="p">),</span> <span class="n">numProbes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
       <span class="p">;</span>
       <span class="n">idx</span> <span class="o">=</span> <span class="n">probeNext</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">numProbes</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">DCHECK_LT</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">capacity_</span><span class="p">);</span>
    <span class="n">value_type</span><span class="o">*</span> <span class="n">cell</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cells_</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
    <span class="n">KeyT</span> <span class="n">currentKey</span> <span class="o">=</span> <span class="n">acquireLoadKey</span><span class="p">(</span><span class="o">*</span><span class="n">cell</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">currentKey</span> <span class="o">==</span> <span class="n">kEmptyKey_</span> <span class="o">||</span> <span class="n">currentKey</span> <span class="o">==</span> <span class="n">kLockedKey_</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-15"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-15">&#182;</a></div><p>If we hit an empty (or locked) element, this key does not exist. This
is similar to how it's handled in find().</p></td><td class="code"><div class="highlight"><pre>      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">key_in</span> <span class="o">==</span> <span class="n">currentKey</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-16"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-16">&#182;</a></div><p>Found an existing entry for our key, attempt to mark it erased.
Some other thread may have erased our key, but this is ok.</p></td><td class="code"><div class="highlight"><pre>      <span class="n">KeyT</span> <span class="n">expect</span> <span class="o">=</span> <span class="n">key_in</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">cellKeyPtr</span><span class="p">(</span><span class="o">*</span><span class="n">cell</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">compare_exchange_strong</span><span class="p">(</span><span class="n">expect</span><span class="p">,</span> <span class="n">kErasedKey_</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">numErases_</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-17"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-17">&#182;</a></div><p>Even if there's a value in the cell, we won't delete (or even
default construct) it because some other thread may be accessing it.
Locking it meanwhile won't work either since another thread may be
holding a pointer to it.</p></td><td class="code"><div class="highlight"><pre></pre></div></td></tr>


<tr id="section-18"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-18">&#182;</a></div><p>We found the key and successfully erased it.</p></td><td class="code"><div class="highlight"><pre>        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
      <span class="p">}</span></pre></div></td></tr>


<tr id="section-19"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-19">&#182;</a></div><p>If another thread succeeds in erasing our key, we'll stop our search.</p></td><td class="code"><div class="highlight"><pre>      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">++</span><span class="n">numProbes</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="n">numProbes</span> <span class="o">&gt;=</span> <span class="n">capacity_</span><span class="p">))</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-20"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-20">&#182;</a></div><p>probed every cell...fail</p></td><td class="code"><div class="highlight"><pre>      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">KeyT</span><span class="p">,</span> <span class="n">class</span> <span class="n">ValueT</span><span class="p">,</span> <span class="n">class</span> <span class="n">HashFcn</span><span class="o">&gt;</span>
<span class="k">const</span> <span class="kr">typename</span> <span class="n">AtomicHashArray</span><span class="o">&lt;</span><span class="n">KeyT</span><span class="p">,</span> <span class="n">ValueT</span><span class="p">,</span> <span class="n">HashFcn</span><span class="o">&gt;::</span><span class="n">Config</span>
<span class="n">AtomicHashArray</span><span class="o">&lt;</span><span class="n">KeyT</span><span class="p">,</span> <span class="n">ValueT</span><span class="p">,</span> <span class="n">HashFcn</span><span class="o">&gt;::</span><span class="n">defaultConfig</span><span class="p">;</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">KeyT</span><span class="p">,</span> <span class="n">class</span> <span class="n">ValueT</span><span class="p">,</span> <span class="n">class</span> <span class="n">HashFcn</span><span class="o">&gt;</span>
<span class="kr">typename</span> <span class="n">AtomicHashArray</span><span class="o">&lt;</span><span class="n">KeyT</span><span class="p">,</span> <span class="n">ValueT</span><span class="p">,</span> <span class="n">HashFcn</span><span class="o">&gt;::</span><span class="n">SmartPtr</span>
<span class="n">AtomicHashArray</span><span class="o">&lt;</span><span class="n">KeyT</span><span class="p">,</span> <span class="n">ValueT</span><span class="p">,</span> <span class="n">HashFcn</span><span class="o">&gt;::</span>
<span class="n">create</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">maxSize</span><span class="p">,</span> <span class="k">const</span> <span class="n">Config</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">CHECK_LE</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">maxLoadFactor</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
  <span class="n">CHECK_GT</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">maxLoadFactor</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
  <span class="n">CHECK_NE</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">emptyKey</span><span class="p">,</span> <span class="n">c</span><span class="p">.</span><span class="n">lockedKey</span><span class="p">);</span>
  <span class="kt">size_t</span> <span class="n">capacity</span> <span class="o">=</span> <span class="kt">size_t</span><span class="p">(</span><span class="n">maxSize</span> <span class="o">/</span> <span class="n">c</span><span class="p">.</span><span class="n">maxLoadFactor</span><span class="p">);</span>
  <span class="kt">size_t</span> <span class="n">sz</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">AtomicHashArray</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value_type</span><span class="p">)</span> <span class="o">*</span> <span class="n">capacity</span><span class="p">;</span>

  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">,</span> <span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">mem</span><span class="p">(</span><span class="n">malloc</span><span class="p">(</span><span class="n">sz</span><span class="p">),</span> <span class="n">free</span><span class="p">);</span>
  <span class="n">new</span><span class="p">(</span><span class="n">mem</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="n">AtomicHashArray</span><span class="p">(</span><span class="n">capacity</span><span class="p">,</span> <span class="n">c</span><span class="p">.</span><span class="n">emptyKey</span><span class="p">,</span> <span class="n">c</span><span class="p">.</span><span class="n">lockedKey</span><span class="p">,</span> <span class="n">c</span><span class="p">.</span><span class="n">erasedKey</span><span class="p">,</span>
                                 <span class="n">c</span><span class="p">.</span><span class="n">maxLoadFactor</span><span class="p">,</span> <span class="n">c</span><span class="p">.</span><span class="n">entryCountThreadCacheSize</span><span class="p">);</span>
  <span class="n">SmartPtr</span> <span class="n">map</span><span class="p">(</span><span class="n">static_cast</span><span class="o">&lt;</span><span class="n">AtomicHashArray</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">mem</span><span class="p">.</span><span class="n">release</span><span class="p">()));</span>

  <span class="cm">/*</span>
<span class="cm">   * Mark all cells as empty.</span>
<span class="cm">   *</span>
<span class="cm">   * Note: we&#39;re bending the rules a little here accessing the key</span>
<span class="cm">   * element in our cells even though the cell object has not been</span>
<span class="cm">   * constructed, and casting them to atomic objects (see cellKeyPtr).</span>
<span class="cm">   * (Also, in fact we never actually invoke the value_type</span>
<span class="cm">   * constructor.)  This is in order to avoid needing to default</span>
<span class="cm">   * construct a bunch of value_type when we first start up: if you</span>
<span class="cm">   * have an expensive default constructor for the value type this can</span>
<span class="cm">   * noticeably speed construction time for an AHA.</span>
<span class="cm">   */</span>
  <span class="n">FOR_EACH_RANGE</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">capacity_</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cellKeyPtr</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">cells_</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">kEmptyKey_</span><span class="p">,</span>
      <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">map</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">KeyT</span><span class="p">,</span> <span class="n">class</span> <span class="n">ValueT</span><span class="p">,</span> <span class="n">class</span> <span class="n">HashFcn</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">AtomicHashArray</span><span class="o">&lt;</span><span class="n">KeyT</span><span class="p">,</span> <span class="n">ValueT</span><span class="p">,</span> <span class="n">HashFcn</span><span class="o">&gt;::</span>
<span class="n">destroy</span><span class="p">(</span><span class="n">AtomicHashArray</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
  <span class="n">FOR_EACH_RANGE</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">capacity_</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">cells_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span> <span class="o">!=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">kEmptyKey_</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">p</span><span class="o">-&gt;</span><span class="n">cells_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="o">~</span><span class="n">value_type</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">p</span><span class="o">-&gt;~</span><span class="n">AtomicHashArray</span><span class="p">();</span>
  <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span></pre></div></td></tr>


<tr id="section-21"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-21">&#182;</a></div><p>clear -- clears all keys and values in the map and resets all counters</p></td><td class="code"><div class="highlight"><pre><span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">KeyT</span><span class="p">,</span> <span class="n">class</span> <span class="n">ValueT</span><span class="p">,</span> <span class="n">class</span> <span class="n">HashFcn</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">AtomicHashArray</span><span class="o">&lt;</span><span class="n">KeyT</span><span class="p">,</span> <span class="n">ValueT</span><span class="p">,</span> <span class="n">HashFcn</span><span class="o">&gt;::</span>
<span class="n">clear</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">FOR_EACH_RANGE</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">capacity_</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">cells_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span> <span class="o">!=</span> <span class="n">kEmptyKey_</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">cells_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="o">~</span><span class="n">value_type</span><span class="p">();</span>
      <span class="o">*</span><span class="n">const_cast</span><span class="o">&lt;</span><span class="n">KeyT</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cells_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="p">)</span> <span class="o">=</span> <span class="n">kEmptyKey_</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">CHECK</span><span class="p">(</span><span class="n">cells_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span> <span class="o">==</span> <span class="n">kEmptyKey_</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">numEntries_</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">numPendingEntries_</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">isFull_</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="n">numErases_</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
<span class="p">}</span></pre></div></td></tr>


<tr id="section-22"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-22">&#182;</a></div><p>Iterator implementation</p></td><td class="code"><div class="highlight"><pre><span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">KeyT</span><span class="p">,</span> <span class="n">class</span> <span class="n">ValueT</span><span class="p">,</span> <span class="n">class</span> <span class="n">HashFcn</span><span class="o">&gt;</span>
<span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">ContT</span><span class="p">,</span> <span class="n">class</span> <span class="n">IterVal</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">AtomicHashArray</span><span class="o">&lt;</span><span class="n">KeyT</span><span class="p">,</span> <span class="n">ValueT</span><span class="p">,</span> <span class="n">HashFcn</span><span class="o">&gt;::</span><span class="n">aha_iterator</span>
    <span class="o">:</span> <span class="n">boost</span><span class="o">::</span><span class="n">iterator_facade</span><span class="o">&lt;</span><span class="n">aha_iterator</span><span class="o">&lt;</span><span class="n">ContT</span><span class="p">,</span><span class="n">IterVal</span><span class="o">&gt;</span><span class="p">,</span>
                             <span class="n">IterVal</span><span class="p">,</span>
                             <span class="n">boost</span><span class="o">::</span><span class="n">forward_traversal_tag</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="n">explicit</span> <span class="n">aha_iterator</span><span class="p">()</span> <span class="o">:</span> <span class="n">aha_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span></pre></div></td></tr>


<tr id="section-23"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-23">&#182;</a></div><p>Conversion ctor for interoperability between const<em>iterator and
iterator.  The enable</em>if&lt;> magic keeps us well-behaved for
is<em>convertible&lt;> (v. the iterator</em>facade documentation).</p></td><td class="code"><div class="highlight"><pre>  <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">OtherContT</span><span class="p">,</span> <span class="n">class</span> <span class="n">OtherVal</span><span class="o">&gt;</span>
  <span class="n">aha_iterator</span><span class="p">(</span><span class="k">const</span> <span class="n">aha_iterator</span><span class="o">&lt;</span><span class="n">OtherContT</span><span class="p">,</span><span class="n">OtherVal</span><span class="o">&gt;&amp;</span> <span class="n">o</span><span class="p">,</span>
               <span class="kr">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span>
               <span class="n">std</span><span class="o">::</span><span class="n">is_convertible</span><span class="o">&lt;</span><span class="n">OtherVal</span><span class="o">*</span><span class="p">,</span><span class="n">IterVal</span><span class="o">*&gt;::</span><span class="n">value</span> <span class="o">&gt;::</span><span class="n">type</span><span class="o">*</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">aha_</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">aha_</span><span class="p">)</span>
      <span class="p">,</span> <span class="n">offset_</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">offset_</span><span class="p">)</span>
  <span class="p">{}</span>

  <span class="n">explicit</span> <span class="n">aha_iterator</span><span class="p">(</span><span class="n">ContT</span><span class="o">*</span> <span class="n">array</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">offset</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">aha_</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
      <span class="p">,</span> <span class="n">offset_</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">advancePastEmpty</span><span class="p">();</span>
  <span class="p">}</span></pre></div></td></tr>


<tr id="section-24"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-24">&#182;</a></div><p>Returns unique index that can be used with findAt().
WARNING: The following function will fail silently for hashtable
with capacity > 2^32</p></td><td class="code"><div class="highlight"><pre>  <span class="kt">uint32_t</span> <span class="n">getIndex</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">offset_</span><span class="p">;</span> <span class="p">}</span>

 <span class="nl">private:</span>
  <span class="n">friend</span> <span class="n">class</span> <span class="n">AtomicHashArray</span><span class="p">;</span>
  <span class="n">friend</span> <span class="n">class</span> <span class="n">boost</span><span class="o">::</span><span class="n">iterator_core_access</span><span class="p">;</span>

  <span class="kt">void</span> <span class="nf">increment</span><span class="p">()</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">offset_</span><span class="p">;</span>
    <span class="n">advancePastEmpty</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">bool</span> <span class="n">equal</span><span class="p">(</span><span class="k">const</span> <span class="n">aha_iterator</span><span class="o">&amp;</span> <span class="n">o</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">aha_</span> <span class="o">==</span> <span class="n">o</span><span class="p">.</span><span class="n">aha_</span> <span class="o">&amp;&amp;</span> <span class="n">offset_</span> <span class="o">==</span> <span class="n">o</span><span class="p">.</span><span class="n">offset_</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">IterVal</span><span class="o">&amp;</span> <span class="n">dereference</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">aha_</span><span class="o">-&gt;</span><span class="n">cells_</span><span class="p">[</span><span class="n">offset_</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">advancePastEmpty</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">offset_</span> <span class="o">&lt;</span> <span class="n">aha_</span><span class="o">-&gt;</span><span class="n">capacity_</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isValid</span><span class="p">())</span> <span class="p">{</span>
      <span class="o">++</span><span class="n">offset_</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">bool</span> <span class="n">isValid</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">KeyT</span> <span class="n">key</span> <span class="o">=</span> <span class="n">acquireLoadKey</span><span class="p">(</span><span class="n">aha_</span><span class="o">-&gt;</span><span class="n">cells_</span><span class="p">[</span><span class="n">offset_</span><span class="p">]);</span>
    <span class="k">return</span> <span class="n">key</span> <span class="o">!=</span> <span class="n">aha_</span><span class="o">-&gt;</span><span class="n">kEmptyKey_</span>  <span class="o">&amp;&amp;</span>
      <span class="n">key</span> <span class="o">!=</span> <span class="n">aha_</span><span class="o">-&gt;</span><span class="n">kLockedKey_</span> <span class="o">&amp;&amp;</span>
      <span class="n">key</span> <span class="o">!=</span> <span class="n">aha_</span><span class="o">-&gt;</span><span class="n">kErasedKey_</span><span class="p">;</span>
  <span class="p">}</span>

 <span class="nl">private:</span>
  <span class="n">ContT</span><span class="o">*</span> <span class="n">aha_</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">offset_</span><span class="p">;</span>
<span class="p">};</span> <span class="c1">// aha_iterator</span>

<span class="p">}</span> <span class="c1">// namespace folly</span>

<span class="cp">#undef FOLLY_SPIN_WAIT</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/folly",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
