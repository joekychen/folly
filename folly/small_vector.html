<!DOCTYPE html>
<html><head><title>joekychen/folly » folly › small_vector.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>small_vector.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2012 Facebook, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="cm"> * you may not use this file except in compliance with the License.</span>
<span class="cm"> * You may obtain a copy of the License at</span>
<span class="cm"> *</span>
<span class="cm"> *   http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="cm"> *</span>
<span class="cm"> * Unless required by applicable law or agreed to in writing, software</span>
<span class="cm"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="cm"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="cm"> * See the License for the specific language governing permissions and</span>
<span class="cm"> * limitations under the License.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * For high-level documentation and usage examples see folly/doc/small_vector.md</span>
<span class="cm"> *</span>
<span class="cm"> * @author Jordan DeLong &lt;delong.j@fb.com&gt;</span>
<span class="cm"> */</span>
<span class="cp">#ifndef FOLLY_SMALL_VECTOR_H_</span>
<span class="cp">#define FOLLY_SMALL_VECTOR_H_</span>

<span class="cp">#include &quot;Portability.h&quot;</span>

<span class="cp">#include &lt;stdexcept&gt;</span>
<span class="cp">#include &lt;cstdlib&gt;</span>
<span class="cp">#include &lt;type_traits&gt;</span>
<span class="cp">#include &lt;algorithm&gt;</span>
<span class="cp">#include &lt;iterator&gt;</span>
<span class="cp">#include &lt;cassert&gt;</span>

<span class="cp">#include &lt;boost/operators.hpp&gt;</span>
<span class="cp">#include &lt;boost/type_traits.hpp&gt;</span>
<span class="cp">#include &lt;boost/mpl/if.hpp&gt;</span>
<span class="cp">#include &lt;boost/mpl/eval_if.hpp&gt;</span>
<span class="cp">#include &lt;boost/mpl/vector.hpp&gt;</span>
<span class="cp">#include &lt;boost/mpl/front.hpp&gt;</span>
<span class="cp">#include &lt;boost/mpl/filter_view.hpp&gt;</span>
<span class="cp">#include &lt;boost/mpl/identity.hpp&gt;</span>
<span class="cp">#include &lt;boost/mpl/placeholders.hpp&gt;</span>
<span class="cp">#include &lt;boost/mpl/empty.hpp&gt;</span>
<span class="cp">#include &lt;boost/mpl/size.hpp&gt;</span>
<span class="cp">#include &lt;boost/mpl/count.hpp&gt;</span>
<span class="cp">#include &lt;boost/mpl/max.hpp&gt;</span>

<span class="cp">#include &quot;folly/Malloc.h&quot;</span>

<span class="cp">#if defined(__GNUC__) &amp;&amp; defined(__x86_64__)</span>
<span class="cp"># include &quot;folly/SmallLocks.h&quot;</span>
<span class="cp"># define FB_PACKED __attribute__((packed))</span>
<span class="cp">#else</span>
<span class="cp"># define FB_PACKED</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef FOLLY_HAVE_MALLOC_SIZE</span>
  <span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">malloc_size</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span><span class="p">);</span>
<span class="cp"># ifndef FOLLY_HAVE_MALLOC_USABLE_SIZE</span>
<span class="cp">#  define malloc_usable_size malloc_size</span>
<span class="cp"># endif</span>
<span class="cp"># ifndef malloc_usable_size</span>
<span class="cp">#  define malloc_usable_size malloc_size</span>
<span class="cp"># endif</span>
<span class="cp">#endif</span>

<span class="n">namespace</span> <span class="n">folly</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>////////////////////////////////////////////////////////////////////</p></td><td class="code"><div class="highlight"><pre><span class="n">namespace</span> <span class="n">small_vector_policy</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>////////////////////////////////////////////////////////////////////</p></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * A flag which makes us refuse to use the heap at all.  If we</span>
<span class="cm"> * overflow the in situ capacity we throw an exception.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">NoHeap</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Passing this policy will cause small_vector to provide lock() and</span>
<span class="cm"> * unlock() functions using a 1-bit spin lock in the size value.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that this is intended for a fairly specialized (although</span>
<span class="cm"> * strangely common at facebook) use case, where you have billions of</span>
<span class="cm"> * vectors in memory where none of them are &quot;hot&quot; and most of them are</span>
<span class="cm"> * small.  This allows you to get fine-grained locks without spending</span>
<span class="cm"> * a lot of memory on mutexes (the alternative of a large hashtable of</span>
<span class="cm"> * locks leads to extra cache misses in the lookup path).</span>
<span class="cm"> *</span>
<span class="cm"> * __x86_64__ only.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">OneBitMutex</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>////////////////////////////////////////////////////////////////////</p></td><td class="code"><div class="highlight"><pre><span class="p">}</span> <span class="c1">// small_vector_policy</span></pre></div></td></tr>


<tr id="section-5"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-5">&#182;</a></div><p>////////////////////////////////////////////////////////////////////</p></td><td class="code"><div class="highlight"><pre><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">M</span><span class="p">,</span> <span class="n">class</span> <span class="n">A</span><span class="p">,</span> <span class="n">class</span> <span class="n">B</span><span class="p">,</span> <span class="n">class</span> <span class="n">C</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">small_vector</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-6"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-6">&#182;</a></div><p>////////////////////////////////////////////////////////////////////</p></td><td class="code"><div class="highlight"><pre><span class="n">namespace</span> <span class="n">detail</span> <span class="p">{</span>

  <span class="cm">/*</span>
<span class="cm">   * Move a range to a range of uninitialized memory.  Assumes the</span>
<span class="cm">   * ranges don&#39;t overlap.</span>
<span class="cm">   */</span>
  <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="kr">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span>
    <span class="o">!</span><span class="n">boost</span><span class="o">::</span><span class="n">has_trivial_copy</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span>
  <span class="o">&gt;::</span><span class="n">type</span>
  <span class="n">moveToUninitialized</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">first</span><span class="p">,</span> <span class="n">T</span><span class="o">*</span> <span class="n">last</span><span class="p">,</span> <span class="n">T</span><span class="o">*</span> <span class="n">out</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="k">const</span> <span class="n">count</span> <span class="o">=</span> <span class="n">last</span> <span class="o">-</span> <span class="n">first</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">try</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">first</span><span class="p">,</span> <span class="o">++</span><span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">new</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">out</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="n">T</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">));</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="n">catch</span> <span class="p">(...)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-7"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-7">&#182;</a></div><p>Even for callers trying to give the strong guarantee
(e.g. push_back) it's ok to assume here that we don't have to
move things back and that it was a copy constructor that
threw: if someone throws from a move constructor the effects
are unspecified.</p></td><td class="code"><div class="highlight"><pre>      <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">idx</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="o">~</span><span class="n">T</span><span class="p">();</span>
      <span class="p">}</span>
      <span class="n">throw</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span></pre></div></td></tr>


<tr id="section-8"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-8">&#182;</a></div><p>Specialization for trivially copyable types.  (TODO: change to
std::is<em>trivially</em>copyable when that works.)</p></td><td class="code"><div class="highlight"><pre>  <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="kr">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">has_trivial_copy</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span>
  <span class="o">&gt;::</span><span class="n">type</span>
  <span class="n">moveToUninitialized</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">first</span><span class="p">,</span> <span class="n">T</span><span class="o">*</span> <span class="n">last</span><span class="p">,</span> <span class="n">T</span><span class="o">*</span> <span class="n">out</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">memmove</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="p">(</span><span class="n">last</span> <span class="o">-</span> <span class="n">first</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">first</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="cm">/*</span>
<span class="cm">   * Move objects in memory to the right into some uninitialized</span>
<span class="cm">   * memory, where the region overlaps.  This doesn&#39;t just use</span>
<span class="cm">   * std::move_backward because move_backward only works if all the</span>
<span class="cm">   * memory is initialized to type T already.</span>
<span class="cm">   */</span>
  <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="kr">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span>
    <span class="o">!</span><span class="n">boost</span><span class="o">::</span><span class="n">has_trivial_copy</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span>
  <span class="o">&gt;::</span><span class="n">type</span>
  <span class="n">moveObjectsRight</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">first</span><span class="p">,</span> <span class="n">T</span><span class="o">*</span> <span class="n">lastConstructed</span><span class="p">,</span> <span class="n">T</span><span class="o">*</span> <span class="n">realLast</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">lastConstructed</span> <span class="o">==</span> <span class="n">realLast</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">T</span><span class="o">*</span> <span class="n">end</span> <span class="o">=</span> <span class="n">first</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// Past the end going backwards.</span>
    <span class="n">T</span><span class="o">*</span> <span class="n">out</span> <span class="o">=</span> <span class="n">realLast</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">T</span><span class="o">*</span> <span class="n">in</span> <span class="o">=</span> <span class="n">lastConstructed</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">try</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(;</span> <span class="n">in</span> <span class="o">!=</span> <span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="n">out</span> <span class="o">&gt;=</span> <span class="n">lastConstructed</span><span class="p">;</span> <span class="o">--</span><span class="n">in</span><span class="p">,</span> <span class="o">--</span><span class="n">out</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">new</span> <span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="n">T</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="o">*</span><span class="n">in</span><span class="p">));</span>
      <span class="p">}</span>
      <span class="k">for</span> <span class="p">(;</span> <span class="n">in</span> <span class="o">!=</span> <span class="n">end</span><span class="p">;</span> <span class="o">--</span><span class="n">in</span><span class="p">,</span> <span class="o">--</span><span class="n">out</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">out</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="o">*</span><span class="n">in</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">for</span> <span class="p">(;</span> <span class="n">out</span> <span class="o">&gt;=</span> <span class="n">lastConstructed</span><span class="p">;</span> <span class="o">--</span><span class="n">out</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">new</span> <span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="n">T</span><span class="p">();</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="n">catch</span> <span class="p">(...)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-9"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-9">&#182;</a></div><p>We want to make sure the same stuff is uninitialized memory
if we exit via an exception (this is to make sure we provide
the basic exception safety guarantee for insert functions).</p></td><td class="code"><div class="highlight"><pre>      <span class="k">if</span> <span class="p">(</span><span class="n">out</span> <span class="o">&lt;</span> <span class="n">lastConstructed</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">lastConstructed</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">out</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">realLast</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">it</span><span class="o">-&gt;~</span><span class="n">T</span><span class="p">();</span>
      <span class="p">}</span>
      <span class="n">throw</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span></pre></div></td></tr>


<tr id="section-10"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-10">&#182;</a></div><p>Specialization for trivially copyable types.  The call to
std::move<em>backward here will just turn into a memmove.  (TODO:
change to std::is</em>trivially_copyable when that works.)</p></td><td class="code"><div class="highlight"><pre>  <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="kr">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">has_trivial_copy</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span>
  <span class="o">&gt;::</span><span class="n">type</span>
  <span class="n">moveObjectsRight</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">first</span><span class="p">,</span> <span class="n">T</span><span class="o">*</span> <span class="n">lastConstructed</span><span class="p">,</span> <span class="n">T</span><span class="o">*</span> <span class="n">realLast</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">move_backward</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">lastConstructed</span><span class="p">,</span> <span class="n">realLast</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="cm">/*</span>
<span class="cm">   * Populate a region of memory using `op&#39; to construct elements.  If</span>
<span class="cm">   * anything throws, undo what we did.</span>
<span class="cm">   */</span>
  <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="p">,</span> <span class="n">class</span> <span class="n">Function</span><span class="o">&gt;</span>
  <span class="kt">void</span> <span class="n">populateMemForward</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">mem</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">Function</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">op</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">try</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">op</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mem</span><span class="p">[</span><span class="n">idx</span><span class="p">]);</span>
        <span class="o">++</span><span class="n">idx</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="n">catch</span> <span class="p">(...)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">idx</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">mem</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="o">~</span><span class="n">T</span><span class="p">();</span>
      <span class="p">}</span>
      <span class="n">throw</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">SizeType</span><span class="p">,</span> <span class="n">bool</span> <span class="n">ShouldUseHeap</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="n">IntegralSizePolicy</span> <span class="p">{</span>
    <span class="k">typedef</span> <span class="n">SizeType</span> <span class="n">InternalSizeType</span><span class="p">;</span>

    <span class="n">IntegralSizePolicy</span><span class="p">()</span> <span class="o">:</span> <span class="n">size_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>

  <span class="nl">protected:</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">policyMaxSize</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">SizeType</span><span class="p">(</span><span class="o">~</span><span class="n">kExternMask</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">doSize</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">size_</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">kExternMask</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">isExtern</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">kExternMask</span> <span class="o">&amp;</span> <span class="n">size_</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">setExtern</span><span class="p">(</span><span class="n">bool</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">size_</span> <span class="o">|=</span> <span class="n">kExternMask</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">size_</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">kExternMask</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">setSize</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">sz</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">sz</span> <span class="o">&lt;=</span> <span class="n">policyMaxSize</span><span class="p">());</span>
      <span class="n">size_</span> <span class="o">=</span> <span class="p">(</span><span class="n">kExternMask</span> <span class="o">&amp;</span> <span class="n">size_</span><span class="p">)</span> <span class="o">|</span> <span class="n">SizeType</span><span class="p">(</span><span class="n">sz</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">swapSizePolicy</span><span class="p">(</span><span class="n">IntegralSizePolicy</span><span class="o">&amp;</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">size_</span><span class="p">,</span> <span class="n">o</span><span class="p">.</span><span class="n">size_</span><span class="p">);</span>
    <span class="p">}</span>

  <span class="nl">protected:</span>
    <span class="k">static</span> <span class="n">bool</span> <span class="k">const</span> <span class="n">kShouldUseHeap</span> <span class="o">=</span> <span class="n">ShouldUseHeap</span><span class="p">;</span>

  <span class="nl">private:</span>
    <span class="k">static</span> <span class="n">SizeType</span> <span class="k">const</span> <span class="n">kExternMask</span> <span class="o">=</span>
      <span class="n">kShouldUseHeap</span> <span class="o">?</span> <span class="n">SizeType</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">SizeType</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                     <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">SizeType</span> <span class="n">size_</span><span class="p">;</span>
  <span class="p">};</span>

<span class="cp">#ifdef __x86_64__</span>
  <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">SizeType</span><span class="p">,</span> <span class="n">bool</span> <span class="n">ShouldUseHeap</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="n">OneBitMutexImpl</span> <span class="p">{</span>
    <span class="k">typedef</span> <span class="n">SizeType</span> <span class="n">InternalSizeType</span><span class="p">;</span>

    <span class="n">OneBitMutexImpl</span><span class="p">()</span> <span class="p">{</span> <span class="n">psl_</span><span class="p">.</span><span class="n">init</span><span class="p">();</span> <span class="p">}</span>

    <span class="kt">void</span> <span class="n">lock</span><span class="p">()</span>     <span class="k">const</span> <span class="p">{</span> <span class="n">psl_</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">unlock</span><span class="p">()</span>   <span class="k">const</span> <span class="p">{</span> <span class="n">psl_</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span> <span class="p">}</span>
    <span class="n">bool</span> <span class="n">try_lock</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">psl_</span><span class="p">.</span><span class="n">try_lock</span><span class="p">();</span> <span class="p">}</span>

  <span class="nl">protected:</span>
    <span class="k">static</span> <span class="n">bool</span> <span class="k">const</span> <span class="n">kShouldUseHeap</span> <span class="o">=</span> <span class="n">ShouldUseHeap</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">policyMaxSize</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">SizeType</span><span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">SizeType</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">kLockBit</span> <span class="o">|</span> <span class="n">kExternMask</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">doSize</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">psl_</span><span class="p">.</span><span class="n">getData</span><span class="p">()</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">kExternMask</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">isExtern</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">psl_</span><span class="p">.</span><span class="n">getData</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">kExternMask</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">setExtern</span><span class="p">(</span><span class="n">bool</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">setSize</span><span class="p">(</span><span class="n">SizeType</span><span class="p">(</span><span class="n">doSize</span><span class="p">())</span> <span class="o">|</span> <span class="n">kExternMask</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">setSize</span><span class="p">(</span><span class="n">SizeType</span><span class="p">(</span><span class="n">doSize</span><span class="p">())</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">kExternMask</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">setSize</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">sz</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">sz</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">kLockBit</span><span class="p">));</span>
      <span class="n">psl_</span><span class="p">.</span><span class="n">setData</span><span class="p">((</span><span class="n">kExternMask</span> <span class="o">&amp;</span> <span class="n">psl_</span><span class="p">.</span><span class="n">getData</span><span class="p">())</span> <span class="o">|</span> <span class="n">SizeType</span><span class="p">(</span><span class="n">sz</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">swapSizePolicy</span><span class="p">(</span><span class="n">OneBitMutexImpl</span><span class="o">&amp;</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">psl_</span><span class="p">,</span> <span class="n">o</span><span class="p">.</span><span class="n">psl_</span><span class="p">);</span>
    <span class="p">}</span>

  <span class="nl">private:</span>
    <span class="k">static</span> <span class="n">SizeType</span> <span class="k">const</span> <span class="n">kLockBit</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">SizeType</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">static</span> <span class="n">SizeType</span> <span class="k">const</span> <span class="n">kExternMask</span> <span class="o">=</span>
      <span class="n">kShouldUseHeap</span> <span class="o">?</span> <span class="n">SizeType</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">SizeType</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
                     <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">PicoSpinLock</span><span class="o">&lt;</span><span class="n">SizeType</span><span class="p">,</span><span class="n">kLockBit</span><span class="o">&gt;</span> <span class="n">psl_</span><span class="p">;</span>
  <span class="p">};</span>
<span class="cp">#else</span>
  <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">SizeType</span><span class="p">,</span> <span class="n">bool</span> <span class="n">ShouldUseHeap</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="n">OneBitMutexImpl</span> <span class="p">{</span>
    <span class="n">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">SizeType</span><span class="p">,</span><span class="kt">void</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
                  <span class="s">&quot;OneBitMutex only works on x86-64&quot;</span><span class="p">);</span>
  <span class="p">};</span>
<span class="cp">#endif</span>

  <span class="cm">/*</span>
<span class="cm">   * If you&#39;re just trying to use this class, ignore everything about</span>
<span class="cm">   * this next small_vector_base class thing.</span>
<span class="cm">   *</span>
<span class="cm">   * The purpose of this junk is to minimize sizeof(small_vector&lt;&gt;)</span>
<span class="cm">   * and allow specifying the template parameters in whatever order is</span>
<span class="cm">   * convenient for the user.  There&#39;s a few extra steps here to try</span>
<span class="cm">   * to keep the error messages at least semi-reasonable.</span>
<span class="cm">   *</span>
<span class="cm">   * Apologies for all the black magic.</span>
<span class="cm">   */</span>
  <span class="n">namespace</span> <span class="n">mpl</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">mpl</span><span class="p">;</span>
  <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Value</span><span class="p">,</span>
           <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">RequestedMaxInline</span><span class="p">,</span>
           <span class="n">class</span> <span class="n">InPolicyA</span><span class="p">,</span>
           <span class="n">class</span> <span class="n">InPolicyB</span><span class="p">,</span>
           <span class="n">class</span> <span class="n">InPolicyC</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="n">small_vector_base</span> <span class="p">{</span>
    <span class="k">typedef</span> <span class="n">mpl</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">InPolicyA</span><span class="p">,</span><span class="n">InPolicyB</span><span class="p">,</span><span class="n">InPolicyC</span><span class="o">&gt;</span> <span class="n">PolicyList</span><span class="p">;</span>

    <span class="cm">/*</span>
<span class="cm">     * Determine the size type</span>
<span class="cm">     */</span>
    <span class="k">typedef</span> <span class="kr">typename</span> <span class="n">mpl</span><span class="o">::</span><span class="n">filter_view</span><span class="o">&lt;</span>
      <span class="n">PolicyList</span><span class="p">,</span>
      <span class="n">boost</span><span class="o">::</span><span class="n">is_integral</span><span class="o">&lt;</span><span class="n">mpl</span><span class="o">::</span><span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="o">&gt;</span>
    <span class="o">&gt;::</span><span class="n">type</span> <span class="n">Integrals</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="kr">typename</span> <span class="n">mpl</span><span class="o">::</span><span class="n">eval_if</span><span class="o">&lt;</span>
      <span class="n">mpl</span><span class="o">::</span><span class="n">empty</span><span class="o">&lt;</span><span class="n">Integrals</span><span class="o">&gt;</span><span class="p">,</span>
      <span class="n">mpl</span><span class="o">::</span><span class="n">identity</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">,</span>
      <span class="n">mpl</span><span class="o">::</span><span class="n">front</span><span class="o">&lt;</span><span class="n">Integrals</span><span class="o">&gt;</span>
    <span class="o">&gt;::</span><span class="n">type</span> <span class="n">SizeType</span><span class="p">;</span>

    <span class="n">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_unsigned</span><span class="o">&lt;</span><span class="n">SizeType</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span>
                  <span class="s">&quot;Size type should be an unsigned integral type&quot;</span><span class="p">);</span>
    <span class="n">static_assert</span><span class="p">(</span><span class="n">mpl</span><span class="o">::</span><span class="n">size</span><span class="o">&lt;</span><span class="n">Integrals</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
                    <span class="n">mpl</span><span class="o">::</span><span class="n">size</span><span class="o">&lt;</span><span class="n">Integrals</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span>
                  <span class="s">&quot;Multiple size types specified in small_vector&lt;&gt;&quot;</span><span class="p">);</span>

    <span class="cm">/*</span>
<span class="cm">     * Figure out if we&#39;re supposed to supply a one-bit mutex. :)</span>
<span class="cm">     */</span>
    <span class="k">typedef</span> <span class="kr">typename</span> <span class="n">mpl</span><span class="o">::</span><span class="n">count</span><span class="o">&lt;</span>
      <span class="n">PolicyList</span><span class="p">,</span><span class="n">small_vector_policy</span><span class="o">::</span><span class="n">OneBitMutex</span>
    <span class="o">&gt;::</span><span class="n">type</span> <span class="n">HasMutex</span><span class="p">;</span>

    <span class="n">static_assert</span><span class="p">(</span><span class="n">HasMutex</span><span class="o">::</span><span class="n">value</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">HasMutex</span><span class="o">::</span><span class="n">value</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span>
                  <span class="s">&quot;Multiple copies of small_vector_policy::OneBitMutex &quot;</span>
                  <span class="s">&quot;supplied; this is probably a mistake&quot;</span><span class="p">);</span>

    <span class="cm">/*</span>
<span class="cm">     * Determine whether we should allow spilling to the heap or not.</span>
<span class="cm">     */</span>
    <span class="k">typedef</span> <span class="kr">typename</span> <span class="n">mpl</span><span class="o">::</span><span class="n">count</span><span class="o">&lt;</span>
      <span class="n">PolicyList</span><span class="p">,</span><span class="n">small_vector_policy</span><span class="o">::</span><span class="n">NoHeap</span>
    <span class="o">&gt;::</span><span class="n">type</span> <span class="n">HasNoHeap</span><span class="p">;</span>

    <span class="n">static_assert</span><span class="p">(</span><span class="n">HasNoHeap</span><span class="o">::</span><span class="n">value</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">HasNoHeap</span><span class="o">::</span><span class="n">value</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span>
                  <span class="s">&quot;Multiple copies of small_vector_policy::NoHeap &quot;</span>
                  <span class="s">&quot;supplied; this is probably a mistake&quot;</span><span class="p">);</span>

    <span class="cm">/*</span>
<span class="cm">     * Make the real policy base classes.</span>
<span class="cm">     */</span>
    <span class="k">typedef</span> <span class="kr">typename</span> <span class="n">mpl</span><span class="o">::</span><span class="n">if_</span><span class="o">&lt;</span>
      <span class="n">HasMutex</span><span class="p">,</span>
      <span class="n">OneBitMutexImpl</span><span class="o">&lt;</span><span class="n">SizeType</span><span class="p">,</span><span class="o">!</span><span class="n">HasNoHeap</span><span class="o">::</span><span class="n">value</span><span class="o">&gt;</span><span class="p">,</span>
      <span class="n">IntegralSizePolicy</span><span class="o">&lt;</span><span class="n">SizeType</span><span class="p">,</span><span class="o">!</span><span class="n">HasNoHeap</span><span class="o">::</span><span class="n">value</span><span class="o">&gt;</span>
    <span class="o">&gt;::</span><span class="n">type</span> <span class="n">ActualSizePolicy</span><span class="p">;</span>

    <span class="cm">/*</span>
<span class="cm">     * Now inherit from them all.  This is done in such a convoluted</span>
<span class="cm">     * way to make sure we get the empty base optimizaton on all these</span>
<span class="cm">     * types to keep sizeof(small_vector&lt;&gt;) minimal.</span>
<span class="cm">     */</span>
    <span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">totally_ordered1</span><span class="o">&lt;</span>
      <span class="n">small_vector</span><span class="o">&lt;</span><span class="n">Value</span><span class="p">,</span><span class="n">RequestedMaxInline</span><span class="p">,</span><span class="n">InPolicyA</span><span class="p">,</span><span class="n">InPolicyB</span><span class="p">,</span><span class="n">InPolicyC</span><span class="o">&gt;</span><span class="p">,</span>
      <span class="n">ActualSizePolicy</span>
    <span class="o">&gt;</span> <span class="n">type</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="n">T</span><span class="o">*</span> <span class="n">pointerFlagSet</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">uintptr_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">|</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="n">bool</span> <span class="n">pointerFlagGet</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">uintptr_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="n">T</span><span class="o">*</span> <span class="n">pointerFlagClear</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">uintptr_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kr">inline</span> <span class="kt">void</span><span class="o">*</span> <span class="n">shiftPointer</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">sizeBytes</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="n">sizeBytes</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span></pre></div></td></tr>


<tr id="section-11"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-11">&#182;</a></div><p>////////////////////////////////////////////////////////////////////</p></td><td class="code"><div class="highlight"><pre><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Value</span><span class="p">,</span>
         <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">RequestedMaxInline</span>    <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
         <span class="n">class</span> <span class="n">PolicyA</span>                     <span class="o">=</span> <span class="kt">void</span><span class="p">,</span>
         <span class="n">class</span> <span class="n">PolicyB</span>                     <span class="o">=</span> <span class="kt">void</span><span class="p">,</span>
         <span class="n">class</span> <span class="n">PolicyC</span>                     <span class="o">=</span> <span class="kt">void</span><span class="o">&gt;</span>
<span class="n">class</span> <span class="n">small_vector</span>
  <span class="o">:</span> <span class="n">public</span> <span class="n">detail</span><span class="o">::</span><span class="n">small_vector_base</span><span class="o">&lt;</span>
      <span class="n">Value</span><span class="p">,</span><span class="n">RequestedMaxInline</span><span class="p">,</span><span class="n">PolicyA</span><span class="p">,</span><span class="n">PolicyB</span><span class="p">,</span><span class="n">PolicyC</span>
    <span class="o">&gt;::</span><span class="n">type</span>
<span class="p">{</span>
  <span class="k">typedef</span> <span class="kr">typename</span> <span class="n">detail</span><span class="o">::</span><span class="n">small_vector_base</span><span class="o">&lt;</span>
    <span class="n">Value</span><span class="p">,</span><span class="n">RequestedMaxInline</span><span class="p">,</span><span class="n">PolicyA</span><span class="p">,</span><span class="n">PolicyB</span><span class="p">,</span><span class="n">PolicyC</span>
  <span class="o">&gt;::</span><span class="n">type</span> <span class="n">BaseType</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="kr">typename</span> <span class="n">BaseType</span><span class="o">::</span><span class="n">InternalSizeType</span> <span class="n">InternalSizeType</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">   * Figure out the max number of elements we should inline.  (If</span>
<span class="cm">   * the user asks for less inlined elements than we can fit unioned</span>
<span class="cm">   * into our value_type*, we will inline more than they asked.)</span>
<span class="cm">   */</span>
  <span class="k">enum</span> <span class="p">{</span>
    <span class="n">MaxInline</span> <span class="o">=</span> <span class="n">boost</span><span class="o">::</span><span class="n">mpl</span><span class="o">::</span><span class="n">max</span><span class="o">&lt;</span>
                  <span class="n">boost</span><span class="o">::</span><span class="n">mpl</span><span class="o">::</span><span class="n">int_</span><span class="o">&lt;</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Value</span><span class="o">*</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Value</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span>
                  <span class="n">boost</span><span class="o">::</span><span class="n">mpl</span><span class="o">::</span><span class="n">int_</span><span class="o">&lt;</span><span class="n">RequestedMaxInline</span><span class="o">&gt;</span>
                <span class="o">&gt;::</span><span class="n">type</span><span class="o">::</span><span class="n">value</span>
  <span class="p">};</span>

<span class="nl">public:</span>
  <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">size_type</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">Value</span>              <span class="n">value_type</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">value_type</span><span class="o">&amp;</span>        <span class="n">reference</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">value_type</span> <span class="k">const</span><span class="o">&amp;</span>  <span class="n">const_reference</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">value_type</span><span class="o">*</span>        <span class="n">iterator</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">value_type</span> <span class="k">const</span><span class="o">*</span>  <span class="n">const_iterator</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="kt">ptrdiff_t</span>     <span class="n">difference_type</span><span class="p">;</span>

  <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">reverse_iterator</span><span class="o">&lt;</span><span class="n">iterator</span><span class="o">&gt;</span>       <span class="n">reverse_iterator</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">reverse_iterator</span><span class="o">&lt;</span><span class="n">const_iterator</span><span class="o">&gt;</span> <span class="n">const_reverse_iterator</span><span class="p">;</span>

  <span class="n">explicit</span> <span class="nf">small_vector</span><span class="p">()</span> <span class="p">{}</span>

  <span class="n">small_vector</span><span class="p">(</span><span class="n">small_vector</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">assign</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">o</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="n">small_vector</span><span class="p">(</span><span class="n">small_vector</span><span class="o">&amp;&amp;</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">this</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">small_vector</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">constructImpl</span><span class="p">(</span><span class="n">il</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">il</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">false_type</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="n">explicit</span> <span class="n">small_vector</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="n">value_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">value_type</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">doConstruct</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Arg</span><span class="o">&gt;</span>
  <span class="n">explicit</span> <span class="n">small_vector</span><span class="p">(</span><span class="n">Arg</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">Arg</span> <span class="n">arg2</span><span class="p">)</span>  <span class="p">{</span></pre></div></td></tr>


<tr id="section-12"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-12">&#182;</a></div><p>Forward using std::is<em>arithmetic to get to the proper
implementation; this disambiguates between the iterators and
(size</em>t, value_type) meaning for this constructor.</p></td><td class="code"><div class="highlight"><pre>    <span class="n">constructImpl</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">is_arithmetic</span><span class="o">&lt;</span><span class="n">Arg</span><span class="o">&gt;</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="o">~</span><span class="n">small_vector</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">t</span> <span class="o">:</span> <span class="o">*</span><span class="n">this</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="p">)</span><span class="o">-&gt;~</span><span class="n">value_type</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">isExtern</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">u</span><span class="p">.</span><span class="n">freeHeap</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">small_vector</span><span class="o">&amp;</span> <span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="n">small_vector</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">assign</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">o</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="k">return</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">small_vector</span><span class="o">&amp;</span> <span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="n">small_vector</span><span class="o">&amp;&amp;</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">clear</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">o</span><span class="p">.</span><span class="n">isExtern</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">makeSize</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">o</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">new</span> <span class="p">(</span><span class="n">data</span><span class="p">()</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">o</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
      <span class="p">}</span>
      <span class="n">this</span><span class="o">-&gt;</span><span class="n">setSize</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">swap</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">bool</span> <span class="n">operator</span><span class="o">==</span><span class="p">(</span><span class="n">small_vector</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">o</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">o</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">std</span><span class="o">::</span><span class="n">equal</span><span class="p">(</span><span class="n">begin</span><span class="p">(),</span> <span class="n">end</span><span class="p">(),</span> <span class="n">o</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="n">bool</span> <span class="n">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="n">small_vector</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">o</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">lexicographical_compare</span><span class="p">(</span><span class="n">begin</span><span class="p">(),</span> <span class="n">end</span><span class="p">(),</span> <span class="n">o</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">o</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="n">size_type</span> <span class="n">max_size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">!</span><span class="n">BaseType</span><span class="o">::</span><span class="n">kShouldUseHeap</span> <span class="o">?</span> <span class="n">MaxInline</span>
                                     <span class="o">:</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">policyMaxSize</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">size_type</span> <span class="n">size</span><span class="p">()</span>         <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">doSize</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">bool</span>      <span class="n">empty</span><span class="p">()</span>        <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">!</span><span class="n">size</span><span class="p">();</span> <span class="p">}</span>

  <span class="n">iterator</span>       <span class="n">begin</span><span class="p">()</span>         <span class="p">{</span> <span class="k">return</span> <span class="n">data</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">iterator</span>       <span class="n">end</span><span class="p">()</span>           <span class="p">{</span> <span class="k">return</span> <span class="n">data</span><span class="p">()</span> <span class="o">+</span> <span class="n">size</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">const_iterator</span> <span class="n">begin</span><span class="p">()</span>   <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">data</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">const_iterator</span> <span class="n">end</span><span class="p">()</span>     <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">data</span><span class="p">()</span> <span class="o">+</span> <span class="n">size</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">const_iterator</span> <span class="n">cbegin</span><span class="p">()</span>  <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">begin</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">const_iterator</span> <span class="n">cend</span><span class="p">()</span>    <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">end</span><span class="p">();</span> <span class="p">}</span>

  <span class="n">reverse_iterator</span>       <span class="n">rbegin</span><span class="p">()</span>        <span class="p">{</span> <span class="k">return</span> <span class="n">reverse_iterator</span><span class="p">(</span><span class="n">end</span><span class="p">());</span> <span class="p">}</span>
  <span class="n">reverse_iterator</span>       <span class="n">rend</span><span class="p">()</span>          <span class="p">{</span> <span class="k">return</span> <span class="n">reverse_iterator</span><span class="p">(</span><span class="n">begin</span><span class="p">());</span> <span class="p">}</span>

  <span class="n">const_reverse_iterator</span> <span class="n">rbegin</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">const_reverse_iterator</span><span class="p">(</span><span class="n">end</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="n">const_reverse_iterator</span> <span class="n">rend</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">const_reverse_iterator</span><span class="p">(</span><span class="n">begin</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="n">const_reverse_iterator</span> <span class="n">crbegin</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">rbegin</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">const_reverse_iterator</span> <span class="n">crend</span><span class="p">()</span>   <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">rend</span><span class="p">();</span> <span class="p">}</span>

  <span class="cm">/*</span>
<span class="cm">   * Usually one of the simplest functions in a Container-like class</span>
<span class="cm">   * but a bit more complex here.  We have to handle all combinations</span>
<span class="cm">   * of in-place vs. heap between this and o.</span>
<span class="cm">   *</span>
<span class="cm">   * Basic guarantee only.  Provides the nothrow guarantee iff our</span>
<span class="cm">   * value_type has a nothrow move or copy constructor.</span>
<span class="cm">   */</span>
  <span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">small_vector</span><span class="o">&amp;</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">using</span> <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">;</span> <span class="c1">// Allow ADL on swap for our value_type.</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">isExtern</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">o</span><span class="p">.</span><span class="n">isExtern</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">this</span><span class="o">-&gt;</span><span class="n">swapSizePolicy</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>

      <span class="k">auto</span> <span class="n">thisCapacity</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">();</span>
      <span class="k">auto</span> <span class="n">oCapacity</span> <span class="o">=</span> <span class="n">o</span><span class="p">.</span><span class="n">capacity</span><span class="p">();</span>

      <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">unpackHack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">u</span><span class="p">.</span><span class="n">pdata_</span><span class="p">.</span><span class="n">heap_</span><span class="p">),</span> <span class="n">unpackHack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">o</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">pdata_</span><span class="p">.</span><span class="n">heap_</span><span class="p">));</span>

      <span class="n">this</span><span class="o">-&gt;</span><span class="n">setCapacity</span><span class="p">(</span><span class="n">oCapacity</span><span class="p">);</span>
      <span class="n">o</span><span class="p">.</span><span class="n">setCapacity</span><span class="p">(</span><span class="n">thisCapacity</span><span class="p">);</span>

      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">isExtern</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">o</span><span class="p">.</span><span class="n">isExtern</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">auto</span><span class="o">&amp;</span> <span class="n">oldSmall</span> <span class="o">=</span> <span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">o</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">?</span> <span class="o">*</span><span class="n">this</span> <span class="o">:</span> <span class="n">o</span><span class="p">;</span>
      <span class="k">auto</span><span class="o">&amp;</span> <span class="n">oldLarge</span> <span class="o">=</span> <span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">o</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">?</span> <span class="n">o</span> <span class="o">:</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span>

      <span class="k">for</span> <span class="p">(</span><span class="n">size_type</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">oldSmall</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">swap</span><span class="p">(</span><span class="n">oldSmall</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">oldLarge</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
      <span class="p">}</span>

      <span class="n">size_type</span> <span class="n">i</span> <span class="o">=</span> <span class="n">oldSmall</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
      <span class="n">try</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">oldLarge</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">new</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">oldSmall</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">oldLarge</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
          <span class="n">oldLarge</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="o">~</span><span class="n">value_type</span><span class="p">();</span>
        <span class="p">}</span>
      <span class="p">}</span> <span class="n">catch</span> <span class="p">(...)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">oldLarge</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">oldLarge</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="o">~</span><span class="n">value_type</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="n">oldLarge</span><span class="p">.</span><span class="n">setSize</span><span class="p">(</span><span class="n">oldSmall</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
        <span class="n">throw</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">this</span><span class="o">-&gt;</span><span class="n">swapSizePolicy</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span></pre></div></td></tr>


<tr id="section-13"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-13">&#182;</a></div><p>isExtern != o.isExtern()</p></td><td class="code"><div class="highlight"><pre>    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">oldExtern</span> <span class="o">=</span> <span class="n">o</span><span class="p">.</span><span class="n">isExtern</span><span class="p">()</span> <span class="o">?</span> <span class="n">o</span> <span class="o">:</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span>
    <span class="k">auto</span><span class="o">&amp;</span> <span class="n">oldIntern</span> <span class="o">=</span> <span class="n">o</span><span class="p">.</span><span class="n">isExtern</span><span class="p">()</span> <span class="o">?</span> <span class="o">*</span><span class="n">this</span> <span class="o">:</span> <span class="n">o</span><span class="p">;</span>

    <span class="k">auto</span> <span class="n">oldExternCapacity</span> <span class="o">=</span> <span class="n">oldExtern</span><span class="p">.</span><span class="n">capacity</span><span class="p">();</span>
    <span class="k">auto</span> <span class="n">oldExternHeap</span>     <span class="o">=</span> <span class="n">oldExtern</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">pdata_</span><span class="p">.</span><span class="n">heap_</span><span class="p">;</span>

    <span class="k">auto</span> <span class="n">buff</span> <span class="o">=</span> <span class="n">oldExtern</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">buffer</span><span class="p">();</span>
    <span class="n">size_type</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">try</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">oldIntern</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">new</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">buff</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">oldIntern</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
        <span class="n">oldIntern</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="o">~</span><span class="n">value_type</span><span class="p">();</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="n">catch</span> <span class="p">(...)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">size_type</span> <span class="n">kill</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">kill</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="o">++</span><span class="n">kill</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">buff</span><span class="p">[</span><span class="n">kill</span><span class="p">].</span><span class="o">~</span><span class="n">value_type</span><span class="p">();</span>
      <span class="p">}</span>
      <span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">oldIntern</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">oldIntern</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="o">~</span><span class="n">value_type</span><span class="p">();</span>
      <span class="p">}</span>
      <span class="n">oldIntern</span><span class="p">.</span><span class="n">setSize</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
      <span class="n">oldExtern</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">pdata_</span><span class="p">.</span><span class="n">heap_</span> <span class="o">=</span> <span class="n">oldExternHeap</span><span class="p">;</span>
      <span class="n">oldExtern</span><span class="p">.</span><span class="n">setCapacity</span><span class="p">(</span><span class="n">oldExternCapacity</span><span class="p">);</span>
      <span class="n">throw</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">oldIntern</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">pdata_</span><span class="p">.</span><span class="n">heap_</span> <span class="o">=</span> <span class="n">oldExternHeap</span><span class="p">;</span>
    <span class="n">this</span><span class="o">-&gt;</span><span class="n">swapSizePolicy</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
    <span class="n">oldIntern</span><span class="p">.</span><span class="n">setCapacity</span><span class="p">(</span><span class="n">oldExternCapacity</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">resize</span><span class="p">(</span><span class="n">size_type</span> <span class="n">sz</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sz</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">erase</span><span class="p">(</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">sz</span><span class="p">,</span> <span class="n">end</span><span class="p">());</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">makeSize</span><span class="p">(</span><span class="n">sz</span><span class="p">);</span>
    <span class="n">detail</span><span class="o">::</span><span class="n">populateMemForward</span><span class="p">(</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">size</span><span class="p">(),</span> <span class="n">sz</span> <span class="o">-</span> <span class="n">size</span><span class="p">(),</span>
      <span class="p">[</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span> <span class="n">new</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="n">value_type</span><span class="p">();</span> <span class="p">}</span>
    <span class="p">);</span>
    <span class="n">this</span><span class="o">-&gt;</span><span class="n">setSize</span><span class="p">(</span><span class="n">sz</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">resize</span><span class="p">(</span><span class="n">size_type</span> <span class="n">sz</span><span class="p">,</span> <span class="n">value_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sz</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">erase</span><span class="p">(</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">sz</span><span class="p">,</span> <span class="n">end</span><span class="p">());</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">makeSize</span><span class="p">(</span><span class="n">sz</span><span class="p">);</span>
    <span class="n">detail</span><span class="o">::</span><span class="n">populateMemForward</span><span class="p">(</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">size</span><span class="p">(),</span> <span class="n">sz</span> <span class="o">-</span> <span class="n">size</span><span class="p">(),</span>
      <span class="p">[</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span> <span class="n">new</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="n">value_type</span><span class="p">(</span><span class="n">v</span><span class="p">);</span> <span class="p">}</span>
    <span class="p">);</span>
    <span class="n">this</span><span class="o">-&gt;</span><span class="n">setSize</span><span class="p">(</span><span class="n">sz</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">value_type</span><span class="o">*</span> <span class="n">data</span><span class="p">()</span> <span class="n">noexcept</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">isExtern</span><span class="p">()</span> <span class="o">?</span> <span class="n">u</span><span class="p">.</span><span class="n">heap</span><span class="p">()</span> <span class="o">:</span> <span class="n">u</span><span class="p">.</span><span class="n">buffer</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">value_type</span> <span class="k">const</span><span class="o">*</span> <span class="n">data</span><span class="p">()</span> <span class="k">const</span> <span class="n">noexcept</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">isExtern</span><span class="p">()</span> <span class="o">?</span> <span class="n">u</span><span class="p">.</span><span class="n">heap</span><span class="p">()</span> <span class="o">:</span> <span class="n">u</span><span class="p">.</span><span class="n">buffer</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="p">...</span><span class="n">Args</span><span class="o">&gt;</span>
  <span class="n">iterator</span> <span class="n">emplace</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">p</span><span class="p">,</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">cend</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">emplace_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
      <span class="k">return</span> <span class="n">end</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/*</span>
<span class="cm">     * We implement emplace at places other than at the back with a</span>
<span class="cm">     * temporary for exception safety reasons.  It is possible to</span>
<span class="cm">     * avoid having to do this, but it becomes hard to maintain the</span>
<span class="cm">     * basic exception safety guarantee (unless you respond to a copy</span>
<span class="cm">     * constructor throwing by clearing the whole vector).</span>
<span class="cm">     *</span>
<span class="cm">     * The reason for this is that otherwise you have to destruct an</span>
<span class="cm">     * element before constructing this one in its place---if the</span>
<span class="cm">     * constructor throws, you either need a nothrow default</span>
<span class="cm">     * constructor or a nothrow copy/move to get something back in the</span>
<span class="cm">     * &quot;gap&quot;, and the vector requirements don&#39;t guarantee we have any</span>
<span class="cm">     * of these.  Clearing the whole vector is a legal response in</span>
<span class="cm">     * this situation, but it seems like this implementation is easy</span>
<span class="cm">     * enough and probably better.</span>
<span class="cm">     */</span>
    <span class="k">return</span> <span class="n">insert</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...));</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">reserve</span><span class="p">(</span><span class="n">size_type</span> <span class="n">sz</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">makeSize</span><span class="p">(</span><span class="n">sz</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">size_type</span> <span class="n">capacity</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">isExtern</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="n">hasCapacity</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">*</span><span class="n">u</span><span class="p">.</span><span class="n">getCapacity</span><span class="p">();</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="n">malloc_usable_size</span><span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="n">pdata_</span><span class="p">.</span><span class="n">heap_</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value_type</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">MaxInline</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">shrink_to_fit</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">isExtern</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">small_vector</span> <span class="n">tmp</span><span class="p">(</span><span class="n">begin</span><span class="p">(),</span> <span class="n">end</span><span class="p">());</span>
    <span class="n">tmp</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="n">this</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="p">...</span><span class="n">Args</span><span class="o">&gt;</span>
  <span class="kt">void</span> <span class="n">emplace_back</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-14"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-14">&#182;</a></div><p>call helper function for static dispatch of special cases</p></td><td class="code"><div class="highlight"><pre>    <span class="n">emplaceBack</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">push_back</span><span class="p">(</span><span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">capacity</span><span class="p">()</span> <span class="o">==</span> <span class="n">size</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">makeSize</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">size_type</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">size</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="n">size</span><span class="p">());</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">new</span> <span class="p">(</span><span class="n">end</span><span class="p">())</span> <span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">t</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="n">this</span><span class="o">-&gt;</span><span class="n">setSize</span><span class="p">(</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">push_back</span><span class="p">(</span><span class="n">value_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-15"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-15">&#182;</a></div><p>Make a copy and forward to the rvalue value_type&amp;&amp; overload
above.</p></td><td class="code"><div class="highlight"><pre>    <span class="n">push_back</span><span class="p">(</span><span class="n">value_type</span><span class="p">(</span><span class="n">t</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">pop_back</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">erase</span><span class="p">(</span><span class="n">end</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">iterator</span> <span class="n">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">constp</span><span class="p">,</span> <span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">iterator</span> <span class="n">p</span> <span class="o">=</span> <span class="n">unconst</span><span class="p">(</span><span class="n">constp</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">end</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">t</span><span class="p">));</span>
      <span class="k">return</span> <span class="n">end</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">auto</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="n">begin</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">capacity</span><span class="p">()</span> <span class="o">==</span> <span class="n">size</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">makeSize</span><span class="p">(</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
      <span class="n">this</span><span class="o">-&gt;</span><span class="n">setSize</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">makeSize</span><span class="p">(</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
      <span class="n">detail</span><span class="o">::</span><span class="n">moveObjectsRight</span><span class="p">(</span><span class="n">data</span><span class="p">()</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span>
                               <span class="n">data</span><span class="p">()</span> <span class="o">+</span> <span class="n">size</span><span class="p">(),</span>
                               <span class="n">data</span><span class="p">()</span> <span class="o">+</span> <span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
      <span class="n">this</span><span class="o">-&gt;</span><span class="n">setSize</span><span class="p">(</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
      <span class="n">data</span><span class="p">()[</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>

  <span class="p">}</span>

  <span class="n">iterator</span> <span class="n">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">p</span><span class="p">,</span> <span class="n">value_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-16"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-16">&#182;</a></div><p>Make a copy and forward to the rvalue value_type&amp;&amp; overload
above.</p></td><td class="code"><div class="highlight"><pre>    <span class="k">return</span> <span class="n">insert</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">value_type</span><span class="p">(</span><span class="n">t</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="n">iterator</span> <span class="n">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">pos</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="n">value_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="n">begin</span><span class="p">();</span>
    <span class="n">makeSize</span><span class="p">(</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="n">n</span><span class="p">);</span>
    <span class="n">detail</span><span class="o">::</span><span class="n">moveObjectsRight</span><span class="p">(</span><span class="n">data</span><span class="p">()</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span>
                             <span class="n">data</span><span class="p">()</span> <span class="o">+</span> <span class="n">size</span><span class="p">(),</span>
                             <span class="n">data</span><span class="p">()</span> <span class="o">+</span> <span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="n">n</span><span class="p">);</span>
    <span class="n">this</span><span class="o">-&gt;</span><span class="n">setSize</span><span class="p">(</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="n">n</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">generate_n</span><span class="p">(</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">{</span> <span class="k">return</span> <span class="n">val</span><span class="p">;</span> <span class="p">});</span>
    <span class="k">return</span> <span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Arg</span><span class="o">&gt;</span>
  <span class="n">iterator</span> <span class="n">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">p</span><span class="p">,</span> <span class="n">Arg</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">Arg</span> <span class="n">arg2</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-17"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-17">&#182;</a></div><p>Forward using std::is<em>arithmetic to get to the proper
implementation; this disambiguates between the iterators and
(size</em>t, value_type) meaning for this function.</p></td><td class="code"><div class="highlight"><pre>    <span class="k">return</span> <span class="n">insertImpl</span><span class="p">(</span><span class="n">unconst</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">is_arithmetic</span><span class="o">&lt;</span><span class="n">Arg</span><span class="o">&gt;</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="n">iterator</span> <span class="n">insert</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">insert</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">il</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">il</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="n">iterator</span> <span class="n">erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">unconst</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="p">(),</span> <span class="n">unconst</span><span class="p">(</span><span class="n">q</span><span class="p">));</span>
    <span class="p">(</span><span class="n">data</span><span class="p">()</span> <span class="o">+</span> <span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">-&gt;~</span><span class="n">value_type</span><span class="p">();</span>
    <span class="n">this</span><span class="o">-&gt;</span><span class="n">setSize</span><span class="p">(</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">unconst</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">iterator</span> <span class="n">erase</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">q1</span><span class="p">,</span> <span class="n">const_iterator</span> <span class="n">q2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">unconst</span><span class="p">(</span><span class="n">q2</span><span class="p">),</span> <span class="n">end</span><span class="p">(),</span> <span class="n">unconst</span><span class="p">(</span><span class="n">q1</span><span class="p">));</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">q1</span><span class="p">;</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">it</span><span class="o">-&gt;~</span><span class="n">value_type</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">this</span><span class="o">-&gt;</span><span class="n">setSize</span><span class="p">(</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="p">(</span><span class="n">q2</span> <span class="o">-</span> <span class="n">q1</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">unconst</span><span class="p">(</span><span class="n">q1</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">clear</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">erase</span><span class="p">(</span><span class="n">begin</span><span class="p">(),</span> <span class="n">end</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Arg</span><span class="o">&gt;</span>
  <span class="kt">void</span> <span class="n">assign</span><span class="p">(</span><span class="n">Arg</span> <span class="n">first</span><span class="p">,</span> <span class="n">Arg</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">clear</span><span class="p">();</span>
    <span class="n">insert</span><span class="p">(</span><span class="n">end</span><span class="p">(),</span> <span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">assign</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">assign</span><span class="p">(</span><span class="n">il</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">il</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">assign</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">clear</span><span class="p">();</span>
    <span class="n">insert</span><span class="p">(</span><span class="n">end</span><span class="p">(),</span> <span class="n">n</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">reference</span> <span class="n">front</span><span class="p">()</span>             <span class="p">{</span> <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">empty</span><span class="p">());</span> <span class="k">return</span> <span class="o">*</span><span class="n">begin</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">reference</span> <span class="n">back</span><span class="p">()</span>              <span class="p">{</span> <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">empty</span><span class="p">());</span> <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="n">end</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="p">}</span>
  <span class="n">const_reference</span> <span class="n">front</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">empty</span><span class="p">());</span> <span class="k">return</span> <span class="o">*</span><span class="n">begin</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">const_reference</span> <span class="n">back</span><span class="p">()</span> <span class="k">const</span>  <span class="p">{</span> <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">empty</span><span class="p">());</span> <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="n">end</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="p">}</span>

  <span class="n">reference</span> <span class="n">operator</span><span class="p">[](</span><span class="n">size_type</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">());</span>
    <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">const_reference</span> <span class="n">operator</span><span class="p">[](</span><span class="n">size_type</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">());</span>
    <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">reference</span> <span class="n">at</span><span class="p">(</span><span class="n">size_type</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">out_of_range</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">this</span><span class="p">)[</span><span class="n">i</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="n">const_reference</span> <span class="n">at</span><span class="p">(</span><span class="n">size_type</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">out_of_range</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">this</span><span class="p">)[</span><span class="n">i</span><span class="p">];</span>
  <span class="p">}</span>

<span class="nl">private:</span>

  <span class="cm">/*</span>
<span class="cm">   * This is doing the same like emplace_back, but we need this helper</span>
<span class="cm">   * to catch the special case - see the next overload function..</span>
<span class="cm">   */</span>
  <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="p">...</span><span class="n">Args</span><span class="o">&gt;</span>
  <span class="kt">void</span> <span class="n">emplaceBack</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">makeSize</span><span class="p">(</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">new</span> <span class="p">(</span><span class="n">end</span><span class="p">())</span> <span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
    <span class="n">this</span><span class="o">-&gt;</span><span class="n">setSize</span><span class="p">(</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="cm">/*</span>
<span class="cm">   * Special case of emplaceBack for rvalue</span>
<span class="cm">   */</span>
  <span class="kt">void</span> <span class="n">emplaceBack</span><span class="p">(</span><span class="n">value_type</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">t</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="k">static</span> <span class="n">iterator</span> <span class="n">unconst</span><span class="p">(</span><span class="n">const_iterator</span> <span class="n">it</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">const_cast</span><span class="o">&lt;</span><span class="n">iterator</span><span class="o">&gt;</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="cm">/*</span>
<span class="cm">   * g++ doesn&#39;t allow you to bind a non-const reference to a member</span>
<span class="cm">   * of a packed structure, presumably because it would make it too</span>
<span class="cm">   * easy to accidentally make an unaligned memory access?</span>
<span class="cm">   */</span>
  <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">static</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">unpackHack</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
  <span class="p">}</span></pre></div></td></tr>


<tr id="section-18"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-18">&#182;</a></div><p>The std::false_type argument is part of disambiguating the
iterator insert functions from integral types (see insert().)</p></td><td class="code"><div class="highlight"><pre>  <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">It</span><span class="o">&gt;</span>
  <span class="n">iterator</span> <span class="n">insertImpl</span><span class="p">(</span><span class="n">iterator</span> <span class="n">pos</span><span class="p">,</span> <span class="n">It</span> <span class="n">first</span><span class="p">,</span> <span class="n">It</span> <span class="n">last</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">false_type</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">typedef</span> <span class="kr">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">It</span><span class="o">&gt;::</span><span class="n">iterator_category</span> <span class="n">categ</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">categ</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">input_iterator_tag</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">auto</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="n">begin</span><span class="p">();</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">first</span> <span class="o">!=</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="o">*</span><span class="n">first</span><span class="o">++</span><span class="p">);</span>
        <span class="o">++</span><span class="n">pos</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">auto</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="n">begin</span><span class="p">();</span>
    <span class="n">makeSize</span><span class="p">(</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="n">distance</span><span class="p">);</span>
    <span class="n">detail</span><span class="o">::</span><span class="n">moveObjectsRight</span><span class="p">(</span><span class="n">data</span><span class="p">()</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span>
                             <span class="n">data</span><span class="p">()</span> <span class="o">+</span> <span class="n">size</span><span class="p">(),</span>
                             <span class="n">data</span><span class="p">()</span> <span class="o">+</span> <span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="n">distance</span><span class="p">);</span>
    <span class="n">this</span><span class="o">-&gt;</span><span class="n">setSize</span><span class="p">(</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="n">distance</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">copy_n</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">iterator</span> <span class="n">insertImpl</span><span class="p">(</span><span class="n">iterator</span> <span class="n">pos</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span>
      <span class="n">std</span><span class="o">::</span><span class="n">true_type</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-19"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-19">&#182;</a></div><p>The true<em>type means this should call the size</em>t,value_type
overload.  (See insert().)</p></td><td class="code"><div class="highlight"><pre>    <span class="k">return</span> <span class="n">insert</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
  <span class="p">}</span></pre></div></td></tr>


<tr id="section-20"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-20">&#182;</a></div><p>The std::false<em>type argument came from std::is</em>arithmetic as part
of disambiguating an overload (see the comment in the
constructor).</p></td><td class="code"><div class="highlight"><pre>  <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">It</span><span class="o">&gt;</span>
  <span class="kt">void</span> <span class="n">constructImpl</span><span class="p">(</span><span class="n">It</span> <span class="n">first</span><span class="p">,</span> <span class="n">It</span> <span class="n">last</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">false_type</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">typedef</span> <span class="kr">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span><span class="n">It</span><span class="o">&gt;::</span><span class="n">iterator_category</span> <span class="n">categ</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span><span class="n">categ</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">input_iterator_tag</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-21"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-21">&#182;</a></div><p>With iterators that only allow a single pass, we can't really
do anything sane here.</p></td><td class="code"><div class="highlight"><pre>      <span class="k">while</span> <span class="p">(</span><span class="n">first</span> <span class="o">!=</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">push_back</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="o">++</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">auto</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
    <span class="n">makeSize</span><span class="p">(</span><span class="n">distance</span><span class="p">);</span>
    <span class="n">this</span><span class="o">-&gt;</span><span class="n">setSize</span><span class="p">(</span><span class="n">distance</span><span class="p">);</span>

    <span class="n">detail</span><span class="o">::</span><span class="n">populateMemForward</span><span class="p">(</span><span class="n">data</span><span class="p">(),</span> <span class="n">distance</span><span class="p">,</span>
      <span class="p">[</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span> <span class="n">new</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="n">value_type</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="o">++</span><span class="p">);</span> <span class="p">}</span>
    <span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">doConstruct</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="n">value_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">makeSize</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="n">this</span><span class="o">-&gt;</span><span class="n">setSize</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="n">detail</span><span class="o">::</span><span class="n">populateMemForward</span><span class="p">(</span><span class="n">data</span><span class="p">(),</span> <span class="n">n</span><span class="p">,</span>
      <span class="p">[</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span> <span class="n">new</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="n">value_type</span><span class="p">(</span><span class="n">val</span><span class="p">);</span> <span class="p">}</span>
    <span class="p">);</span>
  <span class="p">}</span></pre></div></td></tr>


<tr id="section-22"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-22">&#182;</a></div><p>The true<em>type means we should forward to the size</em>t,value_type
overload.</p></td><td class="code"><div class="highlight"><pre>  <span class="kt">void</span> <span class="n">constructImpl</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="n">value_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">true_type</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">doConstruct</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">makeSize</span><span class="p">(</span><span class="n">size_type</span> <span class="n">size</span><span class="p">,</span> <span class="n">value_type</span><span class="o">*</span> <span class="n">v</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">makeSize</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="cm">/*</span>
<span class="cm">   * Ensure we have a large enough memory region to be size `size&#39;.</span>
<span class="cm">   * Will move/copy elements if we are spilling to heap_ or needed to</span>
<span class="cm">   * allocate a new region, but if resized in place doesn&#39;t initialize</span>
<span class="cm">   * anything in the new region.  In any case doesn&#39;t change size().</span>
<span class="cm">   * Supports insertion of new element during reallocation by given</span>
<span class="cm">   * pointer to new element and position of new element.</span>
<span class="cm">   * NOTE: If reallocation is not needed, and new element should be</span>
<span class="cm">   * inserted in the middle of vector (not at the end), do the move</span>
<span class="cm">   * objects and insertion outside the function, otherwise exception is thrown.</span>
<span class="cm">   */</span>
  <span class="kt">void</span> <span class="n">makeSize</span><span class="p">(</span><span class="n">size_type</span> <span class="n">size</span><span class="p">,</span> <span class="n">value_type</span><span class="o">*</span> <span class="n">v</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">pos</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">max_size</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">length_error</span><span class="p">(</span><span class="s">&quot;max_size exceeded in small_vector&quot;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">auto</span> <span class="n">needBytes</span> <span class="o">=</span> <span class="n">size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value_type</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-23"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-23">&#182;</a></div><p>If the capacity isn't explicitly stored inline, but the heap
allocation is grown to over some threshold, we should store
a capacity at the front of the heap allocation.</p></td><td class="code"><div class="highlight"><pre>    <span class="n">bool</span> <span class="n">heapifyCapacity</span> <span class="o">=</span>
      <span class="o">!</span><span class="n">kHasInlineCapacity</span> <span class="o">&amp;&amp;</span> <span class="n">needBytes</span> <span class="o">&gt;</span> <span class="n">kHeapifyCapacityThreshold</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">heapifyCapacity</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">needBytes</span> <span class="o">+=</span> <span class="n">kHeapifyCapacitySize</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">auto</span> <span class="k">const</span> <span class="n">sizeBytes</span> <span class="o">=</span> <span class="n">goodMallocSize</span><span class="p">(</span><span class="n">needBytes</span><span class="p">);</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">newh</span> <span class="o">=</span> <span class="n">checkedMalloc</span><span class="p">(</span><span class="n">sizeBytes</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-24"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-24">&#182;</a></div><p>We expect newh to be at least 2-aligned, because we want to
use its least significant bit as a flag.</p></td><td class="code"><div class="highlight"><pre>    <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">detail</span><span class="o">::</span><span class="n">pointerFlagGet</span><span class="p">(</span><span class="n">newh</span><span class="p">));</span>

    <span class="n">value_type</span><span class="o">*</span> <span class="n">newp</span> <span class="o">=</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">*&gt;</span><span class="p">(</span>
      <span class="n">heapifyCapacity</span> <span class="o">?</span>
        <span class="n">detail</span><span class="o">::</span><span class="n">shiftPointer</span><span class="p">(</span><span class="n">newh</span><span class="p">,</span> <span class="n">kHeapifyCapacitySize</span><span class="p">)</span> <span class="o">:</span>
        <span class="n">newh</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-25"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-25">&#182;</a></div><p>move new element</p></td><td class="code"><div class="highlight"><pre>      <span class="n">try</span> <span class="p">{</span>
        <span class="n">new</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">newp</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span> <span class="n">value_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="o">*</span><span class="n">v</span><span class="p">));</span>
      <span class="p">}</span> <span class="n">catch</span> <span class="p">(...)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">free</span><span class="p">(</span><span class="n">newh</span><span class="p">);</span>
        <span class="n">throw</span><span class="p">;</span>
      <span class="p">}</span></pre></div></td></tr>


<tr id="section-26"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-26">&#182;</a></div><p>move old elements to the left of the new one</p></td><td class="code"><div class="highlight"><pre>      <span class="n">try</span> <span class="p">{</span>
        <span class="n">detail</span><span class="o">::</span><span class="n">moveToUninitialized</span><span class="p">(</span><span class="n">begin</span><span class="p">(),</span> <span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="n">newp</span><span class="p">);</span>
      <span class="p">}</span> <span class="n">catch</span> <span class="p">(...)</span> <span class="p">{</span>
        <span class="n">newp</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="o">~</span><span class="n">value_type</span><span class="p">();</span>
        <span class="n">std</span><span class="o">::</span><span class="n">free</span><span class="p">(</span><span class="n">newh</span><span class="p">);</span>
        <span class="n">throw</span><span class="p">;</span>
      <span class="p">}</span></pre></div></td></tr>


<tr id="section-27"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-27">&#182;</a></div><p>move old elements to the right of the new one</p></td><td class="code"><div class="highlight"><pre>      <span class="n">try</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">detail</span><span class="o">::</span><span class="n">moveToUninitialized</span><span class="p">(</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="n">end</span><span class="p">(),</span> <span class="n">newp</span> <span class="o">+</span> <span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span> <span class="n">catch</span> <span class="p">(...)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">size_type</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">pos</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">newp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="o">~</span><span class="n">value_type</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="n">std</span><span class="o">::</span><span class="n">free</span><span class="p">(</span><span class="n">newh</span><span class="p">);</span>
        <span class="n">throw</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-28"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-28">&#182;</a></div><p>move without inserting new element</p></td><td class="code"><div class="highlight"><pre>      <span class="n">try</span> <span class="p">{</span>
        <span class="n">detail</span><span class="o">::</span><span class="n">moveToUninitialized</span><span class="p">(</span><span class="n">begin</span><span class="p">(),</span> <span class="n">end</span><span class="p">(),</span> <span class="n">newp</span><span class="p">);</span>
      <span class="p">}</span> <span class="n">catch</span> <span class="p">(...)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">free</span><span class="p">(</span><span class="n">newh</span><span class="p">);</span>
        <span class="n">throw</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">val</span> <span class="o">:</span> <span class="o">*</span><span class="n">this</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">val</span><span class="p">.</span><span class="o">~</span><span class="n">value_type</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">isExtern</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">u</span><span class="p">.</span><span class="n">freeHeap</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">auto</span> <span class="n">availableSizeBytes</span> <span class="o">=</span> <span class="n">sizeBytes</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">heapifyCapacity</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">u</span><span class="p">.</span><span class="n">pdata_</span><span class="p">.</span><span class="n">heap_</span> <span class="o">=</span> <span class="n">detail</span><span class="o">::</span><span class="n">pointerFlagSet</span><span class="p">(</span><span class="n">newh</span><span class="p">);</span>
      <span class="n">availableSizeBytes</span> <span class="o">-=</span> <span class="n">kHeapifyCapacitySize</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">u</span><span class="p">.</span><span class="n">pdata_</span><span class="p">.</span><span class="n">heap_</span> <span class="o">=</span> <span class="n">newh</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">this</span><span class="o">-&gt;</span><span class="n">setExtern</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
    <span class="n">this</span><span class="o">-&gt;</span><span class="n">setCapacity</span><span class="p">(</span><span class="n">availableSizeBytes</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">value_type</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="cm">/*</span>
<span class="cm">   * This will set the capacity field, stored inline in the storage_ field</span>
<span class="cm">   * if there is sufficient room to store it.</span>
<span class="cm">   */</span>
  <span class="kt">void</span> <span class="n">setCapacity</span><span class="p">(</span><span class="n">size_type</span> <span class="n">newCapacity</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">isExtern</span><span class="p">());</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="n">hasCapacity</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">newCapacity</span> <span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">InternalSizeType</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">());</span>
      <span class="o">*</span><span class="n">u</span><span class="p">.</span><span class="n">getCapacity</span><span class="p">()</span> <span class="o">=</span> <span class="n">InternalSizeType</span><span class="p">(</span><span class="n">newCapacity</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

<span class="nl">private:</span>
  <span class="k">struct</span> <span class="n">HeapPtrWithCapacity</span> <span class="p">{</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">heap_</span><span class="p">;</span>
    <span class="n">InternalSizeType</span> <span class="n">capacity_</span><span class="p">;</span>

    <span class="n">InternalSizeType</span><span class="o">*</span> <span class="nf">getCapacity</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">&amp;</span><span class="n">capacity_</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="n">FB_PACKED</span><span class="p">;</span>

  <span class="k">struct</span> <span class="n">HeapPtr</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-29"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-29">&#182;</a></div><p>Lower order bit of heap_ is used as flag to indicate whether capacity is
stored at the front of the heap allocation.</p></td><td class="code"><div class="highlight"><pre>    <span class="kt">void</span><span class="o">*</span> <span class="n">heap_</span><span class="p">;</span>

    <span class="n">InternalSizeType</span><span class="o">*</span> <span class="nf">getCapacity</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">detail</span><span class="o">::</span><span class="n">pointerFlagGet</span><span class="p">(</span><span class="n">heap_</span><span class="p">));</span>
      <span class="k">return</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="n">InternalSizeType</span><span class="o">*&gt;</span><span class="p">(</span>
        <span class="n">detail</span><span class="o">::</span><span class="n">pointerFlagClear</span><span class="p">(</span><span class="n">heap_</span><span class="p">));</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="n">FB_PACKED</span><span class="p">;</span>

<span class="cp">#if defined(__x86_64_)</span>
  <span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">InlineStorageType</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">value_type</span><span class="p">)</span> <span class="o">*</span> <span class="n">MaxInline</span><span class="p">];</span>
<span class="cp">#else</span>
  <span class="k">typedef</span> <span class="kr">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">aligned_storage</span><span class="o">&lt;</span>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">value_type</span><span class="p">)</span> <span class="o">*</span> <span class="n">MaxInline</span><span class="p">,</span>
    <span class="n">alignof</span><span class="p">(</span><span class="n">value_type</span><span class="p">)</span>
  <span class="o">&gt;::</span><span class="n">type</span> <span class="n">InlineStorageType</span><span class="p">;</span>
<span class="cp">#endif</span>

  <span class="k">static</span> <span class="n">bool</span> <span class="k">const</span> <span class="n">kHasInlineCapacity</span> <span class="o">=</span>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">HeapPtrWithCapacity</span><span class="p">)</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">InlineStorageType</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-30"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-30">&#182;</a></div><p>This value should we multiple of word size.</p></td><td class="code"><div class="highlight"><pre>  <span class="k">static</span> <span class="kt">size_t</span> <span class="k">const</span> <span class="n">kHeapifyCapacitySize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span>
    <span class="kr">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">aligned_storage</span><span class="o">&lt;</span>
      <span class="k">sizeof</span><span class="p">(</span><span class="n">InternalSizeType</span><span class="p">),</span>
      <span class="n">alignof</span><span class="p">(</span><span class="n">value_type</span><span class="p">)</span>
    <span class="o">&gt;::</span><span class="n">type</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-31"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-31">&#182;</a></div><p>Threshold to control capacity heapifying.</p></td><td class="code"><div class="highlight"><pre>  <span class="k">static</span> <span class="kt">size_t</span> <span class="k">const</span> <span class="n">kHeapifyCapacityThreshold</span> <span class="o">=</span>
    <span class="mi">100</span> <span class="o">*</span> <span class="n">kHeapifyCapacitySize</span><span class="p">;</span>

  <span class="k">typedef</span> <span class="kr">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">conditional</span><span class="o">&lt;</span>
    <span class="n">kHasInlineCapacity</span><span class="p">,</span>
    <span class="n">HeapPtrWithCapacity</span><span class="p">,</span>
    <span class="n">HeapPtr</span>
  <span class="o">&gt;::</span><span class="n">type</span> <span class="n">PointerType</span><span class="p">;</span>

  <span class="k">union</span> <span class="n">Data</span> <span class="p">{</span>
    <span class="n">explicit</span> <span class="n">Data</span><span class="p">()</span> <span class="p">{</span> <span class="n">pdata_</span><span class="p">.</span><span class="n">heap_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

    <span class="n">PointerType</span> <span class="n">pdata_</span><span class="p">;</span>
    <span class="n">InlineStorageType</span> <span class="n">storage_</span><span class="p">;</span>

    <span class="n">value_type</span><span class="o">*</span> <span class="n">buffer</span><span class="p">()</span> <span class="n">noexcept</span> <span class="p">{</span>
      <span class="kt">void</span><span class="o">*</span> <span class="n">vp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">storage_</span><span class="p">;</span>
      <span class="k">return</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">vp</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">value_type</span> <span class="k">const</span><span class="o">*</span> <span class="n">buffer</span><span class="p">()</span> <span class="k">const</span> <span class="n">noexcept</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">const_cast</span><span class="o">&lt;</span><span class="n">Data</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">this</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">value_type</span><span class="o">*</span> <span class="n">heap</span><span class="p">()</span> <span class="n">noexcept</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">kHasInlineCapacity</span> <span class="o">||</span> <span class="o">!</span><span class="n">detail</span><span class="o">::</span><span class="n">pointerFlagGet</span><span class="p">(</span><span class="n">pdata_</span><span class="p">.</span><span class="n">heap_</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">pdata_</span><span class="p">.</span><span class="n">heap_</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">*&gt;</span><span class="p">(</span>
        <span class="n">detail</span><span class="o">::</span><span class="n">shiftPointer</span><span class="p">(</span>
          <span class="n">detail</span><span class="o">::</span><span class="n">pointerFlagClear</span><span class="p">(</span><span class="n">pdata_</span><span class="p">.</span><span class="n">heap_</span><span class="p">),</span> <span class="n">kHeapifyCapacitySize</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="n">value_type</span> <span class="k">const</span><span class="o">*</span> <span class="n">heap</span><span class="p">()</span> <span class="k">const</span> <span class="n">noexcept</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">const_cast</span><span class="o">&lt;</span><span class="n">Data</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">this</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">heap</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">bool</span> <span class="n">hasCapacity</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">kHasInlineCapacity</span> <span class="o">||</span> <span class="n">detail</span><span class="o">::</span><span class="n">pointerFlagGet</span><span class="p">(</span><span class="n">pdata_</span><span class="p">.</span><span class="n">heap_</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">InternalSizeType</span><span class="o">*</span> <span class="n">getCapacity</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">pdata_</span><span class="p">.</span><span class="n">getCapacity</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">InternalSizeType</span><span class="o">*</span> <span class="n">getCapacity</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">const_cast</span><span class="o">&lt;</span><span class="n">Data</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">this</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">getCapacity</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">freeHeap</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">auto</span> <span class="n">vp</span> <span class="o">=</span> <span class="n">detail</span><span class="o">::</span><span class="n">pointerFlagClear</span><span class="p">(</span><span class="n">pdata_</span><span class="p">.</span><span class="n">heap_</span><span class="p">);</span>
      <span class="n">std</span><span class="o">::</span><span class="n">free</span><span class="p">(</span><span class="n">vp</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="n">FB_PACKED</span> <span class="n">u</span><span class="p">;</span>
<span class="p">}</span> <span class="n">FB_PACKED</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-32"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-32">&#182;</a></div><p>////////////////////////////////////////////////////////////////////</p></td><td class="code"><div class="highlight"><pre></pre></div></td></tr>


<tr id="section-33"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-33">&#182;</a></div><p>Basic guarantee only, or provides the nothrow guarantee iff T has a
nothrow move or copy constructor.</p></td><td class="code"><div class="highlight"><pre><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">MaxInline</span><span class="p">,</span> <span class="n">class</span> <span class="n">A</span><span class="p">,</span> <span class="n">class</span> <span class="n">B</span><span class="p">,</span> <span class="n">class</span> <span class="n">C</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">small_vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">MaxInline</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">C</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span>
          <span class="n">small_vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="n">MaxInline</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">C</span><span class="o">&gt;&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">a</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span></pre></div></td></tr>


<tr id="section-34"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-34">&#182;</a></div><p>////////////////////////////////////////////////////////////////////</p></td><td class="code"><div class="highlight"><pre><span class="p">}</span>

<span class="cp">#ifdef FB_PACKED</span>
<span class="cp"># undef FB_PACKED</span>
<span class="cp">#endif</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/folly",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
