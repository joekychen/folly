<h2><code>folly/small_vector.h</code></h2>

<p><code>folly::small_vector&lt;T,Int=1,...&gt;</code> is a sequence container that
implements small buffer optimization. It behaves similarly to
std::vector, except until a certain number of elements are reserved it
does not use the heap.</p>

<p>Like standard vector, it is guaranteed to use contiguous memory.  (So,
after it spills to the heap all the elements live in the heap buffer.)</p>

<p>Simple usage example:</p>

<p><code>Cpp
    small_vector&lt;int,2&gt; vec;
    vec.push_back(0); // Stored in-place on stack
    vec.push_back(1); // Still on the stack
    vec.push_back(2); // Switches to heap buffer.
</code></p>

<h3>Details</h3>

<hr />

<p>This class is useful in either of following cases:</p>

<ul>
<li><p>Short-lived stack vectors with few elements (or maybe with a
usually-known number of elements), if you want to avoid malloc.</p></li>
<li><p>If the vector(s) are usually under a known size and lookups are very
common, you'll save an extra cache miss in the common case when the
data is kept in-place.</p></li>
<li><p>You have billions of these vectors and don't want to waste space on
<code>std::vector</code>'s capacity tracking.  This vector lets <code>malloc</code> track our
allocation capacity.  (Note that this slows down the
insertion/reallocation code paths significantly; if you need those
to be fast you should use <code>fbvector</code>.)</p></li>
</ul>

<p>The last two cases were the main motivation for implementing it.</p>

<p>There are also a couple of flags you can pass into this class
template to customize its behavior.  You can provide them in any
order after the in-place count.  They are all in the <code>namespace
small_vector_policy</code>.</p>

<ul>
<li><p><code>NoHeap</code> - Avoid the heap entirely.  (Throws <code>std::length_error</code> if
you would've spilled out of the in-place allocation.)</p></li>
<li><p><code>OneBitMutex</code> - On x64 platforms, this spends one bit of the
<code>size_type</code> to provide a spin lock that you can use for whatever you
want.</p></li>
<li><p><code>&lt;Any integral type&gt;</code> - customizes the amount of space we spend on
tracking the size of the vector.</p></li>
</ul>

<p>A couple more examples:</p>

<p>``` Cpp
    // With space for 32 in situ unique pointers, and only using a
    // 4-byte size<em>type.
    small</em>vector<std::unique_ptr<int>, 32, uint32_t> v;</p>

<pre><code>// A inline vector of up to 256 ints which will not use the
// heap and comes with a spin lock.
small_vector&lt;int, 256, NoHeap, OneBitMutex&gt; v;

// Same as the above, but making the size_type smaller too.
small_vector&lt;int, 256, NoHeap, uint16_t, OneBitMutex&gt; v;
</code></pre>

<p>```</p>