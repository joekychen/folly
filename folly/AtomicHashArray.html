<!DOCTYPE html>
<html><head><title>joekychen/folly » folly › AtomicHashArray.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>AtomicHashArray.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2012 Facebook, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="cm"> * you may not use this file except in compliance with the License.</span>
<span class="cm"> * You may obtain a copy of the License at</span>
<span class="cm"> *</span>
<span class="cm"> *   http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="cm"> *</span>
<span class="cm"> * Unless required by applicable law or agreed to in writing, software</span>
<span class="cm"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="cm"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="cm"> * See the License for the specific language governing permissions and</span>
<span class="cm"> * limitations under the License.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> *  AtomicHashArray is the building block for AtomicHashMap.  It provides the</span>
<span class="cm"> *  core lock-free functionality, but is limitted by the fact that it cannot</span>
<span class="cm"> *  grow past it&#39;s initialization size and is a little more awkward (no public</span>
<span class="cm"> *  constructor, for example).  If you&#39;re confident that you won&#39;t run out of</span>
<span class="cm"> *  space, don&#39;t mind the awkardness, and really need bare-metal performance,</span>
<span class="cm"> *  feel free to use AHA directly.</span>
<span class="cm"> *</span>
<span class="cm"> *  Check out AtomicHashMap.h for more thorough documentation on perf and</span>
<span class="cm"> *  general pros and cons relative to other hash maps.</span>
<span class="cm"> *</span>
<span class="cm"> *  @author Spencer Ahrens &lt;sahrens@fb.com&gt;</span>
<span class="cm"> *  @author Jordan DeLong &lt;delong.j@fb.com&gt;</span>
<span class="cm"> */</span>

<span class="cp">#ifndef FOLLY_ATOMICHASHARRAY_H_</span>
<span class="cp">#define FOLLY_ATOMICHASHARRAY_H_</span>

<span class="cp">#include &lt;atomic&gt;</span>

<span class="cp">#include &lt;boost/iterator/iterator_facade.hpp&gt;</span>
<span class="cp">#include &lt;boost/noncopyable.hpp&gt;</span>

<span class="cp">#include &quot;folly/Hash.h&quot;</span>
<span class="cp">#include &quot;folly/ThreadCachedInt.h&quot;</span>

<span class="n">namespace</span> <span class="n">folly</span> <span class="p">{</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">KeyT</span><span class="p">,</span> <span class="n">class</span> <span class="n">ValueT</span><span class="p">,</span> <span class="n">class</span> <span class="n">HashFcn</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="n">KeyT</span><span class="o">&gt;&gt;</span>
<span class="n">class</span> <span class="n">AtomicHashMap</span><span class="p">;</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">KeyT</span><span class="p">,</span> <span class="n">class</span> <span class="n">ValueT</span><span class="p">,</span> <span class="n">class</span> <span class="n">HashFcn</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="n">KeyT</span><span class="o">&gt;&gt;</span>
<span class="n">class</span> <span class="n">AtomicHashArray</span> <span class="o">:</span> <span class="n">boost</span><span class="o">::</span><span class="n">noncopyable</span> <span class="p">{</span>
  <span class="n">static_assert</span><span class="p">((</span><span class="n">std</span><span class="o">::</span><span class="n">is_convertible</span><span class="o">&lt;</span><span class="n">KeyT</span><span class="p">,</span><span class="kt">int32_t</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">||</span>
                 <span class="n">std</span><span class="o">::</span><span class="n">is_convertible</span><span class="o">&lt;</span><span class="n">KeyT</span><span class="p">,</span><span class="kt">int64_t</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">),</span>
             <span class="s">&quot;You are trying to use AtomicHashArray with disallowed key &quot;</span>
             <span class="s">&quot;types.  You must use atomically compare-and-swappable integer &quot;</span>
             <span class="s">&quot;keys, or a different container class.&quot;</span><span class="p">);</span>
 <span class="nl">public:</span>
  <span class="k">typedef</span> <span class="n">KeyT</span>                <span class="n">key_type</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">ValueT</span>              <span class="n">mapped_type</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">KeyT</span><span class="p">,</span> <span class="n">ValueT</span><span class="o">&gt;</span> <span class="n">value_type</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span>         <span class="n">size_type</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="kt">ptrdiff_t</span>      <span class="n">difference_type</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">value_type</span><span class="o">&amp;</span>         <span class="n">reference</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span>   <span class="n">const_reference</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">value_type</span><span class="o">*</span>         <span class="n">pointer</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="k">const</span> <span class="n">value_type</span><span class="o">*</span>   <span class="n">const_pointer</span><span class="p">;</span>

  <span class="k">const</span> <span class="kt">size_t</span>  <span class="n">capacity_</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">size_t</span>  <span class="n">maxEntries_</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">KeyT</span>    <span class="n">kEmptyKey_</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">KeyT</span>    <span class="n">kLockedKey_</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">KeyT</span>    <span class="n">kErasedKey_</span><span class="p">;</span>

  <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">ContT</span><span class="p">,</span> <span class="n">class</span> <span class="n">IterVal</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="n">aha_iterator</span><span class="p">;</span>

  <span class="k">typedef</span> <span class="n">aha_iterator</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">AtomicHashArray</span><span class="p">,</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&gt;</span> <span class="n">const_iterator</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">aha_iterator</span><span class="o">&lt;</span><span class="n">AtomicHashArray</span><span class="p">,</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">iterator</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>You really shouldn't need this if you use the SmartPtr provided by create,
but if you really want to do something crazy like stick the released
pointer into a DescriminatedPtr or something, you'll need this to clean up
after yourself.</p></td><td class="code"><div class="highlight"><pre>  <span class="k">static</span> <span class="kt">void</span> <span class="n">destroy</span><span class="p">(</span><span class="n">AtomicHashArray</span><span class="o">*</span><span class="p">);</span>

 <span class="nl">private:</span>
  <span class="k">const</span> <span class="kt">size_t</span>  <span class="n">kAnchorMask_</span><span class="p">;</span>

  <span class="k">struct</span> <span class="n">Deleter</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="n">operator</span><span class="p">()(</span><span class="n">AtomicHashArray</span><span class="o">*</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">AtomicHashArray</span><span class="o">::</span><span class="n">destroy</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">};</span>

 <span class="nl">public:</span>
  <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">AtomicHashArray</span><span class="p">,</span> <span class="n">Deleter</span><span class="o">&gt;</span> <span class="n">SmartPtr</span><span class="p">;</span>

  <span class="cm">/*</span>
<span class="cm">   * create --</span>
<span class="cm">   *</span>
<span class="cm">   *   Creates AtomicHashArray objects.  Use instead of constructor/destructor.</span>
<span class="cm">   *</span>
<span class="cm">   *   We do things this way in order to avoid the perf penalty of a second</span>
<span class="cm">   *   pointer indirection when composing these into AtomicHashMap, which needs</span>
<span class="cm">   *   to store an array of pointers so that it can perform atomic operations on</span>
<span class="cm">   *   them when growing.</span>
<span class="cm">   *</span>
<span class="cm">   *   Instead of a mess of arguments, we take a max size and a Config struct to</span>
<span class="cm">   *   simulate named ctor parameters.  The Config struct has sensible defaults</span>
<span class="cm">   *   for everything, but is overloaded - if you specify a positive capacity,</span>
<span class="cm">   *   that will be used directly instead of computing it based on</span>
<span class="cm">   *   maxLoadFactor.</span>
<span class="cm">   *</span>
<span class="cm">   *   Create returns an AHA::SmartPtr which is a unique_ptr with a custom</span>
<span class="cm">   *   deleter to make sure everything is cleaned up properly.</span>
<span class="cm">   */</span>
  <span class="k">struct</span> <span class="n">Config</span> <span class="p">{</span>
    <span class="n">KeyT</span>   <span class="n">emptyKey</span><span class="p">;</span>
    <span class="n">KeyT</span>   <span class="n">lockedKey</span><span class="p">;</span>
    <span class="n">KeyT</span>   <span class="n">erasedKey</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">maxLoadFactor</span><span class="p">;</span>
    <span class="kt">int</span>    <span class="n">entryCountThreadCacheSize</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">capacity</span><span class="p">;</span> <span class="c1">// if positive, overrides maxLoadFactor</span>

    <span class="n">constexpr</span> <span class="nf">Config</span><span class="p">()</span> <span class="o">:</span> <span class="n">emptyKey</span><span class="p">(</span><span class="n">static_cast</span><span class="o">&lt;</span><span class="n">KeyT</span><span class="o">&gt;</span><span class="p">(</span><span class="o">-</span><span class="mi">1ul</span><span class="p">)),</span>
                         <span class="n">lockedKey</span><span class="p">(</span><span class="n">static_cast</span><span class="o">&lt;</span><span class="n">KeyT</span><span class="o">&gt;</span><span class="p">(</span><span class="o">-</span><span class="mi">2ul</span><span class="p">)),</span>
                         <span class="n">erasedKey</span><span class="p">(</span><span class="n">static_cast</span><span class="o">&lt;</span><span class="n">KeyT</span><span class="o">&gt;</span><span class="p">(</span><span class="o">-</span><span class="mi">3ul</span><span class="p">)),</span>
                         <span class="n">maxLoadFactor</span><span class="p">(</span><span class="mf">0.8</span><span class="p">),</span>
                         <span class="n">entryCountThreadCacheSize</span><span class="p">(</span><span class="mi">1000</span><span class="p">),</span>
                         <span class="n">capacity</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
  <span class="p">};</span>

  <span class="k">static</span> <span class="k">const</span> <span class="n">Config</span> <span class="n">defaultConfig</span><span class="p">;</span>
  <span class="k">static</span> <span class="n">SmartPtr</span> <span class="n">create</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">maxSize</span><span class="p">,</span> <span class="k">const</span> <span class="n">Config</span><span class="o">&amp;</span> <span class="o">=</span> <span class="n">defaultConfig</span><span class="p">);</span>

  <span class="n">iterator</span> <span class="nf">find</span><span class="p">(</span><span class="n">KeyT</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">iterator</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">findInternal</span><span class="p">(</span><span class="n">k</span><span class="p">).</span><span class="n">idx</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">const_iterator</span> <span class="n">find</span><span class="p">(</span><span class="n">KeyT</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">const_cast</span><span class="o">&lt;</span><span class="n">AtomicHashArray</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">this</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">find</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="cm">/*</span>
<span class="cm">   * insert --</span>
<span class="cm">   *</span>
<span class="cm">   *   Returns a pair with iterator to the element at r.first and bool success.</span>
<span class="cm">   *   Retrieve the index with ret.first.getIndex().</span>
<span class="cm">   *</span>
<span class="cm">   *   Fails on key collision (does not overwrite) or if map becomes</span>
<span class="cm">   *   full, at which point no element is inserted, iterator is set to end(),</span>
<span class="cm">   *   and success is set false.  On collisions, success is set false, but the</span>
<span class="cm">   *   iterator is set to the existing entry.</span>
<span class="cm">   */</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span><span class="n">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">SimpleRetT</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">insertInternal</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">iterator</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">ret</span><span class="p">.</span><span class="n">idx</span><span class="p">),</span> <span class="n">ret</span><span class="p">.</span><span class="n">success</span><span class="p">);</span>
  <span class="p">}</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>returns the number of elements erased - should never exceed 1</p></td><td class="code"><div class="highlight"><pre>  <span class="kt">size_t</span> <span class="n">erase</span><span class="p">(</span><span class="n">KeyT</span> <span class="n">k</span><span class="p">);</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>clears all keys and values in the map and resets all counters.  Not thread
safe.</p></td><td class="code"><div class="highlight"><pre>  <span class="kt">void</span> <span class="n">clear</span><span class="p">();</span></pre></div></td></tr>


<tr id="section-5"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-5">&#182;</a></div><p>Exact number of elements in the map - note that readFull() acquires a
mutex.  See folly/ThreadCachedInt.h for more details.</p></td><td class="code"><div class="highlight"><pre>  <span class="kt">size_t</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">numEntries_</span><span class="p">.</span><span class="n">readFull</span><span class="p">()</span> <span class="o">-</span>
      <span class="n">numErases_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

  <span class="n">iterator</span> <span class="n">begin</span><span class="p">()</span>             <span class="p">{</span> <span class="k">return</span> <span class="n">iterator</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="p">}</span>
  <span class="n">iterator</span> <span class="n">end</span><span class="p">()</span>               <span class="p">{</span> <span class="k">return</span> <span class="n">iterator</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">capacity_</span><span class="p">);</span> <span class="p">}</span>
  <span class="n">const_iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">const_iterator</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="p">}</span>
  <span class="n">const_iterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">const</span>   <span class="p">{</span> <span class="k">return</span> <span class="n">const_iterator</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">capacity_</span><span class="p">);</span> <span class="p">}</span></pre></div></td></tr>


<tr id="section-6"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-6">&#182;</a></div><p>See AtomicHashMap::findAt - access elements directly
WARNING: The following 2 functions will fail silently for hashtable
with capacity > 2^32</p></td><td class="code"><div class="highlight"><pre>  <span class="n">iterator</span> <span class="n">findAt</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">DCHECK_LT</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">capacity_</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">iterator</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">const_iterator</span> <span class="n">findAt</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">idx</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">const_cast</span><span class="o">&lt;</span><span class="n">AtomicHashArray</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">this</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">findAt</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">iterator</span> <span class="n">makeIter</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">iterator</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span> <span class="p">}</span>
  <span class="n">const_iterator</span> <span class="n">makeIter</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">idx</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">const_iterator</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
  <span class="p">}</span></pre></div></td></tr>


<tr id="section-7"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-7">&#182;</a></div><p>The max load factor allowed for this map</p></td><td class="code"><div class="highlight"><pre>  <span class="kt">double</span> <span class="n">maxLoadFactor</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="p">((</span><span class="kt">double</span><span class="p">)</span> <span class="n">maxEntries_</span><span class="p">)</span> <span class="o">/</span> <span class="n">capacity_</span><span class="p">;</span> <span class="p">}</span>

  <span class="kt">void</span> <span class="n">setEntryCountThreadCacheSize</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">newSize</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">numEntries_</span><span class="p">.</span><span class="n">setCacheSize</span><span class="p">(</span><span class="n">newSize</span><span class="p">);</span>
    <span class="n">numPendingEntries_</span><span class="p">.</span><span class="n">setCacheSize</span><span class="p">(</span><span class="n">newSize</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">int</span> <span class="n">getEntryCountThreadCacheSize</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">numEntries_</span><span class="p">.</span><span class="n">getCacheSize</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="cm">/* Private data and helper functions... */</span>

 <span class="nl">private:</span>
  <span class="n">friend</span> <span class="n">class</span> <span class="n">AtomicHashMap</span><span class="o">&lt;</span><span class="n">KeyT</span><span class="p">,</span><span class="n">ValueT</span><span class="p">,</span><span class="n">HashFcn</span><span class="o">&gt;</span><span class="p">;</span>

  <span class="k">struct</span> <span class="n">SimpleRetT</span> <span class="p">{</span> <span class="kt">size_t</span> <span class="n">idx</span><span class="p">;</span> <span class="n">bool</span> <span class="n">success</span><span class="p">;</span>
    <span class="n">SimpleRetT</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="n">bool</span> <span class="n">s</span><span class="p">)</span> <span class="o">:</span> <span class="n">idx</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">success</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">SimpleRetT</span><span class="p">()</span> <span class="p">{}</span>
  <span class="p">};</span>

  <span class="n">SimpleRetT</span> <span class="n">insertInternal</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">record</span><span class="p">);</span>

  <span class="n">SimpleRetT</span> <span class="n">findInternal</span><span class="p">(</span><span class="k">const</span> <span class="n">KeyT</span> <span class="n">key</span><span class="p">);</span>

  <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">KeyT</span><span class="o">&gt;*</span> <span class="n">cellKeyPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-8"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-8">&#182;</a></div><p>We need some illegal casting here in order to actually store
our value_type as a std::pair<const,>.  But a little bit of
undefined behavior never hurt anyone ...</p></td><td class="code"><div class="highlight"><pre>    <span class="n">static_assert</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">KeyT</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">KeyT</span><span class="p">),</span>
                  <span class="s">&quot;std::atomic is implemented in an unexpected way for AHM&quot;</span><span class="p">);</span>
    <span class="k">return</span>
      <span class="n">const_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">KeyT</span><span class="o">&gt;*&gt;</span><span class="p">(</span>
        <span class="n">reinterpret_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">KeyT</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="p">.</span><span class="n">first</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="k">static</span> <span class="n">KeyT</span> <span class="n">relaxedLoadKey</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">cellKeyPtr</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">static</span> <span class="n">KeyT</span> <span class="n">acquireLoadKey</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">cellKeyPtr</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">);</span>
  <span class="p">}</span></pre></div></td></tr>


<tr id="section-9"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-9">&#182;</a></div><p>Fun with thread local storage - atomic increment is expensive
(relatively), so we accumulate in the thread cache and periodically
flush to the actual variable, and walk through the unflushed counts when
reading the value, so be careful of calling size() too frequently.  This
increases insertion throughput several times over while keeping the count
accurate.</p></td><td class="code"><div class="highlight"><pre>  <span class="n">ThreadCachedInt</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">numEntries_</span><span class="p">;</span>  <span class="c1">// Successful key inserts</span>
  <span class="n">ThreadCachedInt</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">numPendingEntries_</span><span class="p">;</span> <span class="c1">// Used by insertInternal</span>
  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">isFull_</span><span class="p">;</span> <span class="c1">// Used by insertInternal</span>
  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span> <span class="n">numErases_</span><span class="p">;</span>   <span class="c1">// Successful key erases</span>

  <span class="n">value_type</span> <span class="n">cells_</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>  <span class="c1">// This must be the last field of this class</span></pre></div></td></tr>


<tr id="section-10"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-10">&#182;</a></div><p>Force constructor/destructor private since create/destroy should be
used externally instead</p></td><td class="code"><div class="highlight"><pre>  <span class="n">AtomicHashArray</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">capacity</span><span class="p">,</span> <span class="n">KeyT</span> <span class="n">emptyKey</span><span class="p">,</span> <span class="n">KeyT</span> <span class="n">lockedKey</span><span class="p">,</span>
                  <span class="n">KeyT</span> <span class="n">erasedKey</span><span class="p">,</span> <span class="kt">double</span> <span class="n">maxLoadFactor</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">cacheSize</span><span class="p">);</span>

  <span class="o">~</span><span class="n">AtomicHashArray</span><span class="p">()</span> <span class="p">{}</span>

  <span class="kr">inline</span> <span class="kt">void</span> <span class="n">unlockCell</span><span class="p">(</span><span class="n">value_type</span><span class="o">*</span> <span class="k">const</span> <span class="n">cell</span><span class="p">,</span> <span class="n">KeyT</span> <span class="n">newKey</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cellKeyPtr</span><span class="p">(</span><span class="o">*</span><span class="n">cell</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">(</span><span class="n">newKey</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kr">inline</span> <span class="n">bool</span> <span class="n">tryLockCell</span><span class="p">(</span><span class="n">value_type</span><span class="o">*</span> <span class="k">const</span> <span class="n">cell</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">KeyT</span> <span class="n">expect</span> <span class="o">=</span> <span class="n">kEmptyKey_</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">cellKeyPtr</span><span class="p">(</span><span class="o">*</span><span class="n">cell</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">compare_exchange_strong</span><span class="p">(</span><span class="n">expect</span><span class="p">,</span> <span class="n">kLockedKey_</span><span class="p">,</span>
      <span class="n">std</span><span class="o">::</span><span class="n">memory_order_acq_rel</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kr">inline</span> <span class="kt">size_t</span> <span class="n">keyToAnchorIdx</span><span class="p">(</span><span class="k">const</span> <span class="n">KeyT</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">size_t</span> <span class="n">hashVal</span> <span class="o">=</span> <span class="n">HashFcn</span><span class="p">()(</span><span class="n">k</span><span class="p">);</span>
    <span class="k">const</span> <span class="kt">size_t</span> <span class="n">probe</span> <span class="o">=</span> <span class="n">hashVal</span> <span class="o">&amp;</span> <span class="n">kAnchorMask_</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">LIKELY</span><span class="p">(</span><span class="n">probe</span> <span class="o">&lt;</span> <span class="n">capacity_</span><span class="p">)</span> <span class="o">?</span> <span class="n">probe</span> <span class="o">:</span> <span class="n">hashVal</span> <span class="o">%</span> <span class="n">capacity_</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kr">inline</span> <span class="kt">size_t</span> <span class="n">probeNext</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">numProbes</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-11"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-11">&#182;</a></div><p>idx += numProbes; // quadratic probing</p></td><td class="code"><div class="highlight"><pre>    <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// linear probing</span></pre></div></td></tr>


<tr id="section-12"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-12">&#182;</a></div><p>Avoid modulus because it's slow</p></td><td class="code"><div class="highlight"><pre>    <span class="k">return</span> <span class="n">LIKELY</span><span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">capacity_</span><span class="p">)</span> <span class="o">?</span> <span class="n">idx</span> <span class="o">:</span> <span class="p">(</span><span class="n">idx</span> <span class="o">-</span> <span class="n">capacity_</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span> <span class="c1">// AtomicHashArray</span>

<span class="p">}</span> <span class="c1">// namespace folly</span>

<span class="cp">#include &quot;AtomicHashArray-inl.h&quot;</span>

<span class="cp">#endif </span><span class="c1">// FOLLY_ATOMICHASHARRAY_H_</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/folly",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
