<!DOCTYPE html>
<html><head><title>joekychen/folly » folly › Foreach.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>Foreach.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2012 Facebook, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="cm"> * you may not use this file except in compliance with the License.</span>
<span class="cm"> * You may obtain a copy of the License at</span>
<span class="cm"> *</span>
<span class="cm"> *   http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="cm"> *</span>
<span class="cm"> * Unless required by applicable law or agreed to in writing, software</span>
<span class="cm"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="cm"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="cm"> * See the License for the specific language governing permissions and</span>
<span class="cm"> * limitations under the License.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef FOLLY_BASE_FOREACH_H_</span>
<span class="cp">#define FOLLY_BASE_FOREACH_H_</span>

<span class="cm">/*</span>
<span class="cm"> * Iterim macros (until we have C++0x range-based for) that simplify</span>
<span class="cm"> * writing loops of the form</span>
<span class="cm"> *</span>
<span class="cm"> * for (Container&lt;data&gt;::iterator i = c.begin(); i != c.end(); ++i) statement</span>
<span class="cm"> *</span>
<span class="cm"> * Just replace the above with:</span>
<span class="cm"> *</span>
<span class="cm"> * FOR_EACH (i, c) statement</span>
<span class="cm"> *</span>
<span class="cm"> * and everything is taken care of.</span>
<span class="cm"> *</span>
<span class="cm"> * The implementation is a bit convoluted to make sure the container is</span>
<span class="cm"> * only evaluated once (however, keep in mind that c.end() is evaluated</span>
<span class="cm"> * at every pass through the loop). To ensure the container is not</span>
<span class="cm"> * evaluated multiple times, the macro defines one do-nothing if</span>
<span class="cm"> * statement to inject the Boolean variable FOR_EACH_state1, and then a</span>
<span class="cm"> * for statement that is executed only once, which defines the variable</span>
<span class="cm"> * FOR_EACH_state2 holding a reference to the container being</span>
<span class="cm"> * iterated. The workhorse is the last loop, which uses the just defined</span>
<span class="cm"> * reference FOR_EACH_state2.</span>
<span class="cm"> *</span>
<span class="cm"> * The state variables are nested so they don&#39;t interfere; you can use</span>
<span class="cm"> * FOR_EACH multiple times in the same scope, either at the same level or</span>
<span class="cm"> * nested.</span>
<span class="cm"> *</span>
<span class="cm"> * In optimized builds g++ eliminates the extra gymnastics entirely and</span>
<span class="cm"> * generates code 100% identical to the handwritten loop.</span>
<span class="cm"> *</span>
<span class="cm"> * This will not work with temporary containers.  Consider BOOST_FOREACH</span>
<span class="cm"> * if you need that.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;boost/type_traits/remove_cv.hpp&gt;</span>

<span class="n">namespace</span> <span class="n">folly</span> <span class="p">{</span> <span class="n">namespace</span> <span class="n">detail</span> <span class="p">{</span>

<span class="cm">/*</span>
<span class="cm"> * Simple template for obtaining the unqualified type given a generic</span>
<span class="cm"> * type T. For example, if T is const int,</span>
<span class="cm"> * typeof(remove_cv_from_expression(T())) yields int. Due to a bug in</span>
<span class="cm"> * g++, you need to actually use</span>
<span class="cm"> * typeof(remove_cv_from_expression(T())) instead of typename</span>
<span class="cm"> * boost::remove_cv&lt;T&gt;::type. Note that the function</span>
<span class="cm"> * remove_cv_from_expression is never defined - use it only inside</span>
<span class="cm"> * typeof.</span>
<span class="cm"> */</span>
<span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kr">typename</span> <span class="n">boost</span><span class="o">::</span><span class="n">remove_cv</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span>
<span class="n">remove_cv_from_expression</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span><span class="p">);</span>

<span class="p">}}</span>

<span class="cm">/*</span>
<span class="cm"> * Use a &quot;reference reference&quot; (auto&amp;&amp;) to take advantage of reference</span>
<span class="cm"> * collapsing rules, if available.  In this case, FOR_EACH* will work with</span>
<span class="cm"> * temporary containers.</span>
<span class="cm"> */</span>
<span class="cp">#define FB_AUTO_RR(x, y) auto&amp;&amp; x = y</span>

<span class="cm">/*</span>
<span class="cm"> * The first AUTO should be replaced by decltype((c)) &amp;</span>
<span class="cm"> * FOR_EACH_state2, but bugs in gcc prevent that from functioning</span>
<span class="cm"> * properly. The second pair of parens in decltype is actually</span>
<span class="cm"> * required, see</span>
<span class="cm"> * cpp-next.com/archive/2011/04/appearing-and-disappearing-consts-in-c/</span>
<span class="cm"> */</span>
<span class="cp">#define FOR_EACH(i, c)                              \</span>
<span class="cp">  if (bool FOR_EACH_state1 = false) {} else         \</span>
<span class="cp">    for (auto &amp; FOR_EACH_state2 = (c);              \</span>
<span class="cp">         !FOR_EACH_state1; FOR_EACH_state1 = true)  \</span>
<span class="cp">      for (auto i = FOR_EACH_state2.begin();        \</span>
<span class="cp">           i != FOR_EACH_state2.end(); ++i)</span>

<span class="cm">/*</span>
<span class="cm"> * Similar to FOR_EACH, but iterates the container backwards by</span>
<span class="cm"> * using rbegin() and rend().</span>
<span class="cm"> */</span>
<span class="cp">#define FOR_EACH_R(i, c)                                \</span>
<span class="cp">  if (bool FOR_EACH_R_state1 = false) {} else           \</span>
<span class="cp">    for (auto &amp; FOR_EACH_R_state2 = (c);                \</span>
<span class="cp">         !FOR_EACH_R_state1; FOR_EACH_R_state1 = true)  \</span>
<span class="cp">      for (auto i = FOR_EACH_R_state2.rbegin();         \</span>
<span class="cp">           i != FOR_EACH_R_state2.rend(); ++i)</span>

<span class="cm">/*</span>
<span class="cm"> * Similar to FOR_EACH but also allows client to specify a &#39;count&#39; variable</span>
<span class="cm"> * to track the current iteration in the loop (starting at zero).</span>
<span class="cm"> * Similar to python&#39;s enumerate() function.  For example:</span>
<span class="cm"> * string commaSeparatedValues = &quot;VALUES: &quot;;</span>
<span class="cm"> * FOR_EACH_ENUMERATE(ii, value, columns) {   // don&#39;t want comma at the end!</span>
<span class="cm"> *   commaSeparatedValues += (ii == 0) ? *value : string(&quot;,&quot;) + *value;</span>
<span class="cm"> * }</span>
<span class="cm"> */</span>
<span class="cp">#define FOR_EACH_ENUMERATE(count, i, c)                                \</span>
<span class="cp">  if (bool FOR_EACH_state1 = false) {} else                            \</span>
<span class="cp">    for (auto &amp; FOR_EACH_state2 = (c);                                 \</span>
<span class="cp">         !FOR_EACH_state1; FOR_EACH_state1 = true)                     \</span>
<span class="cp">      if (size_t FOR_EACH_privateCount = 0) {} else                    \</span>
<span class="cp">        if (const size_t&amp; count = FOR_EACH_privateCount) {} else       \</span>
<span class="cp">          for (auto i = FOR_EACH_state2.begin();                       \</span>
<span class="cp">               i != FOR_EACH_state2.end(); ++FOR_EACH_privateCount, ++i)</span>

<span class="cm">/**</span>
<span class="cm"> * Similar to FOR_EACH, but gives the user the key and value for each entry in</span>
<span class="cm"> * the container, instead of just the iterator to the entry. For example:</span>
<span class="cm"> *   map&lt;string, string&gt; testMap;</span>
<span class="cm"> *   FOR_EACH_KV(key, value, testMap) {</span>
<span class="cm"> *      cout &lt;&lt; key &lt;&lt; &quot; &quot; &lt;&lt; value;</span>
<span class="cm"> *   }</span>
<span class="cm"> */</span>
<span class="cp">#define FOR_EACH_KV(k, v, c)                                    \</span>
<span class="cp">  if (unsigned int FOR_EACH_state1 = 0) {} else                 \</span>
<span class="cp">    for (FB_AUTO_RR(FOR_EACH_state2, (c));                      \</span>
<span class="cp">         !FOR_EACH_state1; FOR_EACH_state1 = 1)                 \</span>
<span class="cp">      for (auto FOR_EACH_state3 = FOR_EACH_state2.begin();      \</span>
<span class="cp">           FOR_EACH_state3 != FOR_EACH_state2.end();            \</span>
<span class="cp">           FOR_EACH_state1 == 2                                 \</span>
<span class="cp">             ? ((FOR_EACH_state1 = 0), ++FOR_EACH_state3)       \</span>
<span class="cp">             : (FOR_EACH_state3 = FOR_EACH_state2.end()))       \</span>
<span class="cp">        for (auto &amp;k = FOR_EACH_state3-&gt;first;                  \</span>
<span class="cp">             !FOR_EACH_state1; ++FOR_EACH_state1)               \</span>
<span class="cp">          for (auto &amp;v = FOR_EACH_state3-&gt;second;               \</span>
<span class="cp">               !FOR_EACH_state1; ++FOR_EACH_state1)</span>

<span class="n">namespace</span> <span class="n">folly</span> <span class="p">{</span> <span class="n">namespace</span> <span class="n">detail</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>Boost 1.48 lacks has_less, we emulate a subset of it here.</p></td><td class="code"><div class="highlight"><pre><span class="n">template</span> <span class="o">&lt;</span><span class="kr">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kr">typename</span> <span class="n">U</span><span class="o">&gt;</span>
<span class="n">class</span> <span class="n">HasLess</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">BiggerThanChar</span> <span class="p">{</span> <span class="kt">char</span> <span class="n">unused</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="p">};</span>
  <span class="n">template</span> <span class="o">&lt;</span><span class="kr">typename</span> <span class="n">C</span><span class="p">,</span> <span class="kr">typename</span> <span class="n">D</span><span class="o">&gt;</span> <span class="k">static</span> <span class="kt">char</span> <span class="n">test</span><span class="p">(</span><span class="n">decltype</span><span class="p">(</span><span class="n">C</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">())</span><span class="o">*</span><span class="p">);</span>
  <span class="n">template</span> <span class="o">&lt;</span><span class="kr">typename</span><span class="p">,</span> <span class="kr">typename</span><span class="o">&gt;</span> <span class="k">static</span> <span class="n">BiggerThanChar</span> <span class="n">test</span><span class="p">(...);</span>
<span class="nl">public:</span>
  <span class="k">enum</span> <span class="p">{</span> <span class="n">value</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">test</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">};</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * notThereYet helps the FOR_EACH_RANGE macro by opportunistically</span>
<span class="cm"> * using &quot;&lt;&quot; instead of &quot;!=&quot; whenever available when checking for loop</span>
<span class="cm"> * termination. This makes e.g. examples such as FOR_EACH_RANGE (i,</span>
<span class="cm"> * 10, 5) execute zero iterations instead of looping virtually</span>
<span class="cm"> * forever. At the same time, some iterator types define &quot;!=&quot; but not</span>
<span class="cm"> * &quot;&lt;&quot;. The notThereYet function will dispatch differently for those.</span>
<span class="cm"> *</span>
<span class="cm"> * Below is the correct implementation of notThereYet. It is disabled</span>
<span class="cm"> * because of a bug in Boost 1.46: The filesystem::path::iterator</span>
<span class="cm"> * defines operator&lt; (via boost::iterator_facade), but that in turn</span>
<span class="cm"> * uses distance_to which is undefined for that particular</span>
<span class="cm"> * iterator. So HasLess (defined above) identifies</span>
<span class="cm"> * boost::filesystem::path as properly comparable with &lt;, but in fact</span>
<span class="cm"> * attempting to do so will yield a compile-time error.</span>
<span class="cm"> *</span>
<span class="cm"> * The else branch (active) contains a conservative</span>
<span class="cm"> * implementation.</span>
<span class="cm"> */</span>

<span class="cp">#if 0</span><span class="c"></span>

<span class="c">template &lt;class T, class U&gt;</span>
<span class="c">typename std::enable_if&lt;HasLess&lt;T, U&gt;::value, bool&gt;::type</span>
<span class="c">notThereYet(T&amp; iter, const U&amp; end) {</span>
<span class="c">  return iter &lt; end;</span>
<span class="c">}</span>

<span class="c">template &lt;class T, class U&gt;</span>
<span class="c">typename std::enable_if&lt;!HasLess&lt;T, U&gt;::value, bool&gt;::type</span>
<span class="c">notThereYet(T&amp; iter, const U&amp; end) {</span>
<span class="c">  return iter != end;</span>
<span class="c">}</span>

<span class="cp">#else</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="p">,</span> <span class="n">class</span> <span class="n">U</span><span class="o">&gt;</span>
<span class="kr">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span>
  <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_arithmetic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&amp;&amp;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_arithmetic</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">)</span> <span class="o">||</span>
  <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_pointer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&amp;&amp;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_pointer</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">),</span>
  <span class="n">bool</span><span class="o">&gt;::</span><span class="n">type</span>
<span class="n">notThereYet</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="k">const</span> <span class="n">U</span><span class="o">&amp;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">iter</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="p">,</span> <span class="n">class</span> <span class="n">U</span><span class="o">&gt;</span>
<span class="kr">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span>
  <span class="o">!</span><span class="p">(</span>
    <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_arithmetic</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&amp;&amp;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_arithmetic</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">)</span> <span class="o">||</span>
    <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_pointer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&amp;&amp;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_pointer</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">)</span>
  <span class="p">),</span>
  <span class="n">bool</span><span class="o">&gt;::</span><span class="n">type</span>
<span class="n">notThereYet</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="k">const</span> <span class="n">U</span><span class="o">&amp;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">iter</span> <span class="o">!=</span> <span class="n">end</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif</span>


<span class="cm">/**</span>
<span class="cm"> * downTo is similar to notThereYet, but in reverse - it helps the</span>
<span class="cm"> * FOR_EACH_RANGE_R macro.</span>
<span class="cm"> */</span>
<span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="p">,</span> <span class="n">class</span> <span class="n">U</span><span class="o">&gt;</span>
<span class="kr">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">HasLess</span><span class="o">&lt;</span><span class="n">U</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="n">bool</span><span class="o">&gt;::</span><span class="n">type</span>
<span class="n">downTo</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="k">const</span> <span class="n">U</span><span class="o">&amp;</span> <span class="n">begin</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">begin</span> <span class="o">&lt;</span> <span class="n">iter</span><span class="o">--</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="p">,</span> <span class="n">class</span> <span class="n">U</span><span class="o">&gt;</span>
<span class="kr">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;!</span><span class="n">HasLess</span><span class="o">&lt;</span><span class="n">U</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="n">bool</span><span class="o">&gt;::</span><span class="n">type</span>
<span class="n">downTo</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">iter</span><span class="p">,</span> <span class="k">const</span> <span class="n">U</span><span class="o">&amp;</span> <span class="n">begin</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">iter</span> <span class="o">==</span> <span class="n">begin</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="o">--</span><span class="n">iter</span><span class="p">;</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">}</span> <span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Iteration with given limits. end is assumed to be reachable from</span>
<span class="cm"> * begin. end is evaluated every pass through the loop.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: The type of the loop variable should be the common type of &quot;begin&quot;</span>
<span class="cm"> *       and &quot;end&quot;. e.g. If &quot;begin&quot; is &quot;int&quot; but &quot;end&quot; is &quot;long&quot;, we want &quot;i&quot;</span>
<span class="cm"> *       to be &quot;long&quot;. This is done by getting the type of (true ? begin : end)</span>
<span class="cm"> */</span>
<span class="cp">#define FOR_EACH_RANGE(i, begin, end)           \</span>
<span class="cp">  for (auto i = (true ? (begin) : (end));       \</span>
<span class="cp">       ::folly::detail::notThereYet(i, (end));  \</span>
<span class="cp">       ++i)</span>

<span class="cm">/*</span>
<span class="cm"> * Iteration with given limits. begin is assumed to be reachable from</span>
<span class="cm"> * end by successive decrements. begin is evaluated every pass through</span>
<span class="cm"> * the loop.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: The type of the loop variable should be the common type of &quot;begin&quot;</span>
<span class="cm"> *       and &quot;end&quot;. e.g. If &quot;begin&quot; is &quot;int&quot; but &quot;end&quot; is &quot;long&quot;, we want &quot;i&quot;</span>
<span class="cm"> *       to be &quot;long&quot;. This is done by getting the type of (false ? begin : end)</span>
<span class="cm"> */</span>
<span class="cp">#define FOR_EACH_RANGE_R(i, begin, end) \</span>
<span class="cp">  for (auto i = (false ? (begin) : (end)); ::folly::detail::downTo(i, (begin));)</span>

<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/folly",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
