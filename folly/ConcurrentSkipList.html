<!DOCTYPE html>
<html><head><title>joekychen/folly » folly › ConcurrentSkipList.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>ConcurrentSkipList.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright 2012 Facebook, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="cm"> * you may not use this file except in compliance with the License.</span>
<span class="cm"> * You may obtain a copy of the License at</span>
<span class="cm"> *</span>
<span class="cm"> *   http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="cm"> *</span>
<span class="cm"> * Unless required by applicable law or agreed to in writing, software</span>
<span class="cm"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="cm"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="cm"> * See the License for the specific language governing permissions and</span>
<span class="cm"> * limitations under the License.</span>
<span class="cm"> */</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>@author: Xin Liu <a href="&#x6D;&#97;&#x69;&#108;&#116;o:&#120;&#108;&#x69;&#x75;&#120;&#64;&#102;&#98;&#x2E;&#99;&#111;&#109;">&#120;&#108;&#x69;&#x75;&#120;&#64;&#102;&#98;&#x2E;&#99;&#111;&#109;</a></p>

<p>A concurrent skip list (CSL) implementation.
Ref: http://www.cs.tau.ac.il/~shanir/nir-pubs-web/Papers/OPODIS2006-BA.pdf</p></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>

<span class="cm">This implements a sorted associative container that supports only</span>
<span class="cm">unique keys.  (Similar to std::set.)</span>

<span class="cm">Features:</span>

<span class="cm">  1. Small memory overhead: ~40% less memory overhead compared with</span>
<span class="cm">     std::set (1.6 words per node versus 3). It has an minimum of 4</span>
<span class="cm">     words (7 words if there nodes got deleted) per-list overhead</span>
<span class="cm">     though.</span>

<span class="cm">  2. Read accesses (count, find iterator, skipper) are lock-free and</span>
<span class="cm">     mostly wait-free (the only wait a reader may need to do is when</span>
<span class="cm">     the node it is visiting is in a pending stage, i.e. deleting,</span>
<span class="cm">     adding and not fully linked).  Write accesses (remove, add) need</span>
<span class="cm">     to acquire locks, but locks are local to the predecessor nodes</span>
<span class="cm">     and/or successor nodes.</span>

<span class="cm">  3. Good high contention performance, comparable single-thread</span>
<span class="cm">     performance.  In the multithreaded case (12 workers), CSL tested</span>
<span class="cm">     10x faster than a RWSpinLocked std::set for an averaged sized</span>
<span class="cm">     list (1K - 1M nodes).</span>

<span class="cm">     Comparable read performance to std::set when single threaded,</span>
<span class="cm">     especially when the list size is large, and scales better to</span>
<span class="cm">     larger lists: when the size is small, CSL can be 20-50% slower on</span>
<span class="cm">     find()/contains().  As the size gets large (&gt; 1M elements),</span>
<span class="cm">     find()/contains() can be 30% faster.</span>

<span class="cm">     Iterating through a skiplist is similar to iterating through a</span>
<span class="cm">     linked list, thus is much (2-6x) faster than on a std::set</span>
<span class="cm">     (tree-based).  This is especially true for short lists due to</span>
<span class="cm">     better cache locality.  Based on that, it&#39;s also faster to</span>
<span class="cm">     intersect two skiplists.</span>

<span class="cm">  4. Lazy removal with GC support.  The removed nodes get deleted when</span>
<span class="cm">     the last Accessor to the skiplist is destroyed.</span>

<span class="cm">Caveats:</span>

<span class="cm">  1. Write operations are usually 30% slower than std::set in a single</span>
<span class="cm">     threaded environment.</span>

<span class="cm">  2. Need to have a head node for each list, which has a 4 word</span>
<span class="cm">     overhead.</span>

<span class="cm">  3. When the list is quite small (&lt; 1000 elements), single threaded</span>
<span class="cm">     benchmarks show CSL can be 10x slower than std:set.</span>

<span class="cm">  4. The interface requires using an Accessor to access the skiplist.</span>
<span class="cm">    (See below.)</span>

<span class="cm">  5. Currently x64 only, due to use of MicroSpinLock.</span>

<span class="cm">  6. Freed nodes will not be reclaimed as long as there are ongoing</span>
<span class="cm">     uses of the list.</span>

<span class="cm">Sample usage:</span>

<span class="cm">     typedef ConcurrentSkipList&lt;int&gt; SkipListT;</span>
<span class="cm">     shared_ptr&lt;SkipListT&gt; sl(SkipListT::createInstance(init_head_height);</span>
<span class="cm">     {</span>

<span class="cm">//DIVIDER</span>
<span class="cm">       SkipListT::Accessor accessor(sl);</span>
<span class="cm">       accessor.insert(23);</span>
<span class="cm">       accessor.erase(2);</span>
<span class="cm">       for (auto &amp;elem : accessor) {</span>

<span class="cm">//DIVIDER</span>
<span class="cm">       }</span>
<span class="cm">       ... ...</span>
<span class="cm">     }</span>

<span class="cm"> Another useful type is the Skipper accessor.  This is useful if you</span>
<span class="cm"> want to skip to locations in the way std::lower_bound() works,</span>
<span class="cm"> i.e. it can be used for going through the list by skipping to the</span>
<span class="cm"> node no less than a specified key.  The Skipper keeps its location as</span>
<span class="cm"> state, which makes it convenient for things like implementing</span>
<span class="cm"> intersection of two sets efficiently, as it can start from the last</span>
<span class="cm"> visited position.</span>

<span class="cm">     {</span>
<span class="cm">       SkipListT::Accessor accessor(sl);</span>
<span class="cm">       SkipListT::Skipper skipper(accessor);</span>
<span class="cm">       skipper.to(30);</span>
<span class="cm">       if (skipper) {</span>
<span class="cm">         CHECK_LE(30, *skipper);</span>
<span class="cm">       }</span>
<span class="cm">       ...  ...</span>

<span class="cm">//DIVIDER</span>
<span class="cm">     }</span>
<span class="cm">*/</span>

<span class="cp">#ifndef FOLLY_CONCURRENT_SKIP_LIST_H_</span>
<span class="cp">#define FOLLY_CONCURRENT_SKIP_LIST_H_</span>

<span class="cp">#include &lt;algorithm&gt;</span>
<span class="cp">#include &lt;climits&gt;</span>
<span class="cp">#include &lt;type_traits&gt;</span>
<span class="cp">#include &lt;utility&gt;</span>
<span class="cp">#include &lt;vector&gt;</span>
<span class="cp">#include &lt;atomic&gt;</span>
<span class="cp">#include &lt;thread&gt;</span>
<span class="cp">#include &lt;boost/iterator/iterator_facade.hpp&gt;</span>
<span class="cp">#include &lt;boost/scoped_ptr.hpp&gt;</span>
<span class="cp">#include &lt;boost/shared_ptr.hpp&gt;</span>

<span class="cp">#include &lt;glog/logging.h&gt;</span>
<span class="cp">#include &quot;folly/ConcurrentSkipList-inl.h&quot;</span>
<span class="cp">#include &quot;folly/Likely.h&quot;</span>
<span class="cp">#include &quot;folly/SmallLocks.h&quot;</span>

<span class="n">namespace</span> <span class="n">folly</span> <span class="p">{</span>

<span class="n">template</span><span class="o">&lt;</span><span class="kr">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kr">typename</span> <span class="n">Comp</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">less</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">int</span> <span class="n">MAX_HEIGHT</span><span class="o">=</span><span class="mi">24</span><span class="o">&gt;</span>
<span class="n">class</span> <span class="n">ConcurrentSkipList</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>It's usually good practice to hold an accessor only during
its necessary life cycle (but not in a tight loop as
Accessor creation incurs ref-counting overhead).</p>

<p>Holding it longer delays garbage-collecting the deleted
nodes in the list.</p></td><td class="code"><div class="highlight"><pre>  <span class="n">static_assert</span><span class="p">(</span><span class="n">MAX_HEIGHT</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">MAX_HEIGHT</span> <span class="o">&lt;</span> <span class="mi">64</span><span class="p">,</span>
      <span class="s">&quot;MAX_HEIGHT can only be in the range of [2, 64)&quot;</span><span class="p">);</span>
  <span class="k">typedef</span> <span class="n">detail</span><span class="o">::</span><span class="n">SkipListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">NodeType</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">folly</span><span class="o">::</span><span class="n">MicroSpinLock</span><span class="o">&gt;</span> <span class="n">ScopedLocker</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">ConcurrentSkipList</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Comp</span><span class="p">,</span> <span class="n">MAX_HEIGHT</span><span class="o">&gt;</span> <span class="n">SkipListType</span><span class="p">;</span>

 <span class="nl">public:</span>
  <span class="k">typedef</span> <span class="n">T</span> <span class="n">value_type</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">T</span> <span class="n">key_type</span><span class="p">;</span>


  <span class="k">typedef</span> <span class="n">detail</span><span class="o">::</span><span class="n">csl_iterator</span><span class="o">&lt;</span><span class="n">value_type</span><span class="p">,</span> <span class="n">NodeType</span><span class="o">&gt;</span> <span class="n">iterator</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">detail</span><span class="o">::</span><span class="n">csl_iterator</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">value_type</span><span class="p">,</span> <span class="k">const</span> <span class="n">NodeType</span><span class="o">&gt;</span> <span class="n">const_iterator</span><span class="p">;</span>

  <span class="n">class</span> <span class="n">Accessor</span><span class="p">;</span>
  <span class="n">class</span> <span class="n">Skipper</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>use elem to access data</p></td><td class="code"><div class="highlight"><pre>  <span class="k">static</span> <span class="n">Accessor</span> <span class="nf">create</span><span class="p">(</span><span class="kt">int</span> <span class="n">height</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Accessor</span><span class="p">(</span><span class="n">createInstance</span><span class="p">(</span><span class="n">height</span><span class="p">));</span>
  <span class="p">}</span></pre></div></td></tr>


<tr id="section-5"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-5">&#182;</a></div><p>GC may happen when the accessor gets destructed.</p></td><td class="code"><div class="highlight"><pre>  <span class="k">static</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">SkipListType</span><span class="o">&gt;</span> <span class="n">createInstance</span><span class="p">(</span><span class="kt">int</span> <span class="n">height</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">SkipListType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">new</span> <span class="n">SkipListType</span><span class="p">(</span><span class="n">height</span><span class="p">));</span>
  <span class="p">}</span></pre></div></td></tr>


<tr id="section-6"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-6">&#182;</a></div><p>MAX<em>HEIGHT needs to be at least 2 to suppress compiler
warnings/errors (Werror=uninitialized tiggered due to preds</em>[1]
being treated as a scalar in the compiler).</p></td><td class="code"><div class="highlight"><pre>  <span class="o">~</span><span class="n">ConcurrentSkipList</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">LOG_IF</span><span class="p">(</span><span class="n">FATAL</span><span class="p">,</span> <span class="n">recycler_</span><span class="p">.</span><span class="n">refs</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
      <span class="o">&lt;&lt;</span> <span class="s">&quot;number of accessors is not 0, &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">recycler_</span><span class="p">.</span><span class="n">refs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; instead!&quot;</span>
      <span class="o">&lt;&lt;</span> <span class="s">&quot; This shouldn&#39;t have happened!&quot;</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">NodeType</span><span class="o">*</span> <span class="n">current</span> <span class="o">=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">NodeType</span><span class="o">*</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">skip</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
      <span class="n">NodeType</span><span class="o">::</span><span class="n">destroy</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
      <span class="n">head_</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

 <span class="nl">private:</span>

  <span class="k">static</span> <span class="n">bool</span> <span class="n">greater</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="k">const</span> <span class="n">NodeType</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">node</span> <span class="o">&amp;&amp;</span> <span class="n">Comp</span><span class="p">()(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">(),</span> <span class="n">data</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">static</span> <span class="n">bool</span> <span class="n">less</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="k">const</span> <span class="n">NodeType</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="n">nullptr</span><span class="p">)</span> <span class="o">||</span> <span class="n">Comp</span><span class="p">()(</span><span class="n">data</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="k">static</span> <span class="kt">int</span> <span class="n">findInsertionPoint</span><span class="p">(</span><span class="n">NodeType</span> <span class="o">*</span><span class="n">cur</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cur_layer</span><span class="p">,</span>
      <span class="k">const</span> <span class="n">value_type</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span>
      <span class="n">NodeType</span> <span class="o">*</span><span class="n">preds</span><span class="p">[],</span> <span class="n">NodeType</span> <span class="o">*</span><span class="n">succs</span><span class="p">[])</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">foundLayer</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">NodeType</span> <span class="o">*</span><span class="n">pred</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
    <span class="n">NodeType</span> <span class="o">*</span><span class="n">foundNode</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">layer</span> <span class="o">=</span> <span class="n">cur_layer</span><span class="p">;</span> <span class="n">layer</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">layer</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">NodeType</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">pred</span><span class="o">-&gt;</span><span class="n">skip</span><span class="p">(</span><span class="n">layer</span><span class="p">);</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">greater</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">pred</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">skip</span><span class="p">(</span><span class="n">layer</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">foundLayer</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">less</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// the two keys equal</span>
        <span class="n">foundLayer</span> <span class="o">=</span> <span class="n">layer</span><span class="p">;</span>
        <span class="n">foundNode</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">preds</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span> <span class="o">=</span> <span class="n">pred</span><span class="p">;</span></pre></div></td></tr>


<tr id="section-7"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-7">&#182;</a></div><p>convenient function to get an Accessor to a new instance.</p></td><td class="code"><div class="highlight"><pre>      <span class="n">succs</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span> <span class="o">=</span> <span class="n">foundNode</span> <span class="o">?</span> <span class="n">foundNode</span> <span class="o">:</span> <span class="n">node</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">foundLayer</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">struct</span> <span class="n">Recycler</span> <span class="o">:</span> <span class="n">private</span> <span class="n">boost</span><span class="o">::</span><span class="n">noncopyable</span> <span class="p">{</span>
    <span class="n">Recycler</span><span class="p">()</span> <span class="o">:</span> <span class="n">refs_</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">dirty_</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span> <span class="p">{</span> <span class="n">lock_</span><span class="p">.</span><span class="n">init</span><span class="p">();</span> <span class="p">}</span>

    <span class="o">~</span><span class="n">Recycler</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">nodes_</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">node</span> <span class="o">:</span> <span class="o">*</span><span class="n">nodes_</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">NodeType</span><span class="o">::</span><span class="n">destroy</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">add</span><span class="p">(</span><span class="n">NodeType</span><span class="o">*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">MicroSpinLock</span><span class="o">&gt;</span> <span class="n">g</span><span class="p">(</span><span class="n">lock_</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">nodes_</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">==</span> <span class="n">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">nodes_</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="n">new</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">NodeType</span><span class="o">*&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">node</span><span class="p">));</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">nodes_</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="n">DCHECK_GT</span><span class="p">(</span><span class="n">refs</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
      <span class="n">dirty_</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">refs</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">refs_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">addRef</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">refs_</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">release</span><span class="p">()</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-8"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-8">&#182;</a></div><p>create a shared_ptr skiplist object with initial head height.</p></td><td class="code"><div class="highlight"><pre>      <span class="k">if</span> <span class="p">(</span><span class="n">LIKELY</span><span class="p">(</span><span class="o">!</span><span class="n">dirty_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">)</span> <span class="o">||</span> <span class="n">refs</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">refs_</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="n">boost</span><span class="o">::</span><span class="n">scoped_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">NodeType</span><span class="o">*&gt;</span> <span class="o">&gt;</span> <span class="n">newNodes</span><span class="p">;</span>
      <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">MicroSpinLock</span><span class="o">&gt;</span> <span class="n">g</span><span class="p">(</span><span class="n">lock_</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nodes_</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">==</span> <span class="n">nullptr</span> <span class="o">||</span> <span class="n">refs</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="n">refs_</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
        <span class="p">}</span></pre></div></td></tr>


<tr id="section-9"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-9">&#182;</a></div><p>===================================================================
Below are implementation details.</p>

<h1>Please see ConcurrentSkipList::Accessor for stdlib-like APIs.</h1></td><td class="code"><div class="highlight"><pre>        <span class="n">newNodes</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">nodes_</span><span class="p">);</span>
        <span class="n">dirty_</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="nb">false</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
      <span class="p">}</span></pre></div></td></tr>


<tr id="section-10"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-10">&#182;</a></div><p>if found, succs[0..foundLayer] need to point to the cached foundNode,
as foundNode might be deleted at the same time thus pred->skip() can
return NULL or another node.</p></td><td class="code"><div class="highlight"><pre>      <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">node</span> <span class="o">:</span> <span class="o">*</span><span class="n">newNodes</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">NodeType</span><span class="o">::</span><span class="n">destroy</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
      <span class="p">}</span></pre></div></td></tr>


<tr id="section-11"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-11">&#182;</a></div><p>We don't expect to clean the recycler immediately everytime it is OK
to do so. Here, it is possible that multiple accessors all release at
the same time but nobody would clean the recycler here. If this
happens, the recycler will usually still get cleaned when
such a race doesn't happen. The worst case is the recycler will
eventually get deleted along with the skiplist.</p></td><td class="code"><div class="highlight"><pre>      <span class="k">return</span> <span class="n">refs_</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
    <span class="p">}</span>

   <span class="nl">private:</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">scoped_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">NodeType</span><span class="o">*&gt;&gt;</span> <span class="n">nodes_</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;</span> <span class="n">refs_</span><span class="p">;</span> <span class="c1">// current number of visitors to the list</span>
    <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">bool</span><span class="o">&gt;</span> <span class="n">dirty_</span><span class="p">;</span> <span class="c1">// whether *nodes_ is non-empty</span>
    <span class="n">MicroSpinLock</span> <span class="n">lock_</span><span class="p">;</span> <span class="c1">// protects access to *nodes_</span>
  <span class="p">};</span>  <span class="c1">// class ConcurrentSkipList::Recycler</span>

  <span class="n">explicit</span> <span class="nf">ConcurrentSkipList</span><span class="p">(</span><span class="kt">int</span> <span class="n">height</span><span class="p">)</span> <span class="o">:</span>
    <span class="n">head_</span><span class="p">(</span><span class="n">NodeType</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">value_type</span><span class="p">(),</span> <span class="nb">true</span><span class="p">)),</span> <span class="n">size_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>

  <span class="kt">size_t</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">size_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span> <span class="p">}</span>
  <span class="kt">int</span> <span class="n">height</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_consume</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="kt">int</span> <span class="n">maxLayer</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">height</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>

  <span class="kt">size_t</span> <span class="n">incrementSize</span><span class="p">(</span><span class="kt">int</span> <span class="n">delta</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">size_</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">)</span> <span class="o">+</span> <span class="n">delta</span><span class="p">;</span>
  <span class="p">}</span></pre></div></td></tr>


<tr id="section-12"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-12">&#182;</a></div><p>once refs_ reaches 1 and there is no other accessor, it is safe to
remove all the current nodes in the recycler, as we already acquired
the lock here so no more new nodes can be added, even though new
accessors may be added after that.</p></td><td class="code"><div class="highlight"><pre>  <span class="n">NodeType</span><span class="o">*</span> <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">findNode</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">.</span><span class="n">second</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ret</span><span class="p">.</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">markedForRemoval</span><span class="p">())</span> <span class="k">return</span> <span class="n">ret</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">nullptr</span><span class="p">;</span>
  <span class="p">}</span></pre></div></td></tr>


<tr id="section-13"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-13">&#182;</a></div><p>TODO(xliu) should we spawn a thread to do this when there are large
number of nodes in the recycler?</p></td><td class="code"><div class="highlight"><pre>  <span class="n">bool</span> <span class="n">lockNodesForChange</span><span class="p">(</span><span class="kt">int</span> <span class="n">nodeHeight</span><span class="p">,</span>
      <span class="n">ScopedLocker</span> <span class="n">guards</span><span class="p">[</span><span class="n">MAX_HEIGHT</span><span class="p">],</span>
      <span class="n">NodeType</span> <span class="o">*</span><span class="n">preds</span><span class="p">[</span><span class="n">MAX_HEIGHT</span><span class="p">],</span>
      <span class="n">NodeType</span> <span class="o">*</span><span class="n">succs</span><span class="p">[</span><span class="n">MAX_HEIGHT</span><span class="p">],</span>
      <span class="n">bool</span> <span class="n">adding</span><span class="o">=</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NodeType</span> <span class="o">*</span><span class="n">pred</span><span class="p">,</span> <span class="o">*</span><span class="n">succ</span><span class="p">,</span> <span class="o">*</span><span class="n">prevPred</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">valid</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">layer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">valid</span> <span class="o">&amp;&amp;</span> <span class="n">layer</span> <span class="o">&lt;</span> <span class="n">nodeHeight</span><span class="p">;</span> <span class="o">++</span><span class="n">layer</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">pred</span> <span class="o">=</span> <span class="n">preds</span><span class="p">[</span><span class="n">layer</span><span class="p">];</span>
      <span class="n">DCHECK</span><span class="p">(</span><span class="n">pred</span> <span class="o">!=</span> <span class="n">nullptr</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;layer=&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">layer</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; height=&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">height</span><span class="p">()</span>
        <span class="o">&lt;&lt;</span> <span class="s">&quot; nodeheight=&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">nodeHeight</span><span class="p">;</span>
      <span class="n">succ</span> <span class="o">=</span> <span class="n">succs</span><span class="p">[</span><span class="n">layer</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">pred</span> <span class="o">!=</span> <span class="n">prevPred</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">guards</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span> <span class="o">=</span> <span class="n">pred</span><span class="o">-&gt;</span><span class="n">acquireGuard</span><span class="p">();</span>
        <span class="n">prevPred</span> <span class="o">=</span> <span class="n">pred</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">valid</span> <span class="o">=</span> <span class="o">!</span><span class="n">pred</span><span class="o">-&gt;</span><span class="n">markedForRemoval</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
        <span class="n">pred</span><span class="o">-&gt;</span><span class="n">skip</span><span class="p">(</span><span class="n">layer</span><span class="p">)</span> <span class="o">==</span> <span class="n">succ</span><span class="p">;</span>  <span class="c1">// check again after locking</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">adding</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// when adding a node, the succ shouldn&#39;t be going away</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="n">valid</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">succ</span> <span class="o">==</span> <span class="n">nullptr</span> <span class="o">||</span> <span class="o">!</span><span class="n">succ</span><span class="o">-&gt;</span><span class="n">markedForRemoval</span><span class="p">());</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">valid</span><span class="p">;</span>
  <span class="p">}</span></pre></div></td></tr>


<tr id="section-14"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-14">&#182;</a></div><p>decrease the ref count at the very end, to minimize the
chance of other threads acquiring lock_ to clear the deleted
nodes again.</p></td><td class="code"><div class="highlight"><pre>  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">NodeType</span><span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">addOrGetData</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NodeType</span> <span class="o">*</span><span class="n">preds</span><span class="p">[</span><span class="n">MAX_HEIGHT</span><span class="p">],</span> <span class="o">*</span><span class="n">succs</span><span class="p">[</span><span class="n">MAX_HEIGHT</span><span class="p">];</span>
    <span class="n">NodeType</span> <span class="o">*</span><span class="n">newNode</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">newSize</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">max_layer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">layer</span> <span class="o">=</span> <span class="n">findInsertionPointGetMaxLayer</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">preds</span><span class="p">,</span> <span class="n">succs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">max_layer</span><span class="p">);</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">layer</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">NodeType</span> <span class="o">*</span><span class="n">nodeFound</span> <span class="o">=</span> <span class="n">succs</span><span class="p">[</span><span class="n">layer</span><span class="p">];</span>
        <span class="n">DCHECK</span><span class="p">(</span><span class="n">nodeFound</span> <span class="o">!=</span> <span class="n">nullptr</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nodeFound</span><span class="o">-&gt;</span><span class="n">markedForRemoval</span><span class="p">())</span> <span class="p">{</span>
          <span class="k">continue</span><span class="p">;</span>  <span class="c1">// if it&#39;s getting deleted retry finding node.</span>
        <span class="p">}</span></pre></div></td></tr>


<tr id="section-15"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-15">&#182;</a></div><p>Returns the node if found, nullptr otherwise.</p></td><td class="code"><div class="highlight"><pre>        <span class="k">while</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="o">!</span><span class="n">nodeFound</span><span class="o">-&gt;</span><span class="n">fullyLinked</span><span class="p">()))</span> <span class="p">{}</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">nodeFound</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
      <span class="p">}</span></pre></div></td></tr>


<tr id="section-16"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-16">&#182;</a></div><p>lock all the necessary nodes for changing (adding or removing) the list.
returns true if all the lock acquried successfully and the related nodes
are all validate (not in certain pending states), false otherwise.</p></td><td class="code"><div class="highlight"><pre>      <span class="kt">int</span> <span class="n">nodeHeight</span> <span class="o">=</span> <span class="n">detail</span><span class="o">::</span><span class="n">SkipListRandomHeight</span><span class="o">::</span><span class="n">instance</span><span class="p">()</span><span class="o">-&gt;</span>
        <span class="n">getHeight</span><span class="p">(</span><span class="n">max_layer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

      <span class="n">ScopedLocker</span> <span class="n">guards</span><span class="p">[</span><span class="n">MAX_HEIGHT</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lockNodesForChange</span><span class="p">(</span><span class="n">nodeHeight</span><span class="p">,</span> <span class="n">guards</span><span class="p">,</span> <span class="n">preds</span><span class="p">,</span> <span class="n">succs</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">continue</span><span class="p">;</span> <span class="c1">// give up the locks and retry until all valid</span>
      <span class="p">}</span></pre></div></td></tr>


<tr id="section-17"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-17">&#182;</a></div><p>Returns a paired value:
  pair.first always stores the pointer to the node with the same input key.
    It could be either the newly added data, or the existed data in the
    list with the same key.
  pair.second stores whether the data is added successfully:
    0 means not added, otherwise reutrns the new size.</p></td><td class="code"><div class="highlight"><pre>      <span class="n">newNode</span> <span class="o">=</span> <span class="n">NodeType</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">nodeHeight</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">layer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">layer</span> <span class="o">&lt;</span> <span class="n">nodeHeight</span><span class="p">;</span> <span class="o">++</span><span class="n">layer</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">newNode</span><span class="o">-&gt;</span><span class="n">setSkip</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">succs</span><span class="p">[</span><span class="n">layer</span><span class="p">]);</span>
        <span class="n">preds</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">setSkip</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">newNode</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="n">newNode</span><span class="o">-&gt;</span><span class="n">setFullyLinked</span><span class="p">();</span>
      <span class="n">newSize</span> <span class="o">=</span> <span class="n">incrementSize</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">hgt</span> <span class="o">=</span> <span class="n">height</span><span class="p">();</span>
    <span class="kt">size_t</span> <span class="n">sizeLimit</span> <span class="o">=</span>
      <span class="n">detail</span><span class="o">::</span><span class="n">SkipListRandomHeight</span><span class="o">::</span><span class="n">instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getSizeLimit</span><span class="p">(</span><span class="n">hgt</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">hgt</span> <span class="o">&lt;</span> <span class="n">MAX_HEIGHT</span> <span class="o">&amp;&amp;</span> <span class="n">newSize</span> <span class="o">&gt;</span> <span class="n">sizeLimit</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">growHeight</span><span class="p">(</span><span class="n">hgt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">CHECK_GT</span><span class="p">(</span><span class="n">newSize</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">newNode</span><span class="p">,</span> <span class="n">newSize</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">bool</span> <span class="n">remove</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NodeType</span> <span class="o">*</span><span class="n">nodeToDelete</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
    <span class="n">ScopedLocker</span> <span class="n">nodeGuard</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">isMarked</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">nodeHeight</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">NodeType</span><span class="o">*</span> <span class="n">preds</span><span class="p">[</span><span class="n">MAX_HEIGHT</span><span class="p">],</span> <span class="o">*</span><span class="n">succs</span><span class="p">[</span><span class="n">MAX_HEIGHT</span><span class="p">];</span>

    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">max_layer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">layer</span> <span class="o">=</span> <span class="n">findInsertionPointGetMaxLayer</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">preds</span><span class="p">,</span> <span class="n">succs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">max_layer</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isMarked</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">layer</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">!</span><span class="n">okToDelete</span><span class="p">(</span><span class="n">succs</span><span class="p">[</span><span class="n">layer</span><span class="p">],</span> <span class="n">layer</span><span class="p">)))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isMarked</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">nodeToDelete</span> <span class="o">=</span> <span class="n">succs</span><span class="p">[</span><span class="n">layer</span><span class="p">];</span>
        <span class="n">nodeHeight</span> <span class="o">=</span> <span class="n">nodeToDelete</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">();</span>
        <span class="n">nodeGuard</span> <span class="o">=</span> <span class="n">nodeToDelete</span><span class="o">-&gt;</span><span class="n">acquireGuard</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nodeToDelete</span><span class="o">-&gt;</span><span class="n">markedForRemoval</span><span class="p">())</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">nodeToDelete</span><span class="o">-&gt;</span><span class="n">setMarkedForRemoval</span><span class="p">();</span>
        <span class="n">isMarked</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
      <span class="p">}</span></pre></div></td></tr>


<tr id="section-18"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-18">&#182;</a></div><p>wait until fully linked.</p></td><td class="code"><div class="highlight"><pre>      <span class="n">ScopedLocker</span> <span class="n">guards</span><span class="p">[</span><span class="n">MAX_HEIGHT</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lockNodesForChange</span><span class="p">(</span><span class="n">nodeHeight</span><span class="p">,</span> <span class="n">guards</span><span class="p">,</span> <span class="n">preds</span><span class="p">,</span> <span class="n">succs</span><span class="p">,</span> <span class="nb">false</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">continue</span><span class="p">;</span>  <span class="c1">// this will unlock all the locks</span>
      <span class="p">}</span>

      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">layer</span> <span class="o">=</span> <span class="n">nodeHeight</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">layer</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">layer</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">preds</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">setSkip</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">nodeToDelete</span><span class="o">-&gt;</span><span class="n">skip</span><span class="p">(</span><span class="n">layer</span><span class="p">));</span>
      <span class="p">}</span>

      <span class="n">incrementSize</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">recycle</span><span class="p">(</span><span class="n">nodeToDelete</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="n">value_type</span> <span class="o">*</span><span class="n">first</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">node</span> <span class="o">=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_consume</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">skip</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">node</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">()</span> <span class="o">:</span> <span class="n">nullptr</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="n">value_type</span> <span class="o">*</span><span class="n">last</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">NodeType</span> <span class="o">*</span><span class="n">pred</span> <span class="o">=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_consume</span><span class="p">);</span>
    <span class="n">NodeType</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">layer</span> <span class="o">=</span> <span class="n">maxLayer</span><span class="p">();</span> <span class="n">layer</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">layer</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">do</span> <span class="p">{</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">pred</span><span class="o">-&gt;</span><span class="n">skip</span><span class="p">(</span><span class="n">layer</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">node</span> <span class="o">!=</span> <span class="n">nullptr</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">pred</span> <span class="o">==</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">)</span>
      <span class="o">?</span> <span class="n">nullptr</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">pred</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">static</span> <span class="n">bool</span> <span class="n">okToDelete</span><span class="p">(</span><span class="n">NodeType</span> <span class="o">*</span><span class="n">candidate</span><span class="p">,</span> <span class="kt">int</span> <span class="n">layer</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">DCHECK</span><span class="p">(</span><span class="n">candidate</span> <span class="o">!=</span> <span class="n">nullptr</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">candidate</span><span class="o">-&gt;</span><span class="n">fullyLinked</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
      <span class="n">candidate</span><span class="o">-&gt;</span><span class="n">maxLayer</span><span class="p">()</span> <span class="o">==</span> <span class="n">layer</span> <span class="o">&amp;&amp;</span>
      <span class="o">!</span><span class="n">candidate</span><span class="o">-&gt;</span><span class="n">markedForRemoval</span><span class="p">();</span>
  <span class="p">}</span></pre></div></td></tr>


<tr id="section-19"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-19">&#182;</a></div><p>need to capped at the original height -- the real height may have grown</p></td><td class="code"><div class="highlight"><pre>  <span class="kt">int</span> <span class="n">findInsertionPointGetMaxLayer</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span>
      <span class="n">NodeType</span> <span class="o">*</span><span class="n">preds</span><span class="p">[],</span> <span class="n">NodeType</span> <span class="o">*</span><span class="n">succs</span><span class="p">[],</span> <span class="kt">int</span> <span class="o">*</span><span class="n">max_layer</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">max_layer</span> <span class="o">=</span> <span class="n">maxLayer</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">findInsertionPoint</span><span class="p">(</span><span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_consume</span><span class="p">),</span>
      <span class="o">*</span><span class="n">max_layer</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">preds</span><span class="p">,</span> <span class="n">succs</span><span class="p">);</span>
  <span class="p">}</span></pre></div></td></tr>


<tr id="section-20"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-20">&#182;</a></div><p>locks acquired and all valid, need to modify the links under the locks.</p></td><td class="code"><div class="highlight"><pre>  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">NodeType</span><span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">findNode</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">findNodeDownRight</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
  <span class="p">}</span></pre></div></td></tr>


<tr id="section-21"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-21">&#182;</a></div><p>acquire pred locks from bottom layer up</p></td><td class="code"><div class="highlight"><pre>  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">NodeType</span><span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">findNodeDownRight</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">NodeType</span> <span class="o">*</span><span class="n">pred</span> <span class="o">=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_consume</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">ht</span> <span class="o">=</span> <span class="n">pred</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">();</span>
    <span class="n">NodeType</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>

    <span class="n">bool</span> <span class="n">found</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-22"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-22">&#182;</a></div><p>find node for insertion/deleting</p></td><td class="code"><div class="highlight"><pre>      <span class="k">for</span> <span class="p">(;</span> <span class="n">ht</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">less</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pred</span><span class="o">-&gt;</span><span class="n">skip</span><span class="p">(</span><span class="n">ht</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span> <span class="o">--</span><span class="n">ht</span><span class="p">)</span> <span class="p">{}</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">ht</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">pred</span><span class="o">-&gt;</span><span class="n">skip</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>  <span class="c1">// not found</span>

      <span class="n">node</span> <span class="o">=</span> <span class="n">pred</span><span class="o">-&gt;</span><span class="n">skip</span><span class="p">(</span><span class="o">--</span><span class="n">ht</span><span class="p">);</span>  <span class="c1">// node &lt;= data now</span></pre></div></td></tr>


<tr id="section-23"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-23">&#182;</a></div><p>Find node for access. Returns a paired values:
pair.first = the first node that no-less than data value
pair.second = 1 when the data value is founded, or 0 otherwise.
This is like lower_bound, but not exact: we could have the node marked for
removal so still need to check that.</p></td><td class="code"><div class="highlight"><pre>      <span class="k">while</span> <span class="p">(</span><span class="n">greater</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">pred</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">skip</span><span class="p">(</span><span class="n">ht</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="n">found</span> <span class="o">=</span> <span class="o">!</span><span class="n">less</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">found</span><span class="p">);</span>
  <span class="p">}</span></pre></div></td></tr>


<tr id="section-24"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-24">&#182;</a></div><p>Find node by first stepping down then stepping right. Based on benchmark
results, this is slightly faster than findNodeRightDown for better
localality on the skipping pointers.</p></td><td class="code"><div class="highlight"><pre>  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">NodeType</span><span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">findNodeRightDown</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">NodeType</span> <span class="o">*</span><span class="n">pred</span> <span class="o">=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_consume</span><span class="p">);</span>
    <span class="n">NodeType</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
    <span class="k">auto</span> <span class="n">top</span> <span class="o">=</span> <span class="n">maxLayer</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">layer</span> <span class="o">=</span> <span class="n">top</span><span class="p">;</span> <span class="o">!</span><span class="n">found</span> <span class="o">&amp;&amp;</span> <span class="n">layer</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">layer</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">node</span> <span class="o">=</span> <span class="n">pred</span><span class="o">-&gt;</span><span class="n">skip</span><span class="p">(</span><span class="n">layer</span><span class="p">);</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">greater</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">pred</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">skip</span><span class="p">(</span><span class="n">layer</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="n">found</span> <span class="o">=</span> <span class="o">!</span><span class="n">less</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">found</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">NodeType</span><span class="o">*</span> <span class="n">lower_bound</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">node</span> <span class="o">=</span> <span class="n">findNode</span><span class="p">(</span><span class="n">data</span><span class="p">).</span><span class="n">first</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">node</span> <span class="o">!=</span> <span class="n">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">markedForRemoval</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">skip</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">growHeight</span><span class="p">(</span><span class="kt">int</span> <span class="n">height</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NodeType</span><span class="o">*</span> <span class="n">oldHead</span> <span class="o">=</span> <span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_consume</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">oldHead</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">height</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// someone else already did this</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">NodeType</span><span class="o">*</span> <span class="n">newHead</span> <span class="o">=</span> <span class="n">NodeType</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">value_type</span><span class="p">(),</span> <span class="nb">true</span><span class="p">);</span>

    <span class="p">{</span> <span class="c1">// need to guard the head node in case others are adding/removing</span></pre></div></td></tr>


<tr id="section-25"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-25">&#182;</a></div><p>stepping down</p></td><td class="code"><div class="highlight"><pre>      <span class="n">ScopedLocker</span> <span class="n">g</span> <span class="o">=</span> <span class="n">oldHead</span><span class="o">-&gt;</span><span class="n">acquireGuard</span><span class="p">();</span>
      <span class="n">newHead</span><span class="o">-&gt;</span><span class="n">promoteFrom</span><span class="p">(</span><span class="n">oldHead</span><span class="p">);</span>
      <span class="n">NodeType</span><span class="o">*</span> <span class="n">expected</span> <span class="o">=</span> <span class="n">oldHead</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">head_</span><span class="p">.</span><span class="n">compare_exchange_strong</span><span class="p">(</span><span class="n">expected</span><span class="p">,</span> <span class="n">newHead</span><span class="p">,</span>
          <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">))</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-26"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-26">&#182;</a></div><p>stepping right</p></td><td class="code"><div class="highlight"><pre>        <span class="n">NodeType</span><span class="o">::</span><span class="n">destroy</span><span class="p">(</span><span class="n">newHead</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">oldHead</span><span class="o">-&gt;</span><span class="n">setMarkedForRemoval</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">recycle</span><span class="p">(</span><span class="n">oldHead</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">recycle</span><span class="p">(</span><span class="n">NodeType</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">recycler_</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">NodeType</span><span class="o">*&gt;</span> <span class="n">head_</span><span class="p">;</span>
  <span class="n">Recycler</span> <span class="n">recycler_</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">size_</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">template</span><span class="o">&lt;</span><span class="kr">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kr">typename</span> <span class="n">Comp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">MAX_HEIGHT</span><span class="o">&gt;</span>
<span class="n">class</span> <span class="n">ConcurrentSkipList</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Comp</span><span class="p">,</span> <span class="n">MAX_HEIGHT</span><span class="o">&gt;::</span><span class="n">Accessor</span> <span class="p">{</span>
  <span class="k">typedef</span> <span class="n">detail</span><span class="o">::</span><span class="n">SkipListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">NodeType</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">ConcurrentSkipList</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Comp</span><span class="p">,</span> <span class="n">MAX_HEIGHT</span><span class="o">&gt;</span> <span class="n">SkipListType</span><span class="p">;</span>
 <span class="nl">public:</span>
  <span class="k">typedef</span> <span class="n">T</span> <span class="n">value_type</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">T</span> <span class="n">key_type</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">reference</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">T</span><span class="o">*</span> <span class="n">pointer</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">const_reference</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">const_pointer</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="kt">size_t</span> <span class="n">size_type</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">Comp</span> <span class="n">key_compare</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">Comp</span> <span class="n">value_compare</span><span class="p">;</span>

  <span class="k">typedef</span> <span class="kr">typename</span> <span class="n">SkipListType</span><span class="o">::</span><span class="n">iterator</span> <span class="n">iterator</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="kr">typename</span> <span class="n">SkipListType</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">const_iterator</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="kr">typename</span> <span class="n">SkipListType</span><span class="o">::</span><span class="n">Skipper</span> <span class="n">Skipper</span><span class="p">;</span>

  <span class="n">explicit</span> <span class="nf">Accessor</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">ConcurrentSkipList</span><span class="o">&gt;</span> <span class="n">skip_list</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">slHolder_</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">skip_list</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="n">sl_</span> <span class="o">=</span> <span class="n">slHolder_</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
    <span class="n">DCHECK</span><span class="p">(</span><span class="n">sl_</span> <span class="o">!=</span> <span class="n">nullptr</span><span class="p">);</span>
    <span class="n">sl_</span><span class="o">-&gt;</span><span class="n">recycler_</span><span class="p">.</span><span class="n">addRef</span><span class="p">();</span>
  <span class="p">}</span></pre></div></td></tr>


<tr id="section-27"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-27">&#182;</a></div><p>find node by first stepping right then stepping down.
We still keep this for reference purposes.</p></td><td class="code"><div class="highlight"><pre>  <span class="n">explicit</span> <span class="nf">Accessor</span><span class="p">(</span><span class="n">ConcurrentSkipList</span> <span class="o">*</span><span class="n">skip_list</span><span class="p">)</span> <span class="o">:</span> <span class="n">sl_</span><span class="p">(</span><span class="n">skip_list</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">DCHECK</span><span class="p">(</span><span class="n">sl_</span> <span class="o">!=</span> <span class="n">nullptr</span><span class="p">);</span>
    <span class="n">sl_</span><span class="o">-&gt;</span><span class="n">recycler_</span><span class="p">.</span><span class="n">addRef</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">Accessor</span><span class="p">(</span><span class="k">const</span> <span class="n">Accessor</span> <span class="o">&amp;</span><span class="n">accessor</span><span class="p">)</span> <span class="o">:</span>
      <span class="n">sl_</span><span class="p">(</span><span class="n">accessor</span><span class="p">.</span><span class="n">sl_</span><span class="p">),</span>
      <span class="n">slHolder_</span><span class="p">(</span><span class="n">accessor</span><span class="p">.</span><span class="n">slHolder_</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sl_</span><span class="o">-&gt;</span><span class="n">recycler_</span><span class="p">.</span><span class="n">addRef</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">Accessor</span><span class="o">&amp;</span> <span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Accessor</span> <span class="o">&amp;</span><span class="n">accessor</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">this</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">accessor</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">slHolder_</span> <span class="o">=</span> <span class="n">accessor</span><span class="p">.</span><span class="n">slHolder_</span><span class="p">;</span>
      <span class="n">sl_</span><span class="o">-&gt;</span><span class="n">recycler_</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
      <span class="n">sl_</span> <span class="o">=</span> <span class="n">accessor</span><span class="p">.</span><span class="n">sl_</span><span class="p">;</span>
      <span class="n">sl_</span><span class="o">-&gt;</span><span class="n">recycler_</span><span class="p">.</span><span class="n">addRef</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="o">~</span><span class="n">Accessor</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">sl_</span><span class="o">-&gt;</span><span class="n">recycler_</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">sl_</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">size_t</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">sl_</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">size_type</span> <span class="n">max_size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">size_type</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span> <span class="p">}</span></pre></div></td></tr>


<tr id="section-28"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-28">&#182;</a></div><p>nodes linked to the head.</p></td><td class="code"><div class="highlight"><pre>  <span class="n">iterator</span> <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">iterator</span><span class="p">(</span><span class="n">sl_</span><span class="o">-&gt;</span><span class="n">find</span><span class="p">(</span><span class="n">value</span><span class="p">));</span> <span class="p">}</span>
  <span class="n">const_iterator</span> <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">iterator</span><span class="p">(</span><span class="n">sl_</span><span class="o">-&gt;</span><span class="n">find</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="n">size_type</span> <span class="n">count</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">contains</span><span class="p">(</span><span class="n">data</span><span class="p">);</span> <span class="p">}</span>

  <span class="n">iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">NodeType</span><span class="o">*</span> <span class="n">head</span> <span class="o">=</span> <span class="n">sl_</span><span class="o">-&gt;</span><span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_consume</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">iterator</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">());</span>
  <span class="p">}</span>
  <span class="n">iterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">iterator</span><span class="p">(</span><span class="n">nullptr</span><span class="p">);</span> <span class="p">}</span>
  <span class="n">const_iterator</span> <span class="n">cbegin</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">begin</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">const_iterator</span> <span class="n">cend</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">end</span><span class="p">();</span> <span class="p">}</span>

  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="n">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">sl_</span><span class="o">-&gt;</span><span class="n">addOrGetData</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">iterator</span><span class="p">(</span><span class="n">ret</span><span class="p">.</span><span class="n">first</span><span class="p">),</span> <span class="n">ret</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kt">size_t</span> <span class="n">erase</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">remove</span><span class="p">(</span><span class="n">data</span><span class="p">);</span> <span class="p">}</span>

  <span class="n">iterator</span> <span class="n">lower_bound</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">iterator</span><span class="p">(</span><span class="n">sl_</span><span class="o">-&gt;</span><span class="n">lower_bound</span><span class="p">(</span><span class="n">data</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="kt">size_t</span> <span class="n">height</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">sl_</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">();</span> <span class="p">}</span></pre></div></td></tr>


<tr id="section-29"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-29">&#182;</a></div><p>if someone has already done the swap, just return.</p></td><td class="code"><div class="highlight"><pre>  <span class="k">const</span> <span class="n">key_type</span> <span class="o">*</span><span class="n">first</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">sl_</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">();</span> <span class="p">}</span>
  <span class="k">const</span> <span class="n">key_type</span> <span class="o">*</span><span class="n">last</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">sl_</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">();</span> <span class="p">}</span></pre></div></td></tr>


<tr id="section-30"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-30">&#182;</a></div><p>Unsafe initializer: the caller assumes the responsibility to keep
skip_list valid during the whole life cycle of the Acessor.</p></td><td class="code"><div class="highlight"><pre>  <span class="n">bool</span> <span class="n">pop_back</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">last</span> <span class="o">=</span> <span class="n">sl_</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">last</span> <span class="o">?</span> <span class="n">sl_</span><span class="o">-&gt;</span><span class="n">remove</span><span class="p">(</span><span class="o">*</span><span class="n">last</span><span class="p">)</span> <span class="o">:</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">key_type</span><span class="o">*</span><span class="p">,</span> <span class="n">bool</span><span class="o">&gt;</span> <span class="n">addOrGetData</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">sl_</span><span class="o">-&gt;</span><span class="n">addOrGetData</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ret</span><span class="p">.</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">(),</span> <span class="n">ret</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">SkipListType</span><span class="o">*</span> <span class="n">skiplist</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">sl_</span><span class="p">;</span> <span class="p">}</span></pre></div></td></tr>


<tr id="section-31"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-31">&#182;</a></div><p>returns end() if the value is not in the list, otherwise returns an
iterator pointing to the data, and it's guaranteed that the data is valid
as far as the Accessor is hold.</p></td><td class="code"><div class="highlight"><pre>  <span class="n">bool</span> <span class="n">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">sl_</span><span class="o">-&gt;</span><span class="n">find</span><span class="p">(</span><span class="n">data</span><span class="p">);</span> <span class="p">}</span>
  <span class="n">bool</span> <span class="n">add</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">sl_</span><span class="o">-&gt;</span><span class="n">addOrGetData</span><span class="p">(</span><span class="n">data</span><span class="p">).</span><span class="n">second</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">bool</span> <span class="n">remove</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">sl_</span><span class="o">-&gt;</span><span class="n">remove</span><span class="p">(</span><span class="n">data</span><span class="p">);</span> <span class="p">}</span>

 <span class="nl">private:</span>
  <span class="n">SkipListType</span> <span class="o">*</span><span class="n">sl_</span><span class="p">;</span>
  <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">SkipListType</span><span class="o">&gt;</span> <span class="n">slHolder_</span><span class="p">;</span>
<span class="p">};</span></pre></div></td></tr>


<tr id="section-32"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-32">&#182;</a></div><p>first() returns pointer to the first element in the skiplist, or
nullptr if empty.</p>

<p>last() returns the pointer to the last element in the skiplist,
nullptr if list is empty.</p>

<p>Note: As concurrent writing can happen, first() is not
  guaranteed to be the min<em>element() in the list. Similarly
  last() is not guaranteed to be the max</em>element(), and both of them can
  be invalid (i.e. nullptr), so we name them differently from front() and
  tail() here.</p></td><td class="code"><div class="highlight"><pre><span class="n">template</span><span class="o">&lt;</span><span class="kr">typename</span> <span class="n">ValT</span><span class="p">,</span> <span class="kr">typename</span> <span class="n">NodeT</span><span class="o">&gt;</span>
<span class="n">class</span> <span class="n">detail</span><span class="o">::</span><span class="n">csl_iterator</span> <span class="o">:</span>
  <span class="n">public</span> <span class="n">boost</span><span class="o">::</span><span class="n">iterator_facade</span><span class="o">&lt;</span><span class="n">csl_iterator</span><span class="o">&lt;</span><span class="n">ValT</span><span class="p">,</span> <span class="n">NodeT</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">ValT</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">forward_traversal_tag</span><span class="o">&gt;</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">typedef</span> <span class="n">ValT</span> <span class="n">value_type</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">reference</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">value_type</span><span class="o">*</span> <span class="n">pointer</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="kt">ptrdiff_t</span> <span class="n">difference_type</span><span class="p">;</span>

  <span class="n">explicit</span> <span class="nf">csl_iterator</span><span class="p">(</span><span class="n">NodeT</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">)</span> <span class="o">:</span> <span class="n">node_</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{}</span>

  <span class="n">template</span><span class="o">&lt;</span><span class="kr">typename</span> <span class="n">OtherVal</span><span class="p">,</span> <span class="kr">typename</span> <span class="n">OtherNode</span><span class="o">&gt;</span>
  <span class="n">csl_iterator</span><span class="p">(</span><span class="k">const</span> <span class="n">csl_iterator</span><span class="o">&lt;</span><span class="n">OtherVal</span><span class="p">,</span> <span class="n">OtherNode</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">,</span>
      <span class="kr">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_convertible</span><span class="o">&lt;</span><span class="n">OtherVal</span><span class="p">,</span> <span class="n">ValT</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">*</span>
      <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">node_</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">node_</span><span class="p">)</span> <span class="p">{}</span>

  <span class="kt">size_t</span> <span class="n">nodeSize</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">node_</span> <span class="o">==</span> <span class="n">nullptr</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span>
      <span class="n">node_</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">()</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">NodeT</span><span class="o">*</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">this</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">bool</span> <span class="n">good</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">node_</span> <span class="o">!=</span> <span class="n">nullptr</span><span class="p">;</span> <span class="p">}</span>

 <span class="nl">private:</span>
  <span class="n">friend</span> <span class="n">class</span> <span class="n">boost</span><span class="o">::</span><span class="n">iterator_core_access</span><span class="p">;</span>
  <span class="n">template</span><span class="o">&lt;</span><span class="n">class</span><span class="p">,</span><span class="n">class</span><span class="o">&gt;</span> <span class="n">friend</span> <span class="n">class</span> <span class="n">csl_iterator</span><span class="p">;</span>

  <span class="kt">void</span> <span class="nf">increment</span><span class="p">()</span> <span class="p">{</span> <span class="n">node_</span> <span class="o">=</span> <span class="n">node_</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">();</span> <span class="p">};</span>
  <span class="n">bool</span> <span class="n">equal</span><span class="p">(</span><span class="k">const</span> <span class="n">csl_iterator</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">node_</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">node_</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">dereference</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">node_</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">();</span> <span class="p">}</span>

  <span class="n">NodeT</span><span class="o">*</span> <span class="n">node_</span><span class="p">;</span>
<span class="p">};</span></pre></div></td></tr>


<tr id="section-33"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-33">&#182;</a></div><p>Try to remove the last element in the skip list.</p>

<p>Returns true if we removed it, false if either the list is empty
or a race condition happened (i.e. the used-to-be last element
was already removed by another thread).</p></td><td class="code"><div class="highlight"><pre><span class="n">template</span><span class="o">&lt;</span><span class="kr">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kr">typename</span> <span class="n">Comp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">MAX_HEIGHT</span><span class="o">&gt;</span>
<span class="n">class</span> <span class="n">ConcurrentSkipList</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Comp</span><span class="p">,</span> <span class="n">MAX_HEIGHT</span><span class="o">&gt;::</span><span class="n">Skipper</span> <span class="p">{</span>
  <span class="k">typedef</span> <span class="n">detail</span><span class="o">::</span><span class="n">SkipListNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">NodeType</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">ConcurrentSkipList</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Comp</span><span class="p">,</span> <span class="n">MAX_HEIGHT</span><span class="o">&gt;</span> <span class="n">SkipListType</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="kr">typename</span> <span class="n">SkipListType</span><span class="o">::</span><span class="n">Accessor</span> <span class="n">Accessor</span><span class="p">;</span>

 <span class="nl">public:</span>
  <span class="k">typedef</span> <span class="n">T</span>  <span class="n">value_type</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">reference</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">T</span><span class="o">*</span> <span class="n">pointer</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="kt">ptrdiff_t</span> <span class="n">difference_type</span><span class="p">;</span>

  <span class="n">Skipper</span><span class="p">(</span><span class="k">const</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">SkipListType</span><span class="o">&gt;&amp;</span> <span class="n">skipList</span><span class="p">)</span> <span class="o">:</span>
    <span class="n">accessor_</span><span class="p">(</span><span class="n">skipList</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">init</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">Skipper</span><span class="p">(</span><span class="k">const</span> <span class="n">Accessor</span><span class="o">&amp;</span> <span class="n">accessor</span><span class="p">)</span> <span class="o">:</span> <span class="n">accessor_</span><span class="p">(</span><span class="n">accessor</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">init</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-34"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-34">&#182;</a></div><p>legacy interfaces
TODO:(xliu) remove these.
Returns true if the node is added successfully, false if not, i.e. the
node with the same key already existed in the list.</p></td><td class="code"><div class="highlight"><pre>    <span class="n">NodeType</span><span class="o">*</span> <span class="n">head_node</span> <span class="o">=</span> <span class="n">head</span><span class="p">();</span>
    <span class="n">headHeight_</span> <span class="o">=</span> <span class="n">head_node</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">headHeight_</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">preds_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">head_node</span><span class="p">;</span>
      <span class="n">succs_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">head_node</span><span class="o">-&gt;</span><span class="n">skip</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">max_layer</span> <span class="o">=</span> <span class="n">maxLayer</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_layer</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">hints_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">hints_</span><span class="p">[</span><span class="n">max_layer</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_layer</span><span class="p">;</span>
  <span class="p">}</span></pre></div></td></tr>


<tr id="section-35"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-35">&#182;</a></div><p>implements forward iterator concept.</p></td><td class="code"><div class="highlight"><pre>  <span class="n">Skipper</span><span class="o">&amp;</span> <span class="n">operator</span> <span class="o">++</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">preds_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">succs_</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">succs_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">preds_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">skip</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">height</span> <span class="o">=</span> <span class="n">curHeight</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">height</span> <span class="o">&amp;&amp;</span> <span class="n">preds_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">succs_</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">preds_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">succs_</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="n">succs_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">preds_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">skip</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">bool</span> <span class="n">good</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">succs_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">nullptr</span><span class="p">;</span> <span class="p">}</span>

  <span class="kt">int</span> <span class="n">maxLayer</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">headHeight_</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>

  <span class="kt">int</span> <span class="n">curHeight</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span></pre></div></td></tr>


<tr id="section-36"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-36">&#182;</a></div><p>Skipper interface</p></td><td class="code"><div class="highlight"><pre>    <span class="k">return</span> <span class="n">succs_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">?</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">headHeight_</span><span class="p">,</span> <span class="n">succs_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">())</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="n">value_type</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">DCHECK</span><span class="p">(</span><span class="n">succs_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">succs_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">value_type</span> <span class="o">&amp;</span><span class="n">operator</span> <span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">DCHECK</span><span class="p">(</span><span class="n">succs_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">succs_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">value_type</span> <span class="o">*</span><span class="n">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">DCHECK</span><span class="p">(</span><span class="n">succs_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">succs_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="cm">/*</span>
<span class="cm">   * Skip to the position whose data is no less than the parameter.</span>
<span class="cm">   * (I.e. the lower_bound).</span>
<span class="cm">   *</span>
<span class="cm">   * Returns true if the data is found, false otherwise.</span>
<span class="cm">   */</span>
  <span class="n">bool</span> <span class="n">to</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">layer</span> <span class="o">=</span> <span class="n">curHeight</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">layer</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>   <span class="c1">// reaches the end of the list</span>

    <span class="kt">int</span> <span class="n">lyr</span> <span class="o">=</span> <span class="n">hints_</span><span class="p">[</span><span class="n">layer</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">max_layer</span> <span class="o">=</span> <span class="n">maxLayer</span><span class="p">();</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">SkipListType</span><span class="o">::</span><span class="n">greater</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">succs_</span><span class="p">[</span><span class="n">lyr</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="n">lyr</span> <span class="o">&lt;</span> <span class="n">max_layer</span><span class="p">)</span> <span class="p">{</span>
      <span class="o">++</span><span class="n">lyr</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">hints_</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span> <span class="o">=</span> <span class="n">lyr</span><span class="p">;</span>  <span class="c1">// update the hint</span>

    <span class="kt">int</span> <span class="n">foundLayer</span> <span class="o">=</span> <span class="n">SkipListType</span><span class="o">::</span>
      <span class="n">findInsertionPoint</span><span class="p">(</span><span class="n">preds_</span><span class="p">[</span><span class="n">lyr</span><span class="p">],</span> <span class="n">lyr</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">preds_</span><span class="p">,</span> <span class="n">succs_</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">foundLayer</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

    <span class="n">DCHECK</span><span class="p">(</span><span class="n">succs_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;lyr=&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">lyr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;; max_layer=&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">max_layer</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">!</span><span class="n">succs_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">markedForRemoval</span><span class="p">();</span>
  <span class="p">}</span>

 <span class="nl">private:</span>
  <span class="n">NodeType</span><span class="o">*</span> <span class="n">head</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">accessor_</span><span class="p">.</span><span class="n">skiplist</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">head_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_consume</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">Accessor</span> <span class="n">accessor_</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">headHeight_</span><span class="p">;</span>
  <span class="n">NodeType</span> <span class="o">*</span><span class="n">succs_</span><span class="p">[</span><span class="n">MAX_HEIGHT</span><span class="p">],</span> <span class="o">*</span><span class="n">preds_</span><span class="p">[</span><span class="n">MAX_HEIGHT</span><span class="p">];</span>
  <span class="kt">uint8_t</span> <span class="n">hints_</span><span class="p">[</span><span class="n">MAX_HEIGHT</span><span class="p">];</span>
<span class="p">};</span>

<span class="p">}</span> <span class="c1">// namespace folly</span>

<span class="cp">#endif  </span><span class="c1">// FOLLY_CONCURRENT_SKIP_LIST_H_</span>

</pre></div></td></tr>


<tr id="section-37"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-37">&#182;</a></div><p>need to cache the head node</p></td><td class="code"><div class="highlight"><pre>undefined</pre></div></td></tr>


<tr id="section-38"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-38">&#182;</a></div><p>advance to the next node in the list.</p></td><td class="code"><div class="highlight"><pre>undefined</pre></div></td></tr>


<tr id="section-39"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-39">&#182;</a></div><p>need to cap the height to the cached head height, as the current node
might be some newly inserted node and also during the time period the
head height may have grown.</p></td><td class="code"><div class="highlight"><pre>undefined</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/folly",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
